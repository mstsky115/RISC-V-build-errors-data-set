[    0s] Using BUILD_ROOT=/var/cache/obs/worker/root_10/.mount
[    0s] Using BUILD_ARCH=riscv64
[    0s] Doing kvm build in /var/cache/obs/worker/root_10/root
[    0s] 
[    0s] unknown keyword in config: prefee:
[    0s] 
[    0s] sheep86 started "build python-pytest-flake8.spec" at Sun Feb 19 01:44:17 UTC 2023.
[    0s] 
[    0s] Building python-pytest-flake8 for project 'openSUSE:Factory:RISCV' repository 'standard' arch 'riscv64' srcmd5 'd8b0df5fcc10530aa8900d91e0f4a17b'
[    0s] 
[    0s] processing recipe /var/cache/obs/worker/root_10/.build-srcdir/python-pytest-flake8.spec ...
[    1s] unknown keyword in config: prefee:
[    1s] running changelog2spec --target rpm --file /var/cache/obs/worker/root_10/.build-srcdir/python-pytest-flake8.spec
[    1s] init_buildsystem --configdir /var/run/obs/worker/10/build/configs --cachedir /var/cache/build --prepare --clean --rpmlist /var/cache/obs/worker/root_10/.build.rpmlist /var/cache/obs/worker/root_10/.build-srcdir/python-pytest-flake8.spec build ...
[    1s] unknown keyword in config: prefee:
[    1s] unpacking preinstall image openSUSE:Factory:RISCV/standard/preinstallimage-python [83160fede3a282f635470653fe6cebf8]
[    3s] 
[    3s] copying packages...
[    3s] reordering...unknown keyword in config: prefee:
[    3s] done
[    3s] Detected virtio-serial support
[    4s] booting kvm...
[    4s] ### VM INTERACTION START ###
[    4s] Using virtio-serial support
[    4s] /usr/bin/qemu-kvm -nodefaults -no-reboot -nographic -vga none -cpu host -M pc,accel=kvm,usb=off,dump-guest-core=off,vmport=off -sandbox on -bios /usr/share/qemu/qboot.rom -object rng-random,filename=/dev/hwrng,id=rng0 -device virtio-rng-pci,rng=rng0 -object iothread,id=io0 -runas qemu -net none -kernel /var/cache/obs/worker/root_10/.mount/boot/kernel -initrd /var/cache/obs/worker/root_10/.mount/boot/initrd -append root=/dev/disk/by-id/virtio-0 rootfstype=ext4 rootflags=noatime kvmclock mitigations=off elevator=noop nmi_watchdog=0 rw rd.driver.pre=binfmt_misc oops=panic panic=1 quiet console=hvc0 init=/.build/initvm.x86_64 -m 8192 -drive file=/var/cache/obs/worker/root_10/root,format=raw,if=none,id=disk,cache=unsafe,aio=io_uring -device virtio-blk-pci,iothread=io0,drive=disk,serial=0 -drive file=/var/cache/obs/worker/root_10/swap,format=raw,if=none,id=swap,cache=unsafe,aio=io_uring -device virtio-blk-pci,iothread=io0,drive=swap,serial=1 -device virtio-serial,max_ports=2 -device virtconsole,chardev=virtiocon0 -chardev stdio,id=virtiocon0 -chardev socket,id=monitor,server=on,wait=off,path=/var/cache/obs/worker/root_10/root.qemu/monitor -mon chardev=monitor,mode=readline -smp 6
[    7s] ### VM INTERACTION END ###
[    7s] 2nd stage started in virtual machine
[    8s] machine type: riscv64
[    8s] Linux version: 6.1.12-1-default #1 SMP PREEMPT_DYNAMIC Wed Feb 15 05:31:41 UTC 2023 (373f017)
[    8s] Increasing log level from now on...
[    8s] [    3.258889][  T392] sysrq: Changing Loglevel
[    8s] [    3.259136][  T392] sysrq: Loglevel set to 4
[    8s] Enable sysrq operations
[    8s] Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)
[    8s] no label, UUID=9681259f-ddbe-48ec-b872-aecf7bd597f2
[    8s] swapon: /dev/vdb: found signature [pagesize=4096, signature=swap]
[    8s] swapon: /dev/vdb: pagesize=4096, swapsize=2147483648, devsize=2147483648
[    8s] swapon /dev/vdb
[    8s] WARNING: udev not running, creating extra device nodes
[    9s] logging output to //.build.log...
[    9s] processing recipe /.build-srcdir/python-pytest-flake8.spec ...
[    9s] init_buildsystem --configdir /.build/configs --cachedir /var/cache/build /.build-srcdir/python-pytest-flake8.spec build ...
[    9s] initializing rpm db...
[   10s] querying package ids...
[   15s] unknown keyword in config: prefee:
[   16s] unknown keyword in config: prefee:
[   27s] [1/208] preinstalled aaa_base-84.87+git20220822.6b9f7a3-1.1
[   27s] [2/208] preinstalled aaa_base-malloccheck-84.87+git20220822.6b9f7a3-1.1
[   27s] [3/208] preinstalled attr-2.5.1-1.1
[   27s] [4/208] preinstalled bash-5.2.15-8.1
[   27s] [5/208] preinstalled bash-sh-5.2.15-8.1
[   27s] [6/208] preinstalled binutils-2.39-3.1
[   27s] [7/208] preinstalled brp-check-suse-84.87+git20221115.2f7add6-1.1
[   27s] [8/208] preinstalled build-compare-20221206T204012.bb70754-1.2
[   27s] [9/208] preinstalled build-mkbaselibs-20230215-1.1
[   27s] [10/208] preinstalled bzip2-1.0.8-4.1
[   27s] [11/208] preinstalled chkstat-1599_20221220-1.2
[   27s] [12/208] preinstalled compat-usrmerge-build-84.87-5.1
[   27s] [13/208] preinstalled compat-usrmerge-tools-84.87-5.1
[   27s] [14/208] preinstalled coreutils-9.1-5.1
[   27s] [15/208] preinstalled cpio-2.13-5.1
[   27s] [16/208] preinstalled cpp-12-2.1
[   27s] [17/208] preinstalled cpp12-12.2.1+git749-4.1
[   27s] [18/208] preinstalled crypto-policies-20210917.c9d86d1-1.1
[   27s] [19/208] preinstalled debugedit-5.0-5.1
[   27s] [20/208] preinstalled diffutils-3.9-1.1
[   27s] [21/208] preinstalled dwz-0.15-2.1
[   27s] [22/208] preinstalled elfutils-0.188-3.2
[   27s] [23/208] cumulate fdupes-2.2.1-1.1
[   27s] [24/208] preinstalled file-5.44-1.2
[   27s] [25/208] preinstalled file-magic-5.44-1.2
[   27s] [26/208] preinstalled filesystem-84.87-12.1
[   27s] [27/208] preinstalled fillup-1.42-279.1
[   27s] [28/208] preinstalled findutils-4.9.0-2.1
[   27s] [29/208] preinstalled gawk-5.2.1-2.1
[   27s] [30/208] preinstalled gcc-12-2.1
[   27s] [31/208] preinstalled gcc-PIE-12-2.1
[   27s] [32/208] preinstalled gcc12-12.2.1+git749-4.1
[   27s] [33/208] preinstalled gcc12-PIE-12.2.1+git749-4.1
[   27s] [34/208] preinstalled gettext-runtime-mini-0.21.1-1.1
[   27s] [35/208] preinstalled gettext-tools-mini-0.21.1-1.1
[   27s] [36/208] preinstalled glibc-2.37-1.1
[   27s] [37/208] preinstalled glibc-devel-2.37-1.1
[   27s] [38/208] preinstalled glibc-locale-base-2.37-1.1
[   27s] [39/208] preinstalled grep-3.8-3.1
[   27s] [40/208] preinstalled gzip-1.12-3.1
[   27s] [41/208] preinstalled kernel-obs-build-6.1.12-1.1
[   27s] [42/208] preinstalled libacl1-2.3.1-2.1
[   27s] [43/208] cumulate libalternatives1-1.2+3.b848aad-3.1
[   27s] [44/208] preinstalled libasan8-13.0.1+git5428-6.1
[   27s] [45/208] preinstalled libasm1-0.188-3.2
[   27s] [46/208] preinstalled libatomic1-13.0.1+git5428-6.1
[   27s] [47/208] preinstalled libattr1-2.5.1-1.1
[   27s] [48/208] preinstalled libaudit1-3.0.6-4.1
[   27s] [49/208] preinstalled libblkid1-2.38.1-7.1
[   27s] [50/208] preinstalled libbz2-1-1.0.8-4.1
[   27s] [51/208] preinstalled libcap-ng0-0.8.3-1.1
[   27s] [52/208] preinstalled libcap2-2.67-1.1
[   27s] [53/208] preinstalled libcrypt1-4.4.33-1.1
[   27s] [54/208] preinstalled libctf-nobfd0-2.39-3.1
[   27s] [55/208] preinstalled libctf0-2.39-3.1
[   27s] [56/208] preinstalled libdb-4_8-4.8.30-39.1
[   27s] [57/208] preinstalled libdw1-0.188-3.2
[   27s] [58/208] preinstalled libeconf0-0.5.1-1.1
[   27s] [59/208] preinstalled libelf1-0.188-3.2
[   27s] [60/208] preinstalled libexpat1-2.5.0-2.1
[   27s] [61/208] preinstalled libfdisk1-2.38.1-7.1
[   27s] [62/208] preinstalled libffi8-3.4.4-1.1
[   27s] [63/208] preinstalled libgcc_s1-13.0.1+git5428-6.1
[   27s] [64/208] preinstalled libgcrypt20-1.10.1-1.1
[   27s] [65/208] preinstalled libgdbm6-1.23-1.1
[   27s] [66/208] preinstalled libgdbm_compat4-1.23-1.1
[   27s] [67/208] preinstalled libgmp10-6.2.1-4.1
[   27s] [68/208] preinstalled libgomp1-13.0.1+git5428-6.1
[   27s] [69/208] preinstalled libgpg-error0-1.46-1.1
[   27s] [70/208] preinstalled libisl23-0.25-1.1
[   27s] [71/208] preinstalled liblua5_4-5-5.4.4-8.1
[   27s] [72/208] preinstalled liblzma5-5.4.1-1.1
[   27s] [73/208] preinstalled libmagic1-5.44-1.2
[   27s] [74/208] preinstalled libmount1-2.38.1-7.1
[   27s] [75/208] preinstalled libmpc3-1.3.1-1.2
[   27s] [76/208] preinstalled libmpdec3-2.5.1-2.1
[   27s] [77/208] preinstalled libmpfr6-4.2.0-1.1
[   27s] [78/208] preinstalled libncurses6-6.4.20230128-5.1
[   27s] [79/208] preinstalled libopenssl3-3.0.7-3.1
[   27s] [80/208] preinstalled libpcre2-8-0-10.42-3.2
[   27s] [81/208] preinstalled libpkgconf3-1.8.0-2.1
[   27s] [82/208] preinstalled libpopt0-1.19-1.1
[   27s] [83/208] preinstalled libpython3_10-1_0-3.10.9-2.2
[   27s] [84/208] preinstalled libpython3_11-1_0-3.11.1-4.2
[   27s] [85/208] preinstalled libpython3_8-1_0-3.8.16-3.2
[   27s] [86/208] preinstalled libpython3_9-1_0-3.9.16-3.2
[   27s] [87/208] preinstalled libreadline8-8.2-2.1
[   27s] [88/208] preinstalled librpmbuild9-4.18.0-3.2
[   27s] [89/208] preinstalled libseccomp2-2.5.4-2.1
[   27s] [90/208] preinstalled libselinux1-3.4-2.1
[   27s] [91/208] preinstalled libsemanage-conf-3.4-1.1
[   27s] [92/208] preinstalled libsemanage2-3.4-1.1
[   27s] [93/208] preinstalled libsepol2-3.4-1.1
[   27s] [94/208] preinstalled libsmartcols1-2.38.1-7.1
[   27s] [95/208] preinstalled libstdc++6-13.0.1+git5428-6.1
[   27s] [96/208] preinstalled libsubid4-4.13-3.1
[   27s] [97/208] preinstalled libubsan1-13.0.1+git5428-6.1
[   27s] [98/208] preinstalled libutempter0-1.2.0-3.2
[   27s] [99/208] preinstalled libuuid1-2.38.1-7.1
[   27s] [100/208] preinstalled libxcrypt-devel-4.4.33-1.1
[   27s] [101/208] preinstalled libz1-1.2.13-2.1
[   27s] [102/208] preinstalled libzstd1-1.5.2-2.1
[   27s] [103/208] preinstalled linux-glibc-devel-6.1-1.1
[   27s] [104/208] preinstalled login_defs-4.13-3.1
[   27s] [105/208] preinstalled lua54-5.4.4-8.1
[   27s] [106/208] preinstalled make-4.4-2.1
[   27s] [107/208] preinstalled ncurses-utils-6.4.20230128-5.1
[   27s] [108/208] preinstalled pam-1.5.2-12.1
[   27s] [109/208] preinstalled patch-2.7.6-6.1
[   27s] [110/208] preinstalled perl-5.36.0-4.1
[   27s] [111/208] preinstalled perl-base-5.36.0-4.1
[   27s] [112/208] preinstalled permissions-1599_20221220-1.2
[   27s] [113/208] preinstalled permissions-config-1599_20221220-1.2
[   27s] [114/208] preinstalled pkgconf-1.8.0-2.1
[   27s] [115/208] preinstalled pkgconf-m4-1.8.0-2.1
[   27s] [116/208] preinstalled pkgconf-pkg-config-1.8.0-2.1
[   27s] [117/208] preinstalled polkit-default-privs-1550+20221102.9f111fa-1.1
[   27s] [118/208] preinstalled post-build-checks-84.87+git20230106.3a359c5-1.1
[   27s] [119/208] preinstalled python-rpm-macros-20230128.e704796-1.2
[   27s] [120/208] preinstalled python-rpm-packaging-20210526+a18ca48-1.2
[   27s] [121/208] cumulate python310-apipkg-3.0.1-1.2
[   27s] [122/208] cumulate python310-attrs-22.2.0-1.2
[   27s] [123/208] preinstalled python310-base-3.10.9-2.2
[   27s] [124/208] cumulate python310-exceptiongroup-1.1.0-1.2
[   27s] [125/208] cumulate python310-flake8-6.0.0-1.3
[   27s] [126/208] cumulate python310-iniconfig-1.1.1-3.2
[   27s] [127/208] cumulate python310-mccabe-0.7.0-1.2
[   27s] [128/208] preinstalled python310-packaging-23.0-1.1
[   27s] [129/208] cumulate python310-pluggy-1.0.0-1.5
[   27s] [130/208] cumulate python310-pycodestyle-2.10.0-4.2
[   27s] [131/208] cumulate python310-pyflakes-3.0.1-3.3
[   27s] [132/208] preinstalled python310-setuptools-65.6.3-1.2
[   27s] [133/208] cumulate python310-tomli-2.0.1-1.3
[   27s] [134/208] cumulate python310-zipp-3.8.1-1.2
[   27s] [135/208] cumulate python311-apipkg-3.0.1-1.2
[   27s] [136/208] cumulate python311-attrs-22.2.0-1.2
[   27s] [137/208] preinstalled python311-base-3.11.1-4.2
[   27s] [138/208] cumulate python311-exceptiongroup-1.1.0-1.2
[   27s] [139/208] cumulate python311-flake8-6.0.0-1.3
[   27s] [140/208] cumulate python311-iniconfig-1.1.1-3.2
[   27s] [141/208] cumulate python311-mccabe-0.7.0-1.2
[   27s] [142/208] cumulate python311-packaging-23.0-1.2
[   27s] [143/208] cumulate python311-pluggy-1.0.0-1.5
[   27s] [144/208] cumulate python311-pycodestyle-2.10.0-4.2
[   27s] [145/208] cumulate python311-pyflakes-3.0.1-3.3
[   27s] [146/208] preinstalled python311-setuptools-65.6.3-1.2
[   27s] [147/208] cumulate python311-tomli-2.0.1-1.3
[   27s] [148/208] cumulate python311-zipp-3.8.1-1.2
[   27s] [149/208] cumulate python38-apipkg-3.0.1-1.2
[   27s] [150/208] cumulate python38-attrs-22.2.0-1.2
[   27s] [151/208] preinstalled python38-base-3.8.16-3.2
[   27s] [152/208] cumulate python38-exceptiongroup-1.1.0-1.2
[   27s] [153/208] cumulate python38-flake8-6.0.0-1.3
[   27s] [154/208] cumulate python38-iniconfig-1.1.1-3.2
[   27s] [155/208] cumulate python38-mccabe-0.7.0-1.2
[   27s] [156/208] cumulate python38-packaging-23.0-1.2
[   27s] [157/208] cumulate python38-pluggy-1.0.0-1.5
[   27s] [158/208] cumulate python38-pycodestyle-2.10.0-4.2
[   27s] [159/208] cumulate python38-pyflakes-3.0.1-3.3
[   27s] [160/208] preinstalled python38-setuptools-65.6.3-1.2
[   27s] [161/208] cumulate python38-tomli-2.0.1-1.3
[   27s] [162/208] cumulate python38-zipp-3.8.1-1.2
[   27s] [163/208] cumulate python39-apipkg-3.0.1-1.2
[   27s] [164/208] cumulate python39-attrs-22.2.0-1.2
[   27s] [165/208] preinstalled python39-base-3.9.16-3.2
[   27s] [166/208] cumulate python39-exceptiongroup-1.1.0-1.2
[   27s] [167/208] cumulate python39-flake8-6.0.0-1.3
[   27s] [168/208] cumulate python39-iniconfig-1.1.1-3.2
[   27s] [169/208] cumulate python39-mccabe-0.7.0-1.2
[   27s] [170/208] cumulate python39-packaging-23.0-1.2
[   27s] [171/208] cumulate python39-pluggy-1.0.0-1.5
[   27s] [172/208] cumulate python39-pycodestyle-2.10.0-4.2
[   27s] [173/208] cumulate python39-pyflakes-3.0.1-3.3
[   27s] [174/208] preinstalled python39-setuptools-65.6.3-1.2
[   27s] [175/208] cumulate python39-tomli-2.0.1-1.3
[   27s] [176/208] cumulate python39-zipp-3.8.1-1.2
[   27s] [177/208] preinstalled qemu-linux-user-7.1.0-50.1
[   27s] [178/208] preinstalled rpm-4.18.0-3.2
[   27s] [179/208] preinstalled rpm-build-4.18.0-3.2
[   27s] [180/208] preinstalled rpm-build-perl-4.18.0-3.2
[   27s] [181/208] preinstalled rpm-config-SUSE-20220926-1.1
[   27s] [182/208] preinstalled rpmlint-mini-2.4.0+git20230214.1bab129-9.4
[   27s] [183/208] preinstalled rpmlint-strict-2.4.0+git20230214.1bab129-1.1
[   27s] [184/208] preinstalled sed-4.9-2.1
[   27s] [185/208] preinstalled shadow-4.13-3.1
[   27s] [186/208] preinstalled system-group-hardware-20170617-24.1
[   27s] [187/208] preinstalled system-user-root-20190513-2.1
[   27s] [188/208] preinstalled systemd-rpm-macros-19-1.1
[   27s] [189/208] preinstalled sysuser-shadow-3.1-5.1
[   27s] [190/208] preinstalled tar-1.34-9.1
[   27s] [191/208] preinstalled terminfo-base-6.4.20230128-5.1
[   27s] [192/208] preinstalled update-alternatives-1.21.8-1.1
[   27s] [193/208] preinstalled util-linux-2.38.1-7.1
[   27s] [194/208] preinstalled which-2.21-5.1
[   27s] [195/208] preinstalled xz-5.4.1-1.1
[   27s] [196/208] cumulate alts-1.2+3.b848aad-3.1
[   27s] [197/208] cumulate python310-importlib-metadata-6.0.0-1.2
[   27s] [198/208] cumulate python311-importlib-metadata-6.0.0-1.2
[   27s] [199/208] cumulate python38-importlib-metadata-6.0.0-1.2
[   27s] [200/208] cumulate python39-importlib-metadata-6.0.0-1.2
[   27s] [201/208] cumulate python310-py-1.11.0-3.2
[   27s] [202/208] cumulate python311-py-1.11.0-3.2
[   27s] [203/208] cumulate python38-py-1.11.0-3.2
[   27s] [204/208] cumulate python39-py-1.11.0-3.2
[   27s] [205/208] cumulate python310-pytest-7.2.0-2.2
[   27s] [206/208] cumulate python311-pytest-7.2.0-2.2
[   27s] [207/208] cumulate python38-pytest-7.2.0-2.2
[   27s] [208/208] cumulate python39-pytest-7.2.0-2.2
[   27s] now installing cumulated packages
[   28s] Preparing...                          ########################################
[   28s] Updating / installing...
[   28s] python39-iniconfig-1.1.1-3.2          ########################################
[   28s] python38-iniconfig-1.1.1-3.2          ########################################
[   28s] python311-iniconfig-1.1.1-3.2         ########################################
[   28s] python310-iniconfig-1.1.1-3.2         ########################################
[   28s] python39-zipp-3.8.1-1.2               ########################################
[   28s] python39-importlib-metadata-6.0.0-1.2 ########################################
[   28s] python39-tomli-2.0.1-1.3              ########################################
[   28s] python39-pyflakes-3.0.1-3.3           ########################################
[   28s] python39-pycodestyle-2.10.0-4.2       ########################################
[   29s] python39-pluggy-1.0.0-1.5             ########################################
[   29s] python39-packaging-23.0-1.2           ########################################
[   29s] python39-mccabe-0.7.0-1.2             ########################################
[   29s] python39-exceptiongroup-1.1.0-1.2     ########################################
[   29s] python39-attrs-22.2.0-1.2             ########################################
[   29s] python39-apipkg-3.0.1-1.2             ########################################
[   29s] python38-zipp-3.8.1-1.2               ########################################
[   29s] python38-importlib-metadata-6.0.0-1.2 ########################################
[   29s] python38-tomli-2.0.1-1.3              ########################################
[   29s] python38-pyflakes-3.0.1-3.3           ########################################
[   29s] python38-pycodestyle-2.10.0-4.2       ########################################
[   29s] python38-pluggy-1.0.0-1.5             ########################################
[   29s] python38-packaging-23.0-1.2           ########################################
[   29s] python38-mccabe-0.7.0-1.2             ########################################
[   29s] python38-exceptiongroup-1.1.0-1.2     ########################################
[   29s] python38-attrs-22.2.0-1.2             ########################################
[   29s] python38-apipkg-3.0.1-1.2             ########################################
[   29s] python311-zipp-3.8.1-1.2              ########################################
[   29s] python311-importlib-metadata-6.0.0-1.2########################################
[   29s] python311-tomli-2.0.1-1.3             ########################################
[   29s] python311-pyflakes-3.0.1-3.3          ########################################
[   30s] python311-pycodestyle-2.10.0-4.2      ########################################
[   30s] python311-pluggy-1.0.0-1.5            ########################################
[   30s] python311-packaging-23.0-1.2          ########################################
[   30s] python311-mccabe-0.7.0-1.2            ########################################
[   30s] python311-exceptiongroup-1.1.0-1.2    ########################################
[   30s] python311-attrs-22.2.0-1.2            ########################################
[   30s] python311-apipkg-3.0.1-1.2            ########################################
[   30s] python310-zipp-3.8.1-1.2              ########################################
[   30s] python310-importlib-metadata-6.0.0-1.2########################################
[   30s] python310-tomli-2.0.1-1.3             ########################################
[   30s] python310-pyflakes-3.0.1-3.3          ########################################
[   30s] python310-pycodestyle-2.10.0-4.2      ########################################
[   30s] python310-pluggy-1.0.0-1.5            ########################################
[   30s] python310-mccabe-0.7.0-1.2            ########################################
[   30s] python310-exceptiongroup-1.1.0-1.2    ########################################
[   31s] python310-attrs-22.2.0-1.2            ########################################
[   31s] python310-apipkg-3.0.1-1.2            ########################################
[   31s] libalternatives1-1.2+3.b848aad-3.1    ########################################
[   31s] alts-1.2+3.b848aad-3.1                ########################################
[   31s] python310-pytest-7.2.0-2.2            ########################################
[   32s] python311-pytest-7.2.0-2.2            ########################################
[   32s] python38-pytest-7.2.0-2.2             ########################################
[   33s] python39-pytest-7.2.0-2.2             ########################################
[   33s] python310-py-1.11.0-3.2               ########################################
[   33s] python310-flake8-6.0.0-1.3            ########################################
[   33s] python311-py-1.11.0-3.2               ########################################
[   33s] python311-flake8-6.0.0-1.3            ########################################
[   33s] python38-py-1.11.0-3.2                ########################################
[   33s] python38-flake8-6.0.0-1.3             ########################################
[   34s] python39-py-1.11.0-3.2                ########################################
[   34s] python39-flake8-6.0.0-1.3             ########################################
[   34s] fdupes-2.2.1-1.1                      ########################################
[   36s] now finalizing build dir...
[   36s] ... running 01-add_abuild_user_to_trusted_group
[   37s] ... running 02-set_timezone_to_utc
[   37s] ... running 03-set-permissions-secure
[   37s] ... running 11-hack_uname_version_to_kernel_version
[   41s] unknown keyword in config: prefee:
[   42s] unknown keyword in config: prefee:
[   42s] -----------------------------------------------------------------
[   42s] I have the following modifications for python-pytest-flake8.spec:
[   42s] 21c21
[   42s] < Release:        0
[   42s] ---
[   42s] > Release:        2.2
[   44s] unknown keyword in config: prefee:
[   45s] unknown keyword in config: prefee:
[   46s] unknown keyword in config: prefee:
[   46s] build target is riscv64-suse-linux
[   46s] -----------------------------------------------------------------
[   46s] ----- building python-pytest-flake8.spec (user abuild)
[   46s] -----------------------------------------------------------------
[   46s] -----------------------------------------------------------------
[   48s] unknown keyword in config: prefee:
[   49s] + exec rpmbuild -ba --define '_srcdefattr (-,root,root)' --nosignature --target=riscv64-suse-linux --define '_build_create_debug 1' --define 'disturl obs://build.opensuse.org/openSUSE:Factory:RISCV/standard/d8b0df5fcc10530aa8900d91e0f4a17b-python-pytest-flake8' /home/abuild/rpmbuild/SOURCES/python-pytest-flake8.spec
[   72s] Building target platforms: riscv64-suse-linux
[   72s] Building for target riscv64-suse-linux
[   72s] setting SOURCE_DATE_EPOCH=1669766400
[   72s] Executing(%prep): /usr/bin/bash -e /var/tmp/rpm-tmp.sf5xR6
[   72s] + umask 022
[   72s] + cd /home/abuild/rpmbuild/BUILD
[   72s] + cd /home/abuild/rpmbuild/BUILD
[   72s] + rm -rf pytest-flake8-1.1.1
[   72s] + /usr/lib/rpm/rpmuncompress -x /home/abuild/rpmbuild/SOURCES/pytest-flake8-1.1.1.tar.gz
[   72s] + STATUS=0
[   72s] + '[' 0 -ne 0 ']'
[   72s] + cd pytest-flake8-1.1.1
[   72s] + /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
[   72s] + /usr/lib/rpm/rpmuncompress /home/abuild/rpmbuild/SOURCES/support-flake8-5.patch
[   72s] + /usr/bin/patch -p1 -s --fuzz=0 --no-backup-if-mismatch -f
[   73s] + RPM_EC=0
[   73s] ++ jobs -p
[   73s] + exit 0
[   73s] Executing(%build): /usr/bin/bash -e /var/tmp/rpm-tmp.QdDzNb
[   73s] + umask 022
[   73s] + cd /home/abuild/rpmbuild/BUILD
[   73s] + /usr/bin/rm -rf /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64
[   73s] ++ dirname /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64
[   73s] + /usr/bin/mkdir -p /home/abuild/rpmbuild/BUILDROOT
[   73s] + /usr/bin/mkdir /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64
[   73s] + cd pytest-flake8-1.1.1
[   73s] + ref=/usr/lib/rpm
[   73s] + mints=0
[   73s] + case $(uname -m) in
[   73s] ++ uname -m
[   73s] + mints=20160911
[   73s] + for s in guess sub
[   73s] ++ find -maxdepth 8 -name config.guess
[   73s] + for s in guess sub
[   73s] ++ find -maxdepth 8 -name config.sub
[   73s] ++ '[' -f _current_flavor ']'
[   73s] ++ true
[   73s] + last_flavor=
[   73s] + '[' -z '' ']'
[   73s] + last_flavor=tmp
[   73s] + '[' tmp '!=' python38 ']'
[   73s] + '[' -d build ']'
[   73s] + '[' -d _build.python38 ']'
[   73s] + echo python38
[   73s] + python_flavor=python38
[   73s] + /usr/bin/python3.8 setup.py build '--executable=/usr/bin/python3.8 -s'
[   76s] running build
[   76s] running build_py
[   76s] creating build
[   76s] creating build/lib
[   76s] copying pytest_flake8.py -> build/lib
[   76s] ++ '[' -f _current_flavor ']'
[   76s] ++ cat _current_flavor
[   76s] + last_flavor=python38
[   76s] + '[' -z python38 ']'
[   76s] + '[' python38 '!=' python39 ']'
[   76s] + '[' -d build ']'
[   76s] + mv build _build.python38
[   76s] + '[' -d _build.python39 ']'
[   76s] + echo python39
[   76s] + python_flavor=python39
[   76s] + /usr/bin/python3.9 setup.py build '--executable=/usr/bin/python3.9 -s'
[   78s] running build
[   78s] running build_py
[   78s] creating build
[   78s] creating build/lib
[   78s] copying pytest_flake8.py -> build/lib
[   78s] ++ '[' -f _current_flavor ']'
[   78s] ++ cat _current_flavor
[   78s] + last_flavor=python39
[   78s] + '[' -z python39 ']'
[   78s] + '[' python39 '!=' python311 ']'
[   78s] + '[' -d build ']'
[   78s] + mv build _build.python39
[   79s] + '[' -d _build.python311 ']'
[   79s] + echo python311
[   79s] + python_flavor=python311
[   79s] + /usr/bin/python3.11 setup.py build '--executable=/usr/bin/python3.11 -s'
[   81s] running build
[   81s] running build_py
[   81s] creating build
[   81s] creating build/lib
[   81s] copying pytest_flake8.py -> build/lib
[   81s] ++ '[' -f _current_flavor ']'
[   81s] ++ cat _current_flavor
[   81s] + last_flavor=python311
[   81s] + '[' -z python311 ']'
[   81s] + '[' python311 '!=' python310 ']'
[   81s] + '[' -d build ']'
[   81s] + mv build _build.python311
[   81s] + '[' -d _build.python310 ']'
[   81s] + echo python310
[   81s] + python_flavor=python310
[   81s] + /usr/bin/python3.10 setup.py build '--executable=/usr/bin/python3.10 -s'
[   83s] running build
[   83s] running build_py
[   83s] creating build
[   83s] creating build/lib
[   83s] copying pytest_flake8.py -> build/lib
[   83s] + RPM_EC=0
[   83s] ++ jobs -p
[   83s] + exit 0
[   84s] Executing(%install): /usr/bin/bash -e /var/tmp/rpm-tmp.SeISVd
[   84s] + umask 022
[   84s] + cd /home/abuild/rpmbuild/BUILD
[   84s] + /usr/bin/rm -rf /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64
[   84s] + /usr/bin/mkdir -p /home/abuild/rpmbuild/BUILDROOT
[   84s] + /usr/bin/mkdir /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64
[   84s] + cd pytest-flake8-1.1.1
[   84s] ++ '[' -f _current_flavor ']'
[   84s] ++ cat _current_flavor
[   84s] + last_flavor=python310
[   84s] + '[' -z python310 ']'
[   84s] + '[' python310 '!=' python38 ']'
[   84s] + '[' -d build ']'
[   84s] + mv build _build.python310
[   84s] + '[' -d _build.python38 ']'
[   84s] + mv _build.python38 build
[   84s] + echo python38
[   84s] + python_flavor=python38
[   84s] + /usr/bin/python3.8 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64 --prefix /usr
[   86s] running install
[   86s] running install_lib
[   87s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr
[   87s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib
[   87s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8
[   87s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages
[   87s] copying build/lib/pytest_flake8.py -> /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages
[   87s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py to pytest_flake8.cpython-38.pyc
[   87s] writing byte-compilation script '/tmp/tmp6mcaml26.py'
[   87s] /usr/bin/python3.8 /tmp/tmp6mcaml26.py
[   89s] removing /tmp/tmp6mcaml26.py
[   89s] running install_egg_info
[   89s] running egg_info
[   89s] writing pytest_flake8.egg-info/PKG-INFO
[   89s] writing dependency_links to pytest_flake8.egg-info/dependency_links.txt
[   89s] writing entry points to pytest_flake8.egg-info/entry_points.txt
[   89s] writing requirements to pytest_flake8.egg-info/requires.txt
[   89s] writing top-level names to pytest_flake8.egg-info/top_level.txt
[   89s] reading manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[   89s] reading manifest template 'MANIFEST.in'
[   89s] /usr/lib/python3.8/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[   89s]   warnings.warn(
[   89s] warning: no directories found matching 'doc'
[   89s] warning: no directories found matching 'test_flake8.py'
[   89s] adding license file 'LICENSE'
[   89s] writing manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[   89s] Copying pytest_flake8.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8-1.1.1-py3.8.egg-info
[   89s] running install_scripts
[   90s] ++ '[' -f _current_flavor ']'
[   90s] ++ cat _current_flavor
[   90s] + last_flavor=python38
[   90s] + '[' -z python38 ']'
[   90s] + '[' python38 '!=' python39 ']'
[   90s] + '[' -d build ']'
[   90s] + mv build _build.python38
[   90s] + '[' -d _build.python39 ']'
[   90s] + mv _build.python39 build
[   90s] + echo python39
[   90s] + python_flavor=python39
[   90s] + /usr/bin/python3.9 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64 --prefix /usr
[   92s] running install
[   92s] /usr/lib/python3.9/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[   92s]   warnings.warn(
[   92s] running install_lib
[   92s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9
[   92s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9/site-packages
[   92s] copying build/lib/pytest_flake8.py -> /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9/site-packages
[   92s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9/site-packages/pytest_flake8.py to pytest_flake8.cpython-39.pyc
[   92s] writing byte-compilation script '/tmp/tmp7qkku_lq.py'
[   92s] /usr/bin/python3.9 /tmp/tmp7qkku_lq.py
[   94s] removing /tmp/tmp7qkku_lq.py
[   94s] running install_egg_info
[   94s] running egg_info
[   94s] writing pytest_flake8.egg-info/PKG-INFO
[   94s] writing dependency_links to pytest_flake8.egg-info/dependency_links.txt
[   94s] writing entry points to pytest_flake8.egg-info/entry_points.txt
[   94s] writing requirements to pytest_flake8.egg-info/requires.txt
[   94s] writing top-level names to pytest_flake8.egg-info/top_level.txt
[   95s] reading manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[   95s] reading manifest template 'MANIFEST.in'
[   95s] warning: no directories found matching 'doc'
[   95s] warning: no directories found matching 'test_flake8.py'
[   95s] adding license file 'LICENSE'
[   95s] writing manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[   95s] Copying pytest_flake8.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9/site-packages/pytest_flake8-1.1.1-py3.9.egg-info
[   95s] running install_scripts
[   95s] ++ '[' -f _current_flavor ']'
[   95s] ++ cat _current_flavor
[   95s] + last_flavor=python39
[   95s] + '[' -z python39 ']'
[   95s] + '[' python39 '!=' python311 ']'
[   95s] + '[' -d build ']'
[   95s] + mv build _build.python39
[   95s] + '[' -d _build.python311 ']'
[   95s] + mv _build.python311 build
[   95s] + echo python311
[   95s] + python_flavor=python311
[   95s] + /usr/bin/python3.11 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64 --prefix /usr
[   97s] running install
[   97s] /usr/lib/python3.11/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[   97s]   warnings.warn(
[   97s] running install_lib
[   97s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11
[   97s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages
[   97s] copying build/lib/pytest_flake8.py -> /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages
[   97s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages/pytest_flake8.py to pytest_flake8.cpython-311.pyc
[   97s] writing byte-compilation script '/tmp/tmp180e5tgc.py'
[   97s] /usr/bin/python3.11 /tmp/tmp180e5tgc.py
[  100s] removing /tmp/tmp180e5tgc.py
[  100s] running install_egg_info
[  100s] running egg_info
[  100s] writing pytest_flake8.egg-info/PKG-INFO
[  100s] writing dependency_links to pytest_flake8.egg-info/dependency_links.txt
[  100s] writing entry points to pytest_flake8.egg-info/entry_points.txt
[  100s] writing requirements to pytest_flake8.egg-info/requires.txt
[  100s] writing top-level names to pytest_flake8.egg-info/top_level.txt
[  100s] reading manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[  100s] reading manifest template 'MANIFEST.in'
[  100s] warning: no directories found matching 'doc'
[  100s] warning: no directories found matching 'test_flake8.py'
[  100s] adding license file 'LICENSE'
[  100s] writing manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[  100s] Copying pytest_flake8.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages/pytest_flake8-1.1.1-py3.11.egg-info
[  100s] running install_scripts
[  100s] ++ '[' -f _current_flavor ']'
[  100s] ++ cat _current_flavor
[  100s] + last_flavor=python311
[  100s] + '[' -z python311 ']'
[  100s] + '[' python311 '!=' python310 ']'
[  100s] + '[' -d build ']'
[  100s] + mv build _build.python311
[  100s] + '[' -d _build.python310 ']'
[  100s] + mv _build.python310 build
[  100s] + echo python310
[  100s] + python_flavor=python310
[  100s] + /usr/bin/python3.10 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64 --prefix /usr
[  103s] running install
[  103s] /usr/lib/python3.10/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[  103s]   warnings.warn(
[  103s] running install_lib
[  103s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10
[  103s] creating /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10/site-packages
[  103s] copying build/lib/pytest_flake8.py -> /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10/site-packages
[  103s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10/site-packages/pytest_flake8.py to pytest_flake8.cpython-310.pyc
[  103s] writing byte-compilation script '/tmp/tmpi2aoq17j.py'
[  103s] /usr/bin/python3.10 /tmp/tmpi2aoq17j.py
[  105s] removing /tmp/tmpi2aoq17j.py
[  105s] running install_egg_info
[  105s] running egg_info
[  105s] writing pytest_flake8.egg-info/PKG-INFO
[  105s] writing dependency_links to pytest_flake8.egg-info/dependency_links.txt
[  105s] writing entry points to pytest_flake8.egg-info/entry_points.txt
[  105s] writing requirements to pytest_flake8.egg-info/requires.txt
[  105s] writing top-level names to pytest_flake8.egg-info/top_level.txt
[  105s] reading manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[  105s] reading manifest template 'MANIFEST.in'
[  105s] warning: no directories found matching 'doc'
[  105s] warning: no directories found matching 'test_flake8.py'
[  105s] adding license file 'LICENSE'
[  105s] writing manifest file 'pytest_flake8.egg-info/SOURCES.txt'
[  105s] Copying pytest_flake8.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10/site-packages/pytest_flake8-1.1.1-py3.10.egg-info
[  105s] running install_scripts
[  106s] ++ '[' -f _current_flavor ']'
[  106s] ++ cat _current_flavor
[  106s] + last_flavor=python310
[  106s] + '[' -z python310 ']'
[  106s] + '[' python310 '!=' python38 ']'
[  106s] + '[' -d build ']'
[  106s] + mv build _build.python310
[  106s] + '[' -d _build.python38 ']'
[  106s] + mv _build.python38 build
[  106s] + echo python38
[  106s] + python_flavor=python38
[  106s] + /usr/lib/rpm/fdupes_wrapper /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages
[  106s] ++ '[' -f _current_flavor ']'
[  106s] ++ cat _current_flavor
[  106s] + last_flavor=python38
[  106s] + '[' -z python38 ']'
[  106s] + '[' python38 '!=' python39 ']'
[  106s] + '[' -d build ']'
[  106s] + mv build _build.python38
[  106s] + '[' -d _build.python39 ']'
[  106s] + mv _build.python39 build
[  106s] + echo python39
[  106s] + python_flavor=python39
[  106s] + /usr/lib/rpm/fdupes_wrapper /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.9/site-packages
[  107s] ++ '[' -f _current_flavor ']'
[  107s] ++ cat _current_flavor
[  107s] + last_flavor=python39
[  107s] + '[' -z python39 ']'
[  107s] + '[' python39 '!=' python311 ']'
[  107s] + '[' -d build ']'
[  107s] + mv build _build.python39
[  107s] + '[' -d _build.python311 ']'
[  107s] + mv _build.python311 build
[  107s] + echo python311
[  107s] + python_flavor=python311
[  107s] + /usr/lib/rpm/fdupes_wrapper /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages
[  107s] Linking /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages/__pycache__/pytest_flake8.cpython-311.opt-1.pyc -> /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.11/site-packages/__pycache__/pytest_flake8.cpython-311.pyc
[  107s] ++ '[' -f _current_flavor ']'
[  107s] ++ cat _current_flavor
[  107s] + last_flavor=python311
[  107s] + '[' -z python311 ']'
[  107s] + '[' python311 '!=' python310 ']'
[  107s] + '[' -d build ']'
[  107s] + mv build _build.python311
[  107s] + '[' -d _build.python310 ']'
[  107s] + mv _build.python310 build
[  107s] + echo python310
[  107s] + python_flavor=python310
[  107s] + /usr/lib/rpm/fdupes_wrapper /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.10/site-packages
[  107s] + /usr/lib/rpm/find-debuginfo -j6 -n --run-dwz --dwz-low-mem-die-limit 10000000 --dwz-max-die-limit 50000000 -S debugsourcefiles.list /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1
[  107s] + /usr/lib/rpm/brp-compress
[  108s] + /usr/lib/rpm/brp-suse
[  108s] calling /usr/lib/rpm/brp-suse.d/brp-05-permissions
[  108s] calling /usr/lib/rpm/brp-suse.d/brp-15-strip-debug
[  108s] calling /usr/lib/rpm/brp-suse.d/brp-25-symlink
[  108s] calling /usr/lib/rpm/brp-suse.d/brp-50-generate-fips-hmac
[  108s] calling /usr/lib/rpm/brp-suse.d/brp-75-ar
[  108s] Executing(%check): /usr/bin/bash -e /var/tmp/rpm-tmp.zud77P
[  108s] + umask 022
[  108s] + cd /home/abuild/rpmbuild/BUILD
[  108s] + cd pytest-flake8-1.1.1
[  108s] + set +x
[  109s] Using libalternatives variant 38 for py.test in XDG_CONFIG_HOME during Python 3.8 expansions.
[  109s] Using libalternatives variant 38 for pytest in XDG_CONFIG_HOME during Python 3.8 expansions.
[  109s] Using alternative flake8-3.8 for flake8 in ./build/flavorbin during Python 3.8 expansions.
[  109s] Using alternative pycodestyle-3.8 for pycodestyle in ./build/flavorbin during Python 3.8 expansions.
[  109s] Using alternative pyflakes-3.8 for pyflakes in ./build/flavorbin during Python 3.8 expansions.
[  109s] Using libalternatives variant 39 for py.test in XDG_CONFIG_HOME during Python 3.9 expansions.
[  109s] Using libalternatives variant 39 for pytest in XDG_CONFIG_HOME during Python 3.9 expansions.
[  109s] Using alternative flake8-3.9 for flake8 in ./build/flavorbin during Python 3.9 expansions.
[  110s] Using alternative pycodestyle-3.9 for pycodestyle in ./build/flavorbin during Python 3.9 expansions.
[  110s] Using alternative pyflakes-3.9 for pyflakes in ./build/flavorbin during Python 3.9 expansions.
[  110s] Using libalternatives variant 311 for py.test in XDG_CONFIG_HOME during Python 3.11 expansions.
[  110s] Using libalternatives variant 311 for pytest in XDG_CONFIG_HOME during Python 3.11 expansions.
[  110s] Using alternative flake8-3.11 for flake8 in ./build/flavorbin during Python 3.11 expansions.
[  110s] Using alternative pycodestyle-3.11 for pycodestyle in ./build/flavorbin during Python 3.11 expansions.
[  111s] Using alternative pyflakes-3.11 for pyflakes in ./build/flavorbin during Python 3.11 expansions.
[  111s] Using alternative flake8-3.10 for flake8 in ./build/flavorbin during Python 3.10 expansions.
[  111s] Using alternative pycodestyle-3.10 for pycodestyle in ./build/flavorbin during Python 3.10 expansions.
[  111s] Using alternative pyflakes-3.10 for pyflakes in ./build/flavorbin during Python 3.10 expansions.
[  111s] + export PATH=/home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/build/flavorbin:/usr/local/bin:/usr/bin:/bin
[  111s] + PATH=/home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/build/flavorbin:/usr/local/bin:/usr/bin:/bin
[  111s] ++ '[' -f _current_flavor ']'
[  111s] ++ cat _current_flavor
[  111s] + last_flavor=python310
[  111s] + '[' -z python310 ']'
[  111s] + '[' python310 '!=' python38 ']'
[  111s] + '[' -d build ']'
[  111s] + mv build _build.python310
[  111s] + '[' -d _build.python38 ']'
[  111s] + mv _build.python38 build
[  111s] + echo python38
[  111s] + python_flavor=python38
[  111s] + PYTHONPATH=/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages
[  111s] + PYTHONDONTWRITEBYTECODE=1
[  111s] + pytest-3.8 --ignore=_build.python38 --ignore=_build.python39 --ignore=_build.python311 --ignore=_build.python310 -v
[  115s] ============================= test session starts ==============================
[  115s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0 -- /usr/bin/python3.8
[  115s] cachedir: .pytest_cache
[  115s] rootdir: /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1, configfile: tox.ini
[  115s] plugins: flake8-1.1.1
[  115s] collecting ... collected 16 items
[  115s] 
[  115s] pytest_flake8.py::flake-8::FLAKE8 FAILED                                 [  6%]
[  116s] setup.py::flake-8::FLAKE8 FAILED                                         [ 12%]
[  116s] test_flake8.py::flake-8::FLAKE8 FAILED                                   [ 18%]
[  116s] test_flake8.py::test_version PASSED                                      [ 25%]
[  116s] test_flake8.py::TestIgnores::test_ignores PASSED                         [ 31%]
[  118s] test_flake8.py::TestIgnores::test_default_flake8_ignores FAILED          [ 37%]
[  119s] test_flake8.py::TestIgnores::test_ignores_all FAILED                     [ 43%]
[  120s] test_flake8.py::TestIgnores::test_w293w292 FAILED                        [ 50%]
[  122s] test_flake8.py::TestIgnores::test_mtime_caching FAILED                   [ 56%]
[  123s] test_flake8.py::test_extensions PASSED                                   [ 62%]
[  125s] test_flake8.py::test_ok_verbose FAILED                                   [ 68%]
[  126s] test_flake8.py::test_keyword_match FAILED                                [ 75%]
[  127s] test_flake8.py::test_run_on_init_file FAILED                             [ 81%]
[  127s] test_flake8.py::test_unicode_error PASSED                                [ 87%]
[  127s] test_flake8.py::test_strict XFAIL (flake8 is not properly registered...) [ 93%]
[  129s] test_flake8.py::test_junit_classname FAILED                              [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004ac0820>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4003169f70>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d32a00>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/pytest_flake8.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e62ca0>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4003169f70>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x400505d910>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/setup.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e62af0>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4003169f70>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x40050e5160>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] ../../BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] ___________________ TestIgnores.test_default_flake8_ignores ____________________
[  129s] 
[  129s] self = <test_flake8.TestIgnores object at 0x4004d32dc0>
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_default_flake8_ignores0')>
[  129s] 
[  129s]     def test_default_flake8_ignores(self, testdir):
[  129s]         testdir.makeini("""
[  129s]             [pytest]
[  129s]             markers = flake8
[  129s]     
[  129s]             [flake8]
[  129s]             ignore = E203
[  129s]                 *.py E300
[  129s]                 tests/*.py ALL E203  # something
[  129s]         """)
[  129s]         testdir.tmpdir.ensure("xy.py")
[  129s]         testdir.tmpdir.ensure("tests/hello.py")
[  129s]         result = testdir.runpytest("--flake8", "-s")
[  129s] >       result.assert_outcomes(passed=2)
[  129s] E       AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
[  129s] E         Omitting 4 identical items, use -vv to show
[  129s] E         Differing items:
[  129s] E         {'passed': 0} != {'passed': 2}
[  129s] E         {'failed': 2} != {'failed': 0}
[  129s] E         Full diff:
[  129s] E           {
[  129s] E            'errors': 0,...
[  129s] E         
[  129s] E         ...Full output truncated (13 lines hidden), use '-vv' to show
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:53: AssertionError
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_default_flake8_ignores0, configfile: tox.ini
[  129s] plugins: flake8-1.1.1
[  129s] collected 2 items
[  129s] 
[  129s] xy.py F
[  129s] tests/hello.py F
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e90e50>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4005114280>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d4f880>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004e90ee0>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d4ff70>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_default_flake8_ignores0/xy.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e904c0>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4005114280>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x40051b4520>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004e90f70>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x40051b4220>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_default_flake8_ignores0/tests/hello.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
[  129s] FAILED tests/hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
[  129s] ============================== 2 failed in 1.17s ===============================
[  129s] _________________________ TestIgnores.test_ignores_all _________________________
[  129s] 
[  129s] self = <test_flake8.TestIgnores object at 0x4004d32b20>
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_ignores_all0')>
[  129s] 
[  129s]     def test_ignores_all(self, testdir):
[  129s]         """Verify success when all errors are ignored."""
[  129s]         testdir.makeini("""
[  129s]             [pytest]
[  129s]             markers = flake8
[  129s]             flake8-ignore = E203
[  129s]                 *.py E300
[  129s]                 tests/*.py ALL E203 # something
[  129s]         """)
[  129s]         testdir.tmpdir.ensure("xy.py")
[  129s]         testdir.tmpdir.ensure("tests/hello.py")
[  129s]         result = testdir.runpytest("--flake8", "-s")
[  129s] >       result.assert_outcomes(passed=1)
[  129s] E       AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
[  129s] E         Omitting 4 identical items, use -vv to show
[  129s] E         Differing items:
[  129s] E         {'passed': 0} != {'passed': 1}
[  129s] E         {'failed': 1} != {'failed': 0}
[  129s] E         Full diff:
[  129s] E           {
[  129s] E            'errors': 0,...
[  129s] E         
[  129s] E         ...Full output truncated (13 lines hidden), use '-vv' to show
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:72: AssertionError
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_ignores_all0, configfile: tox.ini
[  129s] plugins: flake8-1.1.1
[  129s] collected 1 item
[  129s] 
[  129s] xy.py F
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _______________________ FLAKE8-check(ignoring E203 E300) _______________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4005101670>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x4004e2f9d0>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004e182b0>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4005101700>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004e18700>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_ignores_all0/xy.py')
[  129s] flake8ignore = ['E203', 'E300'], maxlength = '', maxdoclenght = ''
[  129s] maxcomplexity = '', showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
[  129s] ============================== 1 failed in 0.61s ===============================
[  129s] __________________________ TestIgnores.test_w293w292 ___________________________
[  129s] 
[  129s] self = <test_flake8.TestIgnores object at 0x4004d64610>
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_w293w2920')>
[  129s] example = local('/tmp/pytest-of-abuild/pytest-0/test_w293w2920/test_w293w292.py')
[  129s] 
[  129s]     def test_w293w292(self, testdir, example):
[  129s]         result = testdir.runpytest("--flake8", )
[  129s] >       result.stdout.fnmatch_lines([
[  129s]             # "*plugins*flake8*",
[  129s]             "*W293*",
[  129s]             "*W292*",
[  129s]         ])
[  129s] E       Failed: nomatch: '*W293*'
[  129s] E           and: '============================= test session starts =============================='
[  129s] E           and: 'platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0'
[  129s] E           and: 'rootdir: /tmp/pytest-of-abuild/pytest-0/test_w293w2920'
[  129s] E           and: 'plugins: flake8-1.1.1'
[  129s] E           and: 'collected 1 item'
[  129s] E           and: ''
[  129s] E           and: 'test_w293w292.py F                                                       [100%]'
[  129s] E           and: ''
[  129s] E           and: '=================================== FAILURES ==================================='
[  129s] E           and: '_________________________________ FLAKE8-check _________________________________'
[  129s] E           and: ''
[  129s] E           and: "cls = <class '_pytest.runner.CallInfo'>"
[  129s] E           and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e21f70>'
[  129s] E           and: "when = 'call'"
[  129s] E           and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call('
[  129s] E           and: '        cls,'
[  129s] E           and: '        func: "Callable[[], TResult]",'
[  129s] E           and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
[  129s] E           and: '        reraise: Optional['
[  129s] E           and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
[  129s] E           and: '        ] = None,'
[  129s] E           and: '    ) -> "CallInfo[TResult]":'
[  129s] E           and: '        """Call func, wrapping the result in a CallInfo.'
[  129s] E           and: '    '
[  129s] E           and: '        :param func:'
[  129s] E           and: '            The function to call. Called without arguments.'
[  129s] E           and: '        :param when:'
[  129s] E           and: '            The phase in which the function is called.'
[  129s] E           and: '        :param reraise:'
[  129s] E           and: '            Exception or exceptions that shall propagate if raised by the'
[  129s] E           and: '            function, instead of being wrapped in the CallInfo.'
[  129s] E           and: '        """'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        start = timing.time()'
[  129s] E           and: '        precise_start = timing.perf_counter()'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result: Optional[TResult] = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:339: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:260: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "self = <_HookCaller 'pytest_runtest_call'>, args = ()"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def __call__(self, *args, **kwargs):'
[  129s] E           and: '        if args:'
[  129s] E           and: '            raise TypeError("hook calling supports only keyword arguments")'
[  129s] E           and: '        assert not self.is_historic()'
[  129s] E           and: '    '
[  129s] E           and: '        # This is written to avoid expensive operations when not needed.'
[  129s] E           and: '        if self.spec:'
[  129s] E           and: '            for argname in self.spec.argnames:'
[  129s] E           and: '                if argname not in kwargs:'
[  129s] E           and: '                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())'
[  129s] E           and: '                    warnings.warn('
[  129s] E           and: '                        "Argument(s) {} which are declared in the hookspec "'
[  129s] E           and: '                        "can not be found in this hook call".format(notincall),'
[  129s] E           and: '                        stacklevel=2,'
[  129s] E           and: '                    )'
[  129s] E           and: '                    break'
[  129s] E           and: '    '
[  129s] E           and: '            firstresult = self.spec.opts.get("firstresult")'
[  129s] E           and: '        else:'
[  129s] E           and: '            firstresult = False'
[  129s] E           and: '    '
[  129s] E           and: '>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <_pytest.config.PytestPluginManager object at 0x400533d2e0>'
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _hookexec(self, hook_name, methods, kwargs, firstresult):'
[  129s] E           and: '        # called from all hookcaller instances.'
[  129s] E           and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
[  129s] E           and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:80: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):'
[  129s] E           and: '        before(hook_name, hook_impls, kwargs)'
[  129s] E           and: '        outcome = _Result.from_call('
[  129s] E           and: '            lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '        )'
[  129s] E           and: '        after(outcome, hook_name, hook_impls, kwargs)'
[  129s] E           and: '>       return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:327: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4005092d30>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "cls = <class 'pluggy._result._Result'>"
[  129s] E           and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004e21a60>'
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call(cls, func):'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        result = excinfo = None'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:33: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:324: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '                        res = hook_impl.function(*args)'
[  129s] E           and: '                        if res is not None:'
[  129s] E           and: '                            results.append(res)'
[  129s] E           and: '                            if firstresult:  # halt further impl calls'
[  129s] E           and: '                                break'
[  129s] E           and: '            except BaseException:'
[  129s] E           and: '                excinfo = sys.exc_info()'
[  129s] E           and: '        finally:'
[  129s] E           and: '            if firstresult:  # first result hooks return a single value'
[  129s] E           and: '                outcome = _Result(results[0] if results else None, excinfo)'
[  129s] E           and: '            else:'
[  129s] E           and: '                outcome = _Result(results, excinfo)'
[  129s] E           and: '    '
[  129s] E           and: '            # run all wrapper post-yield blocks'
[  129s] E           and: '            for gen in reversed(teardowns):'
[  129s] E           and: '                try:'
[  129s] E           and: '                    gen.send(outcome)'
[  129s] E           and: '                    _raise_wrapfail(gen, "has second yield")'
[  129s] E           and: '                except StopIteration:'
[  129s] E           and: '                    pass'
[  129s] E           and: '    '
[  129s] E           and: '>           return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x40051d1d60>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '>                       res = hook_impl.function(*args)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:39: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '            item.runtest()'
[  129s] E           and: '        except Exception as e:'
[  129s] E           and: '            # Store trace info to allow postmortem debugging'
[  129s] E           and: '            sys.last_type = type(e)'
[  129s] E           and: '            sys.last_value = e'
[  129s] E           and: '            assert e.__traceback__ is not None'
[  129s] E           and: '            # Skip *this* frame'
[  129s] E           and: '            sys.last_traceback = e.__traceback__.tb_next'
[  129s] E           and: '>           raise e'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:175: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '>           item.runtest()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:167: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def runtest(self):'
[  129s] E           and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
[  129s] E           and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
[  129s] E           and: '             redirect_stdout(to), redirect_stderr(te):'
[  129s] E           and: '>           found_errors = check_file('
[  129s] E           and: '                self.fspath,'
[  129s] E           and: '                self.flake8ignore,'
[  129s] E           and: '                self.maxlength,'
[  129s] E           and: '                self.maxdoclength,'
[  129s] E           and: '                self.maxcomplexity,'
[  129s] E           and: '                self.showsource,'
[  129s] E           and: '                self.statistics'
[  129s] E           and: '            )'
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "path = local('/tmp/pytest-of-abuild/pytest-0/test_w293w2920/test_w293w292.py')"
[  129s] E           and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
[  129s] E           and: 'showsource = [], statistics = []'
[  129s] E           and: ''
[  129s] E           and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
[  129s] E           and: '                   showsource, statistics):'
[  129s] E           and: '        """Run flake8 over a single file, and return the number of failures."""'
[  129s] E           and: '        args = []'
[  129s] E           and: '        if maxlength:'
[  129s] E           and: "            args += ['--max-line-length', maxlength]"
[  129s] E           and: '        if maxdoclenght:'
[  129s] E           and: "            args += ['--max-doc-length', maxdoclenght]"
[  129s] E           and: '        if maxcomplexity:'
[  129s] E           and: "            args += ['--max-complexity', maxcomplexity]"
[  129s] E           and: '        if showsource:'
[  129s] E           and: "            args += ['--show-source']"
[  129s] E           and: '        if statistics:'
[  129s] E           and: "            args += ['--statistics']"
[  129s] E           and: '        args += [str(path)]'
[  129s] E           and: '        app = application.Application()'
[  129s] E           and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
[  129s] E           and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError'
[  129s] E           and: '=========================== short test summary info ============================'
[  129s] E           and: "FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje..."
[  129s] E           and: '============================== 1 failed in 0.57s ==============================='
[  129s] E       remains unmatched: '*W293*'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:81: Failed
[  129s] ---------------------------- Captured stderr setup -----------------------------
[  129s] /tmp/pytest-of-abuild/pytest-0/test_w293w2920
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_w293w2920
[  129s] plugins: flake8-1.1.1
[  129s] collected 1 item
[  129s] 
[  129s] test_w293w292.py F                                                       [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e21f70>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x400533d2e0>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4005092d30>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004e21a60>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x40051d1d60>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_w293w2920/test_w293w292.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
[  129s] ============================== 1 failed in 0.57s ===============================
[  129s] ________________________ TestIgnores.test_mtime_caching ________________________
[  129s] 
[  129s] self = <test_flake8.TestIgnores object at 0x4004d642b0>
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0')>
[  129s] example = local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0/test_mtime_caching.py')
[  129s] 
[  129s]     def test_mtime_caching(self, testdir, example):
[  129s]         testdir.tmpdir.ensure("hello.py")
[  129s]         result = testdir.runpytest("--flake8", )
[  129s] >       result.stdout.fnmatch_lines([
[  129s]             # "*plugins*flake8*",
[  129s]             "*W293*",
[  129s]             "*W292*",
[  129s]         ])
[  129s] E       Failed: nomatch: '*W293*'
[  129s] E           and: '============================= test session starts =============================='
[  129s] E           and: 'platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0'
[  129s] E           and: 'rootdir: /tmp/pytest-of-abuild/pytest-0/test_mtime_caching0'
[  129s] E           and: 'plugins: flake8-1.1.1'
[  129s] E           and: 'collected 2 items'
[  129s] E           and: ''
[  129s] E           and: 'hello.py F                                                               [ 50%]'
[  129s] E           and: 'test_mtime_caching.py F                                                  [100%]'
[  129s] E           and: ''
[  129s] E           and: '=================================== FAILURES ==================================='
[  129s] E           and: '_________________________________ FLAKE8-check _________________________________'
[  129s] E           and: ''
[  129s] E           and: "cls = <class '_pytest.runner.CallInfo'>"
[  129s] E           and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x40051dc1f0>'
[  129s] E           and: "when = 'call'"
[  129s] E           and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call('
[  129s] E           and: '        cls,'
[  129s] E           and: '        func: "Callable[[], TResult]",'
[  129s] E           and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
[  129s] E           and: '        reraise: Optional['
[  129s] E           and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
[  129s] E           and: '        ] = None,'
[  129s] E           and: '    ) -> "CallInfo[TResult]":'
[  129s] E           and: '        """Call func, wrapping the result in a CallInfo.'
[  129s] E           and: '    '
[  129s] E           and: '        :param func:'
[  129s] E           and: '            The function to call. Called without arguments.'
[  129s] E           and: '        :param when:'
[  129s] E           and: '            The phase in which the function is called.'
[  129s] E           and: '        :param reraise:'
[  129s] E           and: '            Exception or exceptions that shall propagate if raised by the'
[  129s] E           and: '            function, instead of being wrapped in the CallInfo.'
[  129s] E           and: '        """'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        start = timing.time()'
[  129s] E           and: '        precise_start = timing.perf_counter()'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result: Optional[TResult] = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:339: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:260: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "self = <_HookCaller 'pytest_runtest_call'>, args = ()"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def __call__(self, *args, **kwargs):'
[  129s] E           and: '        if args:'
[  129s] E           and: '            raise TypeError("hook calling supports only keyword arguments")'
[  129s] E           and: '        assert not self.is_historic()'
[  129s] E           and: '    '
[  129s] E           and: '        # This is written to avoid expensive operations when not needed.'
[  129s] E           and: '        if self.spec:'
[  129s] E           and: '            for argname in self.spec.argnames:'
[  129s] E           and: '                if argname not in kwargs:'
[  129s] E           and: '                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())'
[  129s] E           and: '                    warnings.warn('
[  129s] E           and: '                        "Argument(s) {} which are declared in the hookspec "'
[  129s] E           and: '                        "can not be found in this hook call".format(notincall),'
[  129s] E           and: '                        stacklevel=2,'
[  129s] E           and: '                    )'
[  129s] E           and: '                    break'
[  129s] E           and: '    '
[  129s] E           and: '            firstresult = self.spec.opts.get("firstresult")'
[  129s] E           and: '        else:'
[  129s] E           and: '            firstresult = False'
[  129s] E           and: '    '
[  129s] E           and: '>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <_pytest.config.PytestPluginManager object at 0x40053f4a30>'
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _hookexec(self, hook_name, methods, kwargs, firstresult):'
[  129s] E           and: '        # called from all hookcaller instances.'
[  129s] E           and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
[  129s] E           and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:80: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):'
[  129s] E           and: '        before(hook_name, hook_impls, kwargs)'
[  129s] E           and: '        outcome = _Result.from_call('
[  129s] E           and: '            lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '        )'
[  129s] E           and: '        after(outcome, hook_name, hook_impls, kwargs)'
[  129s] E           and: '>       return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:327: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004f2ce80>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "cls = <class 'pluggy._result._Result'>"
[  129s] E           and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051dcee0>'
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call(cls, func):'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        result = excinfo = None'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:33: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:324: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '                        res = hook_impl.function(*args)'
[  129s] E           and: '                        if res is not None:'
[  129s] E           and: '                            results.append(res)'
[  129s] E           and: '                            if firstresult:  # halt further impl calls'
[  129s] E           and: '                                break'
[  129s] E           and: '            except BaseException:'
[  129s] E           and: '                excinfo = sys.exc_info()'
[  129s] E           and: '        finally:'
[  129s] E           and: '            if firstresult:  # first result hooks return a single value'
[  129s] E           and: '                outcome = _Result(results[0] if results else None, excinfo)'
[  129s] E           and: '            else:'
[  129s] E           and: '                outcome = _Result(results, excinfo)'
[  129s] E           and: '    '
[  129s] E           and: '            # run all wrapper post-yield blocks'
[  129s] E           and: '            for gen in reversed(teardowns):'
[  129s] E           and: '                try:'
[  129s] E           and: '                    gen.send(outcome)'
[  129s] E           and: '                    _raise_wrapfail(gen, "has second yield")'
[  129s] E           and: '                except StopIteration:'
[  129s] E           and: '                    pass'
[  129s] E           and: '    '
[  129s] E           and: '>           return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004f2cd30>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '>                       res = hook_impl.function(*args)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:39: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '            item.runtest()'
[  129s] E           and: '        except Exception as e:'
[  129s] E           and: '            # Store trace info to allow postmortem debugging'
[  129s] E           and: '            sys.last_type = type(e)'
[  129s] E           and: '            sys.last_value = e'
[  129s] E           and: '            assert e.__traceback__ is not None'
[  129s] E           and: '            # Skip *this* frame'
[  129s] E           and: '            sys.last_traceback = e.__traceback__.tb_next'
[  129s] E           and: '>           raise e'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:175: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '>           item.runtest()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:167: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def runtest(self):'
[  129s] E           and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
[  129s] E           and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
[  129s] E           and: '             redirect_stdout(to), redirect_stderr(te):'
[  129s] E           and: '>           found_errors = check_file('
[  129s] E           and: '                self.fspath,'
[  129s] E           and: '                self.flake8ignore,'
[  129s] E           and: '                self.maxlength,'
[  129s] E           and: '                self.maxdoclength,'
[  129s] E           and: '                self.maxcomplexity,'
[  129s] E           and: '                self.showsource,'
[  129s] E           and: '                self.statistics'
[  129s] E           and: '            )'
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "path = local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0/hello.py')"
[  129s] E           and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
[  129s] E           and: 'showsource = [], statistics = []'
[  129s] E           and: ''
[  129s] E           and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
[  129s] E           and: '                   showsource, statistics):'
[  129s] E           and: '        """Run flake8 over a single file, and return the number of failures."""'
[  129s] E           and: '        args = []'
[  129s] E           and: '        if maxlength:'
[  129s] E           and: "            args += ['--max-line-length', maxlength]"
[  129s] E           and: '        if maxdoclenght:'
[  129s] E           and: "            args += ['--max-doc-length', maxdoclenght]"
[  129s] E           and: '        if maxcomplexity:'
[  129s] E           and: "            args += ['--max-complexity', maxcomplexity]"
[  129s] E           and: '        if showsource:'
[  129s] E           and: "            args += ['--show-source']"
[  129s] E           and: '        if statistics:'
[  129s] E           and: "            args += ['--statistics']"
[  129s] E           and: '        args += [str(path)]'
[  129s] E           and: '        app = application.Application()'
[  129s] E           and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
[  129s] E           and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError'
[  129s] E           and: '_________________________________ FLAKE8-check _________________________________'
[  129s] E           and: ''
[  129s] E           and: "cls = <class '_pytest.runner.CallInfo'>"
[  129s] E           and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x40051b8af0>'
[  129s] E           and: "when = 'call'"
[  129s] E           and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call('
[  129s] E           and: '        cls,'
[  129s] E           and: '        func: "Callable[[], TResult]",'
[  129s] E           and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
[  129s] E           and: '        reraise: Optional['
[  129s] E           and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
[  129s] E           and: '        ] = None,'
[  129s] E           and: '    ) -> "CallInfo[TResult]":'
[  129s] E           and: '        """Call func, wrapping the result in a CallInfo.'
[  129s] E           and: '    '
[  129s] E           and: '        :param func:'
[  129s] E           and: '            The function to call. Called without arguments.'
[  129s] E           and: '        :param when:'
[  129s] E           and: '            The phase in which the function is called.'
[  129s] E           and: '        :param reraise:'
[  129s] E           and: '            Exception or exceptions that shall propagate if raised by the'
[  129s] E           and: '            function, instead of being wrapped in the CallInfo.'
[  129s] E           and: '        """'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        start = timing.time()'
[  129s] E           and: '        precise_start = timing.perf_counter()'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result: Optional[TResult] = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:339: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:260: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "self = <_HookCaller 'pytest_runtest_call'>, args = ()"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def __call__(self, *args, **kwargs):'
[  129s] E           and: '        if args:'
[  129s] E           and: '            raise TypeError("hook calling supports only keyword arguments")'
[  129s] E           and: '        assert not self.is_historic()'
[  129s] E           and: '    '
[  129s] E           and: '        # This is written to avoid expensive operations when not needed.'
[  129s] E           and: '        if self.spec:'
[  129s] E           and: '            for argname in self.spec.argnames:'
[  129s] E           and: '                if argname not in kwargs:'
[  129s] E           and: '                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())'
[  129s] E           and: '                    warnings.warn('
[  129s] E           and: '                        "Argument(s) {} which are declared in the hookspec "'
[  129s] E           and: '                        "can not be found in this hook call".format(notincall),'
[  129s] E           and: '                        stacklevel=2,'
[  129s] E           and: '                    )'
[  129s] E           and: '                    break'
[  129s] E           and: '    '
[  129s] E           and: '            firstresult = self.spec.opts.get("firstresult")'
[  129s] E           and: '        else:'
[  129s] E           and: '            firstresult = False'
[  129s] E           and: '    '
[  129s] E           and: '>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <_pytest.config.PytestPluginManager object at 0x40053f4a30>'
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _hookexec(self, hook_name, methods, kwargs, firstresult):'
[  129s] E           and: '        # called from all hookcaller instances.'
[  129s] E           and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
[  129s] E           and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:80: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):'
[  129s] E           and: '        before(hook_name, hook_impls, kwargs)'
[  129s] E           and: '        outcome = _Result.from_call('
[  129s] E           and: '            lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '        )'
[  129s] E           and: '        after(outcome, hook_name, hook_impls, kwargs)'
[  129s] E           and: '>       return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:327: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004d4f7f0>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "cls = <class 'pluggy._result._Result'>"
[  129s] E           and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051b8820>'
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call(cls, func):'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        result = excinfo = None'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:33: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:324: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '                        res = hook_impl.function(*args)'
[  129s] E           and: '                        if res is not None:'
[  129s] E           and: '                            results.append(res)'
[  129s] E           and: '                            if firstresult:  # halt further impl calls'
[  129s] E           and: '                                break'
[  129s] E           and: '            except BaseException:'
[  129s] E           and: '                excinfo = sys.exc_info()'
[  129s] E           and: '        finally:'
[  129s] E           and: '            if firstresult:  # first result hooks return a single value'
[  129s] E           and: '                outcome = _Result(results[0] if results else None, excinfo)'
[  129s] E           and: '            else:'
[  129s] E           and: '                outcome = _Result(results, excinfo)'
[  129s] E           and: '    '
[  129s] E           and: '            # run all wrapper post-yield blocks'
[  129s] E           and: '            for gen in reversed(teardowns):'
[  129s] E           and: '                try:'
[  129s] E           and: '                    gen.send(outcome)'
[  129s] E           and: '                    _raise_wrapfail(gen, "has second yield")'
[  129s] E           and: '                except StopIteration:'
[  129s] E           and: '                    pass'
[  129s] E           and: '    '
[  129s] E           and: '>           return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004d4f8b0>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '>                       res = hook_impl.function(*args)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:39: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '            item.runtest()'
[  129s] E           and: '        except Exception as e:'
[  129s] E           and: '            # Store trace info to allow postmortem debugging'
[  129s] E           and: '            sys.last_type = type(e)'
[  129s] E           and: '            sys.last_value = e'
[  129s] E           and: '            assert e.__traceback__ is not None'
[  129s] E           and: '            # Skip *this* frame'
[  129s] E           and: '            sys.last_traceback = e.__traceback__.tb_next'
[  129s] E           and: '>           raise e'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:175: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '>           item.runtest()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:167: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def runtest(self):'
[  129s] E           and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
[  129s] E           and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
[  129s] E           and: '             redirect_stdout(to), redirect_stderr(te):'
[  129s] E           and: '>           found_errors = check_file('
[  129s] E           and: '                self.fspath,'
[  129s] E           and: '                self.flake8ignore,'
[  129s] E           and: '                self.maxlength,'
[  129s] E           and: '                self.maxdoclength,'
[  129s] E           and: '                self.maxcomplexity,'
[  129s] E           and: '                self.showsource,'
[  129s] E           and: '                self.statistics'
[  129s] E           and: '            )'
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "path = local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0/test_mtime_caching.py')"
[  129s] E           and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
[  129s] E           and: 'showsource = [], statistics = []'
[  129s] E           and: ''
[  129s] E           and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
[  129s] E           and: '                   showsource, statistics):'
[  129s] E           and: '        """Run flake8 over a single file, and return the number of failures."""'
[  129s] E           and: '        args = []'
[  129s] E           and: '        if maxlength:'
[  129s] E           and: "            args += ['--max-line-length', maxlength]"
[  129s] E           and: '        if maxdoclenght:'
[  129s] E           and: "            args += ['--max-doc-length', maxdoclenght]"
[  129s] E           and: '        if maxcomplexity:'
[  129s] E           and: "            args += ['--max-complexity', maxcomplexity]"
[  129s] E           and: '        if showsource:'
[  129s] E           and: "            args += ['--show-source']"
[  129s] E           and: '        if statistics:'
[  129s] E           and: "            args += ['--statistics']"
[  129s] E           and: '        args += [str(path)]'
[  129s] E           and: '        app = application.Application()'
[  129s] E           and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
[  129s] E           and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError'
[  129s] E           and: '=========================== short test summary info ============================'
[  129s] E           and: "FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n..."
[  129s] E           and: "FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
[  129s] E           and: '============================== 2 failed in 1.36s ==============================='
[  129s] E       remains unmatched: '*W293*'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:91: Failed
[  129s] ---------------------------- Captured stderr setup -----------------------------
[  129s] /tmp/pytest-of-abuild/pytest-0/test_mtime_caching0
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_mtime_caching0
[  129s] plugins: flake8-1.1.1
[  129s] collected 2 items
[  129s] 
[  129s] hello.py F                                                               [ 50%]
[  129s] test_mtime_caching.py F                                                  [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x40051dc1f0>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x40053f4a30>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004f2ce80>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051dcee0>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004f2cd30>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0/hello.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x40051b8af0>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x40053f4a30>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d4f7f0>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051b8820>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d4f8b0>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_mtime_caching0/test_mtime_caching.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
[  129s] FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'...
[  129s] ============================== 2 failed in 1.36s ===============================
[  129s] _______________________________ test_ok_verbose ________________________________
[  129s] 
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_ok_verbose0')>
[  129s] 
[  129s]     def test_ok_verbose(testdir):
[  129s]         p = testdir.makepyfile("""
[  129s]             class AClass:
[  129s]                 pass
[  129s]         """)
[  129s]         p = p.write(p.read() + "\n")
[  129s]         result = testdir.runpytest("--flake8", "--verbose")
[  129s]         result.stdout.fnmatch_lines([
[  129s]             "*test_ok_verbose*",
[  129s]         ])
[  129s] >       result.assert_outcomes(passed=1)
[  129s] E       AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
[  129s] E         Omitting 4 identical items, use -vv to show
[  129s] E         Differing items:
[  129s] E         {'passed': 0} != {'passed': 1}
[  129s] E         {'failed': 1} != {'failed': 0}
[  129s] E         Full diff:
[  129s] E           {
[  129s] E            'errors': 0,...
[  129s] E         
[  129s] E         ...Full output truncated (13 lines hidden), use '-vv' to show
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:139: AssertionError
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0 -- /usr/bin/python3.8
[  129s] cachedir: .pytest_cache
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_ok_verbose0
[  129s] plugins: flake8-1.1.1
[  129s] collecting ... collected 1 item
[  129s] 
[  129s] test_ok_verbose.py::flake-8::FLAKE8 FAILED                               [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x400505ee50>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x400534c3a0>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x400510fe50>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051015e0>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004e34d30>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_ok_verbose0/test_ok_verbose.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED test_ok_verbose.py::flake-8::FLAKE8 - AttributeError: 'Application' ob...
[  129s] ============================== 1 failed in 0.57s ===============================
[  129s] ______________________________ test_keyword_match ______________________________
[  129s] 
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_keyword_match0')>
[  129s] 
[  129s]     def test_keyword_match(testdir):
[  129s]         testdir.makepyfile("""
[  129s]             def test_hello():
[  129s]                 a=[ 1,123]
[  129s]                 #
[  129s]         """)
[  129s]         result = testdir.runpytest("--flake8", "-mflake8")
[  129s] >       result.stdout.fnmatch_lines([
[  129s]             "*E201*",
[  129s]             "*1 failed*",
[  129s]         ])
[  129s] E       Failed: nomatch: '*E201*'
[  129s] E           and: '============================= test session starts =============================='
[  129s] E           and: 'platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0'
[  129s] E           and: 'rootdir: /tmp/pytest-of-abuild/pytest-0/test_keyword_match0'
[  129s] E           and: 'plugins: flake8-1.1.1'
[  129s] E           and: 'collected 2 items / 1 deselected / 1 selected'
[  129s] E           and: ''
[  129s] E           and: 'test_keyword_match.py F                                                  [100%]'
[  129s] E           and: ''
[  129s] E           and: '=================================== FAILURES ==================================='
[  129s] E           and: '_________________________________ FLAKE8-check _________________________________'
[  129s] E           and: ''
[  129s] E           and: "cls = <class '_pytest.runner.CallInfo'>"
[  129s] E           and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x40051dc040>'
[  129s] E           and: "when = 'call'"
[  129s] E           and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call('
[  129s] E           and: '        cls,'
[  129s] E           and: '        func: "Callable[[], TResult]",'
[  129s] E           and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
[  129s] E           and: '        reraise: Optional['
[  129s] E           and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
[  129s] E           and: '        ] = None,'
[  129s] E           and: '    ) -> "CallInfo[TResult]":'
[  129s] E           and: '        """Call func, wrapping the result in a CallInfo.'
[  129s] E           and: '    '
[  129s] E           and: '        :param func:'
[  129s] E           and: '            The function to call. Called without arguments.'
[  129s] E           and: '        :param when:'
[  129s] E           and: '            The phase in which the function is called.'
[  129s] E           and: '        :param reraise:'
[  129s] E           and: '            Exception or exceptions that shall propagate if raised by the'
[  129s] E           and: '            function, instead of being wrapped in the CallInfo.'
[  129s] E           and: '        """'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        start = timing.time()'
[  129s] E           and: '        precise_start = timing.perf_counter()'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result: Optional[TResult] = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:339: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:260: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "self = <_HookCaller 'pytest_runtest_call'>, args = ()"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def __call__(self, *args, **kwargs):'
[  129s] E           and: '        if args:'
[  129s] E           and: '            raise TypeError("hook calling supports only keyword arguments")'
[  129s] E           and: '        assert not self.is_historic()'
[  129s] E           and: '    '
[  129s] E           and: '        # This is written to avoid expensive operations when not needed.'
[  129s] E           and: '        if self.spec:'
[  129s] E           and: '            for argname in self.spec.argnames:'
[  129s] E           and: '                if argname not in kwargs:'
[  129s] E           and: '                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())'
[  129s] E           and: '                    warnings.warn('
[  129s] E           and: '                        "Argument(s) {} which are declared in the hookspec "'
[  129s] E           and: '                        "can not be found in this hook call".format(notincall),'
[  129s] E           and: '                        stacklevel=2,'
[  129s] E           and: '                    )'
[  129s] E           and: '                    break'
[  129s] E           and: '    '
[  129s] E           and: '            firstresult = self.spec.opts.get("firstresult")'
[  129s] E           and: '        else:'
[  129s] E           and: '            firstresult = False'
[  129s] E           and: '    '
[  129s] E           and: '>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <_pytest.config.PytestPluginManager object at 0x40053f7070>'
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _hookexec(self, hook_name, methods, kwargs, firstresult):'
[  129s] E           and: '        # called from all hookcaller instances.'
[  129s] E           and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
[  129s] E           and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:80: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):'
[  129s] E           and: '        before(hook_name, hook_impls, kwargs)'
[  129s] E           and: '        outcome = _Result.from_call('
[  129s] E           and: '            lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '        )'
[  129s] E           and: '        after(outcome, hook_name, hook_impls, kwargs)'
[  129s] E           and: '>       return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:327: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004d190d0>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "cls = <class 'pluggy._result._Result'>"
[  129s] E           and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004d92b80>'
[  129s] E           and: ''
[  129s] E           and: '    @classmethod'
[  129s] E           and: '    def from_call(cls, func):'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        result = excinfo = None'
[  129s] E           and: '        try:'
[  129s] E           and: '>           result = func()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:33: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: '>       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)'
[  129s] E           and: '    )'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_manager.py:324: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '                        res = hook_impl.function(*args)'
[  129s] E           and: '                        if res is not None:'
[  129s] E           and: '                            results.append(res)'
[  129s] E           and: '                            if firstresult:  # halt further impl calls'
[  129s] E           and: '                                break'
[  129s] E           and: '            except BaseException:'
[  129s] E           and: '                excinfo = sys.exc_info()'
[  129s] E           and: '        finally:'
[  129s] E           and: '            if firstresult:  # first result hooks return a single value'
[  129s] E           and: '                outcome = _Result(results[0] if results else None, excinfo)'
[  129s] E           and: '            else:'
[  129s] E           and: '                outcome = _Result(results, excinfo)'
[  129s] E           and: '    '
[  129s] E           and: '            # run all wrapper post-yield blocks'
[  129s] E           and: '            for gen in reversed(teardowns):'
[  129s] E           and: '                try:'
[  129s] E           and: '                    gen.send(outcome)'
[  129s] E           and: '                    _raise_wrapfail(gen, "has second yield")'
[  129s] E           and: '                except StopIteration:'
[  129s] E           and: '                    pass'
[  129s] E           and: '    '
[  129s] E           and: '>           return outcome.get_result()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <pluggy._result._Result object at 0x4004d19490>'
[  129s] E           and: ''
[  129s] E           and: '    def get_result(self):'
[  129s] E           and: '        """Get the result(s) for this hook call.'
[  129s] E           and: '    '
[  129s] E           and: '        If the hook was marked as a ``firstresult`` only a single value'
[  129s] E           and: '        will be returned otherwise a list of results.'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        if self._excinfo is None:'
[  129s] E           and: '            return self._result'
[  129s] E           and: '        else:'
[  129s] E           and: '            ex = self._excinfo'
[  129s] E           and: '>           raise ex[1].with_traceback(ex[2])'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_result.py:60: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "hook_name = 'pytest_runtest_call'"
[  129s] E           and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]"
[  129s] E           and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
[  129s] E           and: ''
[  129s] E           and: '    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):'
[  129s] E           and: '        """Execute a call into multiple python functions/methods and return the'
[  129s] E           and: '        result(s).'
[  129s] E           and: '    '
[  129s] E           and: '        ``caller_kwargs`` comes from _HookCaller.__call__().'
[  129s] E           and: '        """'
[  129s] E           and: '        __tracebackhide__ = True'
[  129s] E           and: '        results = []'
[  129s] E           and: '        excinfo = None'
[  129s] E           and: '        try:  # run impl and wrapper setup functions in a loop'
[  129s] E           and: '            teardowns = []'
[  129s] E           and: '            try:'
[  129s] E           and: '                for hook_impl in reversed(hook_impls):'
[  129s] E           and: '                    try:'
[  129s] E           and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
[  129s] E           and: '                    except KeyError:'
[  129s] E           and: '                        for argname in hook_impl.argnames:'
[  129s] E           and: '                            if argname not in caller_kwargs:'
[  129s] E           and: '                                raise HookCallError('
[  129s] E           and: '                                    f"hook call must provide argument {argname!r}"'
[  129s] E           and: '                                )'
[  129s] E           and: '    '
[  129s] E           and: '                    if hook_impl.hookwrapper:'
[  129s] E           and: '                        try:'
[  129s] E           and: '                            gen = hook_impl.function(*args)'
[  129s] E           and: '                            next(gen)  # first yield'
[  129s] E           and: '                            teardowns.append(gen)'
[  129s] E           and: '                        except StopIteration:'
[  129s] E           and: '                            _raise_wrapfail(gen, "did not yield")'
[  129s] E           and: '                    else:'
[  129s] E           and: '>                       res = hook_impl.function(*args)'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/pluggy/_callers.py:39: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '            item.runtest()'
[  129s] E           and: '        except Exception as e:'
[  129s] E           and: '            # Store trace info to allow postmortem debugging'
[  129s] E           and: '            sys.last_type = type(e)'
[  129s] E           and: '            sys.last_value = e'
[  129s] E           and: '            assert e.__traceback__ is not None'
[  129s] E           and: '            # Skip *this* frame'
[  129s] E           and: '            sys.last_traceback = e.__traceback__.tb_next'
[  129s] E           and: '>           raise e'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:175: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'item = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def pytest_runtest_call(item: Item) -> None:'
[  129s] E           and: '        _update_current_test_var(item, "call")'
[  129s] E           and: '        try:'
[  129s] E           and: '            del sys.last_type'
[  129s] E           and: '            del sys.last_value'
[  129s] E           and: '            del sys.last_traceback'
[  129s] E           and: '        except AttributeError:'
[  129s] E           and: '            pass'
[  129s] E           and: '        try:'
[  129s] E           and: '>           item.runtest()'
[  129s] E           and: ''
[  129s] E           and: '/usr/lib/python3.8/site-packages/_pytest/runner.py:167: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: 'self = <Flake8Item flake-8>'
[  129s] E           and: ''
[  129s] E           and: '    def runtest(self):'
[  129s] E           and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
[  129s] E           and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
[  129s] E           and: '             redirect_stdout(to), redirect_stderr(te):'
[  129s] E           and: '>           found_errors = check_file('
[  129s] E           and: '                self.fspath,'
[  129s] E           and: '                self.flake8ignore,'
[  129s] E           and: '                self.maxlength,'
[  129s] E           and: '                self.maxdoclength,'
[  129s] E           and: '                self.maxcomplexity,'
[  129s] E           and: '                self.showsource,'
[  129s] E           and: '                self.statistics'
[  129s] E           and: '            )'
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: '
[  129s] E           and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
[  129s] E           and: ''
[  129s] E           and: "path = local('/tmp/pytest-of-abuild/pytest-0/test_keyword_match0/test_keyword_match.py')"
[  129s] E           and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
[  129s] E           and: 'showsource = [], statistics = []'
[  129s] E           and: ''
[  129s] E           and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
[  129s] E           and: '                   showsource, statistics):'
[  129s] E           and: '        """Run flake8 over a single file, and return the number of failures."""'
[  129s] E           and: '        args = []'
[  129s] E           and: '        if maxlength:'
[  129s] E           and: "            args += ['--max-line-length', maxlength]"
[  129s] E           and: '        if maxdoclenght:'
[  129s] E           and: "            args += ['--max-doc-length', maxdoclenght]"
[  129s] E           and: '        if maxcomplexity:'
[  129s] E           and: "            args += ['--max-complexity', maxcomplexity]"
[  129s] E           and: '        if showsource:'
[  129s] E           and: "            args += ['--show-source']"
[  129s] E           and: '        if statistics:'
[  129s] E           and: "            args += ['--statistics']"
[  129s] E           and: '        args += [str(path)]'
[  129s] E           and: '        app = application.Application()'
[  129s] E           and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
[  129s] E           and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
[  129s] E           and: ''
[  129s] E           and: '/home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError'
[  129s] E           and: '=========================== short test summary info ============================'
[  129s] E           and: "FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
[  129s] E           and: '======================= 1 failed, 1 deselected in 0.58s ========================'
[  129s] E       remains unmatched: '*E201*'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:149: Failed
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_keyword_match0
[  129s] plugins: flake8-1.1.1
[  129s] collected 2 items / 1 deselected / 1 selected
[  129s] 
[  129s] test_keyword_match.py F                                                  [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x40051dc040>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x40053f7070>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d190d0>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004d92b80>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004d19490>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_keyword_match0/test_keyword_match.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'...
[  129s] ======================= 1 failed, 1 deselected in 0.58s ========================
[  129s] ____________________________ test_run_on_init_file _____________________________
[  129s] 
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_run_on_init_file0')>
[  129s] 
[  129s]     def test_run_on_init_file(testdir):
[  129s]         d = testdir.mkpydir("tests")
[  129s]         result = testdir.runpytest("--flake8", d / "__init__.py")
[  129s] >       result.assert_outcomes(passed=1)
[  129s] E       AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
[  129s] E         Omitting 4 identical items, use -vv to show
[  129s] E         Differing items:
[  129s] E         {'passed': 0} != {'passed': 1}
[  129s] E         {'failed': 1} != {'failed': 0}
[  129s] E         Full diff:
[  129s] E           {
[  129s] E            'errors': 0,...
[  129s] E         
[  129s] E         ...Full output truncated (13 lines hidden), use '-vv' to show
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:159: AssertionError
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_run_on_init_file0
[  129s] plugins: flake8-1.1.1
[  129s] collected 1 item
[  129s] 
[  129s] tests/__init__.py F                                                      [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x4004e2ed30>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x400560a130>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4005319fa0>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x4004e2edc0>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4005319a60>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_run_on_init_file0/tests/__init__.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] =========================== short test summary info ============================
[  129s] FAILED tests/__init__.py::flake-8::FLAKE8 - AttributeError: 'Application' obj...
[  129s] ============================== 1 failed in 0.58s ===============================
[  129s] _____________________________ test_junit_classname _____________________________
[  129s] 
[  129s] testdir = <Testdir local('/tmp/pytest-of-abuild/pytest-0/test_junit_classname0')>
[  129s] 
[  129s]     def test_junit_classname(testdir):
[  129s]         testdir.makepyfile("")
[  129s]         result = testdir.runpytest("--flake8", "--junit-xml=TEST.xml")
[  129s]         junit = testdir.tmpdir.join("TEST.xml")
[  129s]         with open(str(junit)) as j_file:
[  129s]             j_text = j_file.read()
[  129s] >       result.assert_outcomes(passed=1)
[  129s] E       AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
[  129s] E         Omitting 4 identical items, use -vv to show
[  129s] E         Differing items:
[  129s] E         {'passed': 0} != {'passed': 1}
[  129s] E         {'failed': 1} != {'failed': 0}
[  129s] E         Full diff:
[  129s] E           {
[  129s] E            'errors': 0,...
[  129s] E         
[  129s] E         ...Full output truncated (13 lines hidden), use '-vv' to show
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILD/pytest-flake8-1.1.1/test_flake8.py:192: AssertionError
[  129s] ----------------------------- Captured stdout call -----------------------------
[  129s] ============================= test session starts ==============================
[  129s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0
[  129s] rootdir: /tmp/pytest-of-abuild/pytest-0/test_junit_classname0
[  129s] plugins: flake8-1.1.1
[  129s] collected 1 item
[  129s] 
[  129s] test_junit_classname.py F                                                [100%]
[  129s] 
[  129s] =================================== FAILURES ===================================
[  129s] _________________________________ FLAKE8-check _________________________________
[  129s] 
[  129s] cls = <class '_pytest.runner.CallInfo'>
[  129s] func = <function call_runtest_hook.<locals>.<lambda> at 0x400531f820>
[  129s] when = 'call'
[  129s] reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(
[  129s]         cls,
[  129s]         func: "Callable[[], TResult]",
[  129s]         when: "Literal['collect', 'setup', 'call', 'teardown']",
[  129s]         reraise: Optional[
[  129s]             Union[Type[BaseException], Tuple[Type[BaseException], ...]]
[  129s]         ] = None,
[  129s]     ) -> "CallInfo[TResult]":
[  129s]         """Call func, wrapping the result in a CallInfo.
[  129s]     
[  129s]         :param func:
[  129s]             The function to call. Called without arguments.
[  129s]         :param when:
[  129s]             The phase in which the function is called.
[  129s]         :param reraise:
[  129s]             Exception or exceptions that shall propagate if raised by the
[  129s]             function, instead of being wrapped in the CallInfo.
[  129s]         """
[  129s]         excinfo = None
[  129s]         start = timing.time()
[  129s]         precise_start = timing.perf_counter()
[  129s]         try:
[  129s] >           result: Optional[TResult] = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:339: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:260: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_HookCaller 'pytest_runtest_call'>, args = ()
[  129s] kwargs = {'item': <Flake8Item flake-8>}, argname = 'item', firstresult = False
[  129s] 
[  129s]     def __call__(self, *args, **kwargs):
[  129s]         if args:
[  129s]             raise TypeError("hook calling supports only keyword arguments")
[  129s]         assert not self.is_historic()
[  129s]     
[  129s]         # This is written to avoid expensive operations when not needed.
[  129s]         if self.spec:
[  129s]             for argname in self.spec.argnames:
[  129s]                 if argname not in kwargs:
[  129s]                     notincall = tuple(set(self.spec.argnames) - kwargs.keys())
[  129s]                     warnings.warn(
[  129s]                         "Argument(s) {} which are declared in the hookspec "
[  129s]                         "can not be found in this hook call".format(notincall),
[  129s]                         stacklevel=2,
[  129s]                     )
[  129s]                     break
[  129s]     
[  129s]             firstresult = self.spec.opts.get("firstresult")
[  129s]         else:
[  129s]             firstresult = False
[  129s]     
[  129s] >       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_hooks.py:265: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <_pytest.config.PytestPluginManager object at 0x40056148e0>
[  129s] hook_name = 'pytest_runtest_call'
[  129s] methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _hookexec(self, hook_name, methods, kwargs, firstresult):
[  129s]         # called from all hookcaller instances.
[  129s]         # enable_tracing will set its own wrapping function at self._inner_hookexec
[  129s] >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:80: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def traced_hookexec(hook_name, hook_impls, kwargs, firstresult):
[  129s]         before(hook_name, hook_impls, kwargs)
[  129s]         outcome = _Result.from_call(
[  129s]             lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]         )
[  129s]         after(outcome, hook_name, hook_impls, kwargs)
[  129s] >       return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:327: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4004e18160>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] cls = <class 'pluggy._result._Result'>
[  129s] func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x40051015e0>
[  129s] 
[  129s]     @classmethod
[  129s]     def from_call(cls, func):
[  129s]         __tracebackhide__ = True
[  129s]         result = excinfo = None
[  129s]         try:
[  129s] >           result = func()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:33: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] >       lambda: oldcall(hook_name, hook_impls, kwargs, firstresult)
[  129s]     )
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_manager.py:324: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s]                         res = hook_impl.function(*args)
[  129s]                         if res is not None:
[  129s]                             results.append(res)
[  129s]                             if firstresult:  # halt further impl calls
[  129s]                                 break
[  129s]             except BaseException:
[  129s]                 excinfo = sys.exc_info()
[  129s]         finally:
[  129s]             if firstresult:  # first result hooks return a single value
[  129s]                 outcome = _Result(results[0] if results else None, excinfo)
[  129s]             else:
[  129s]                 outcome = _Result(results, excinfo)
[  129s]     
[  129s]             # run all wrapper post-yield blocks
[  129s]             for gen in reversed(teardowns):
[  129s]                 try:
[  129s]                     gen.send(outcome)
[  129s]                     _raise_wrapfail(gen, "has second yield")
[  129s]                 except StopIteration:
[  129s]                     pass
[  129s]     
[  129s] >           return outcome.get_result()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <pluggy._result._Result object at 0x4005080370>
[  129s] 
[  129s]     def get_result(self):
[  129s]         """Get the result(s) for this hook call.
[  129s]     
[  129s]         If the hook was marked as a ``firstresult`` only a single value
[  129s]         will be returned otherwise a list of results.
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         if self._excinfo is None:
[  129s]             return self._result
[  129s]         else:
[  129s]             ex = self._excinfo
[  129s] >           raise ex[1].with_traceback(ex[2])
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_result.py:60: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] hook_name = 'pytest_runtest_call'
[  129s] hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.8/site-packages/_pytest/runner...eption', plugin=<module '_pytest.threadexception' from '/usr/lib/python3.8/site-packages/_pytest/threadexception.py'>>]
[  129s] caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False
[  129s] 
[  129s]     def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
[  129s]         """Execute a call into multiple python functions/methods and return the
[  129s]         result(s).
[  129s]     
[  129s]         ``caller_kwargs`` comes from _HookCaller.__call__().
[  129s]         """
[  129s]         __tracebackhide__ = True
[  129s]         results = []
[  129s]         excinfo = None
[  129s]         try:  # run impl and wrapper setup functions in a loop
[  129s]             teardowns = []
[  129s]             try:
[  129s]                 for hook_impl in reversed(hook_impls):
[  129s]                     try:
[  129s]                         args = [caller_kwargs[argname] for argname in hook_impl.argnames]
[  129s]                     except KeyError:
[  129s]                         for argname in hook_impl.argnames:
[  129s]                             if argname not in caller_kwargs:
[  129s]                                 raise HookCallError(
[  129s]                                     f"hook call must provide argument {argname!r}"
[  129s]                                 )
[  129s]     
[  129s]                     if hook_impl.hookwrapper:
[  129s]                         try:
[  129s]                             gen = hook_impl.function(*args)
[  129s]                             next(gen)  # first yield
[  129s]                             teardowns.append(gen)
[  129s]                         except StopIteration:
[  129s]                             _raise_wrapfail(gen, "did not yield")
[  129s]                     else:
[  129s] >                       res = hook_impl.function(*args)
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/pluggy/_callers.py:39: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s]             item.runtest()
[  129s]         except Exception as e:
[  129s]             # Store trace info to allow postmortem debugging
[  129s]             sys.last_type = type(e)
[  129s]             sys.last_value = e
[  129s]             assert e.__traceback__ is not None
[  129s]             # Skip *this* frame
[  129s]             sys.last_traceback = e.__traceback__.tb_next
[  129s] >           raise e
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:175: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] item = <Flake8Item flake-8>
[  129s] 
[  129s]     def pytest_runtest_call(item: Item) -> None:
[  129s]         _update_current_test_var(item, "call")
[  129s]         try:
[  129s]             del sys.last_type
[  129s]             del sys.last_value
[  129s]             del sys.last_traceback
[  129s]         except AttributeError:
[  129s]             pass
[  129s]         try:
[  129s] >           item.runtest()
[  129s] 
[  129s] /usr/lib/python3.8/site-packages/_pytest/runner.py:167: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] self = <Flake8Item flake-8>
[  129s] 
[  129s]     def runtest(self):
[  129s]         with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
[  129s]              BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
[  129s]              redirect_stdout(to), redirect_stderr(te):
[  129s] >           found_errors = check_file(
[  129s]                 self.fspath,
[  129s]                 self.flake8ignore,
[  129s]                 self.maxlength,
[  129s]                 self.maxdoclength,
[  129s]                 self.maxcomplexity,
[  129s]                 self.showsource,
[  129s]                 self.statistics
[  129s]             )
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:136: 
[  129s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  129s] 
[  129s] path = local('/tmp/pytest-of-abuild/pytest-0/test_junit_classname0/test_junit_classname.py')
[  129s] flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
[  129s] showsource = [], statistics = []
[  129s] 
[  129s]     def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
[  129s]                    showsource, statistics):
[  129s]         """Run flake8 over a single file, and return the number of failures."""
[  129s]         args = []
[  129s]         if maxlength:
[  129s]             args += ['--max-line-length', maxlength]
[  129s]         if maxdoclenght:
[  129s]             args += ['--max-doc-length', maxdoclenght]
[  129s]         if maxcomplexity:
[  129s]             args += ['--max-complexity', maxcomplexity]
[  129s]         if showsource:
[  129s]             args += ['--show-source']
[  129s]         if statistics:
[  129s]             args += ['--statistics']
[  129s]         args += [str(path)]
[  129s]         app = application.Application()
[  129s] >       prelim_opts, remaining_args = app.parse_preliminary_options(args)
[  129s] E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'
[  129s] 
[  129s] /home/abuild/rpmbuild/BUILDROOT/python-pytest-flake8-1.1.1-2.2.riscv64/usr/lib/python3.8/site-packages/pytest_flake8.py:217: AttributeError
[  129s] - generated xml file: /tmp/pytest-of-abuild/pytest-0/test_junit_classname0/TEST.xml -
[  129s] =========================== short test summary info ============================
[  129s] FAILED test_junit_classname.py::flake-8::FLAKE8 - AttributeError: 'Applicatio...
[  129s] ============================== 1 failed in 0.72s ===============================
[  129s] =========================== short test summary info ============================
[  129s] FAILED pytest_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
[  129s] FAILED setup.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
[  129s] FAILED test_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
[  129s] FAILED test_flake8.py::TestIgnores::test_default_flake8_ignores - AssertionEr...
[  129s] FAILED test_flake8.py::TestIgnores::test_ignores_all - AssertionError: assert...
[  129s] FAILED test_flake8.py::TestIgnores::test_w293w292 - Failed: nomatch: '*W293*'
[  129s] FAILED test_flake8.py::TestIgnores::test_mtime_caching - Failed: nomatch: '*W...
[  129s] FAILED test_flake8.py::test_ok_verbose - AssertionError: assert {'errors': 0,...
[  129s] FAILED test_flake8.py::test_keyword_match - Failed: nomatch: '*E201*'
[  129s] FAILED test_flake8.py::test_run_on_init_file - AssertionError: assert {'error...
[  129s] FAILED test_flake8.py::test_junit_classname - AssertionError: assert {'errors...
[  129s] =================== 11 failed, 4 passed, 1 xfailed in 14.38s ===================
[  129s] error: Bad exit status from /var/tmp/rpm-tmp.zud77P (%check)
[  129s] 
[  129s] RPM build errors:
[  129s]     Bad exit status from /var/tmp/rpm-tmp.zud77P (%check)
[  129s] ### VM INTERACTION START ###
[  130s] [  124.852299][    T1] sysrq: Power Off
[  130s] [  124.855520][   T18] reboot: Power down
[  130s] ### VM INTERACTION END ###
[  130s] 
[  130s] sheep86 failed "build python-pytest-flake8.spec" at Sun Feb 19 01:46:27 UTC 2023.
[  130s] 
