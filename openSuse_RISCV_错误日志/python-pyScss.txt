[    0s] Using BUILD_ROOT=/var/cache/obs/worker/root_3/.mount
[    0s] Using BUILD_ARCH=riscv64
[    0s] Doing kvm build in /var/cache/obs/worker/root_3/root
[    0s] 
[    0s] 
[    0s] sheep88 started "build python-pyScss.spec" at Sat Feb 18 21:25:24 UTC 2023.
[    0s] 
[    0s] Building python-pyScss for project 'openSUSE:Factory:RISCV' repository 'standard' arch 'riscv64' srcmd5 'bfee0fd2581d1d93b993cdff71876ad8'
[    0s] 
[    0s] processing recipe /var/cache/obs/worker/root_3/.build-srcdir/python-pyScss.spec ...
[    0s] running changelog2spec --target rpm --file /var/cache/obs/worker/root_3/.build-srcdir/python-pyScss.spec
[    0s] init_buildsystem --configdir /var/run/obs/worker/3/build/configs --cachedir /var/cache/build --prepare --clean --rpmlist /var/cache/obs/worker/root_3/.build.rpmlist /var/cache/obs/worker/root_3/.build-srcdir/python-pyScss.spec build ...
[    1s] unpacking preinstall image openSUSE:Factory:RISCV/standard/preinstallimage-python [83160fede3a282f635470653fe6cebf8]
[    4s] 
[    4s] copying packages...
[    4s] reordering...done
[    4s] Detected virtio-serial support
[    5s] booting kvm...
[    5s] ### VM INTERACTION START ###
[    5s] Using virtio-serial support
[    5s] /usr/bin/qemu-kvm -nodefaults -no-reboot -nographic -vga none -cpu host -M pc,accel=kvm,usb=off,dump-guest-core=off,vmport=off -sandbox on -bios /usr/share/qemu/qboot.rom -object rng-random,filename=/dev/hwrng,id=rng0 -device virtio-rng-pci,rng=rng0 -object iothread,id=io0 -runas qemu -net none -kernel /var/cache/obs/worker/root_3/.mount/boot/kernel -initrd /var/cache/obs/worker/root_3/.mount/boot/initrd -append root=/dev/disk/by-id/virtio-0 rootfstype=ext4 rootflags=noatime kvmclock mitigations=off elevator=noop nmi_watchdog=0 rw rd.driver.pre=binfmt_misc oops=panic panic=1 quiet console=hvc0 init=/.build/initvm.x86_64 -m 8192 -drive file=/var/cache/obs/worker/root_3/root,format=raw,if=none,id=disk,cache=unsafe,aio=io_uring -device virtio-blk-pci,iothread=io0,drive=disk,serial=0 -drive file=/var/cache/obs/worker/root_3/swap,format=raw,if=none,id=swap,cache=unsafe,aio=io_uring -device virtio-blk-pci,iothread=io0,drive=swap,serial=1 -device virtio-serial,max_ports=2 -device virtconsole,chardev=virtiocon0 -chardev stdio,id=virtiocon0 -chardev socket,id=monitor,server=on,wait=off,path=/var/cache/obs/worker/root_3/root.qemu/monitor -mon chardev=monitor,mode=readline -smp 6
[    9s] ### VM INTERACTION END ###
[    9s] 2nd stage started in virtual machine
[   10s] machine type: riscv64
[   10s] Linux version: 6.1.12-1-default #1 SMP PREEMPT_DYNAMIC Wed Feb 15 05:31:41 UTC 2023 (373f017)
[   10s] Increasing log level from now on...
[   10s] [    4.114050][  T391] sysrq: Changing Loglevel
[   10s] [    4.114172][  T391] sysrq: Loglevel set to 4
[   10s] Enable sysrq operations
[   10s] Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)
[   10s] no label, UUID=662ea36a-5490-4d9a-9e12-fb2cd10085e9
[   11s] swapon: /dev/vdb: found signature [pagesize=4096, signature=swap]
[   11s] swapon: /dev/vdb: pagesize=4096, swapsize=2147483648, devsize=2147483648
[   11s] swapon /dev/vdb
[   11s] WARNING: udev not running, creating extra device nodes
[   11s] logging output to //.build.log...
[   12s] processing recipe /.build-srcdir/python-pyScss.spec ...
[   12s] init_buildsystem --configdir /.build/configs --cachedir /var/cache/build /.build-srcdir/python-pyScss.spec build ...
[   12s] initializing rpm db...
[   13s] querying package ids...
[   35s] [1/198] preinstalled aaa_base-84.87+git20220822.6b9f7a3-1.1
[   35s] [2/198] preinstalled aaa_base-malloccheck-84.87+git20220822.6b9f7a3-1.1
[   35s] [3/198] preinstalled attr-2.5.1-1.1
[   35s] [4/198] preinstalled bash-5.2.15-8.1
[   35s] [5/198] preinstalled bash-sh-5.2.15-8.1
[   35s] [6/198] preinstalled binutils-2.39-3.1
[   35s] [7/198] preinstalled brp-check-suse-84.87+git20221115.2f7add6-1.1
[   35s] [8/198] preinstalled build-compare-20221206T204012.bb70754-1.2
[   35s] [9/198] preinstalled build-mkbaselibs-20230215-1.1
[   35s] [10/198] preinstalled bzip2-1.0.8-4.1
[   35s] [11/198] preinstalled chkstat-1599_20221220-1.2
[   35s] [12/198] preinstalled compat-usrmerge-build-84.87-5.1
[   35s] [13/198] preinstalled compat-usrmerge-tools-84.87-5.1
[   35s] [14/198] preinstalled coreutils-9.1-5.1
[   35s] [15/198] preinstalled cpio-2.13-5.1
[   35s] [16/198] preinstalled cpp-12-2.1
[   35s] [17/198] preinstalled cpp12-12.2.1+git749-4.1
[   35s] [18/198] preinstalled crypto-policies-20210917.c9d86d1-1.1
[   35s] [19/198] preinstalled debugedit-5.0-5.1
[   35s] [20/198] preinstalled diffutils-3.9-1.1
[   35s] [21/198] preinstalled dwz-0.15-2.1
[   35s] [22/198] preinstalled elfutils-0.188-3.2
[   35s] [23/198] preinstalled file-5.44-1.2
[   35s] [24/198] preinstalled file-magic-5.44-1.2
[   35s] [25/198] preinstalled filesystem-84.87-12.1
[   35s] [26/198] preinstalled fillup-1.42-279.1
[   35s] [27/198] preinstalled findutils-4.9.0-2.1
[   35s] [28/198] preinstalled gawk-5.2.1-2.1
[   35s] [29/198] preinstalled gcc-12-2.1
[   35s] [30/198] preinstalled gcc-PIE-12-2.1
[   35s] [31/198] preinstalled gcc12-12.2.1+git749-4.1
[   35s] [32/198] preinstalled gcc12-PIE-12.2.1+git749-4.1
[   35s] [33/198] preinstalled gettext-runtime-mini-0.21.1-1.1
[   35s] [34/198] preinstalled gettext-tools-mini-0.21.1-1.1
[   35s] [35/198] preinstalled glibc-2.37-1.1
[   35s] [36/198] preinstalled glibc-devel-2.37-1.1
[   35s] [37/198] preinstalled glibc-locale-base-2.37-1.1
[   35s] [38/198] preinstalled grep-3.8-3.1
[   35s] [39/198] preinstalled gzip-1.12-3.1
[   35s] [40/198] preinstalled kernel-obs-build-6.1.12-1.1
[   35s] [41/198] preinstalled libacl1-2.3.1-2.1
[   35s] [42/198] cumulate libalternatives1-1.2+3.b848aad-3.1
[   35s] [43/198] preinstalled libasan8-13.0.1+git5428-6.1
[   35s] [44/198] preinstalled libasm1-0.188-3.2
[   35s] [45/198] preinstalled libatomic1-13.0.1+git5428-6.1
[   35s] [46/198] preinstalled libattr1-2.5.1-1.1
[   35s] [47/198] preinstalled libaudit1-3.0.6-4.1
[   35s] [48/198] preinstalled libblkid1-2.38.1-7.1
[   35s] [49/198] preinstalled libbz2-1-1.0.8-4.1
[   35s] [50/198] preinstalled libcap-ng0-0.8.3-1.1
[   35s] [51/198] preinstalled libcap2-2.67-1.1
[   35s] [52/198] preinstalled libcrypt1-4.4.33-1.1
[   35s] [53/198] preinstalled libctf-nobfd0-2.39-3.1
[   35s] [54/198] preinstalled libctf0-2.39-3.1
[   35s] [55/198] preinstalled libdb-4_8-4.8.30-39.1
[   35s] [56/198] preinstalled libdw1-0.188-3.2
[   35s] [57/198] preinstalled libeconf0-0.5.1-1.1
[   35s] [58/198] preinstalled libelf1-0.188-3.2
[   35s] [59/198] preinstalled libexpat1-2.5.0-2.1
[   35s] [60/198] preinstalled libfdisk1-2.38.1-7.1
[   35s] [61/198] preinstalled libffi8-3.4.4-1.1
[   35s] [62/198] preinstalled libgcc_s1-13.0.1+git5428-6.1
[   35s] [63/198] preinstalled libgcrypt20-1.10.1-1.1
[   35s] [64/198] preinstalled libgdbm6-1.23-1.1
[   35s] [65/198] preinstalled libgdbm_compat4-1.23-1.1
[   35s] [66/198] preinstalled libgmp10-6.2.1-4.1
[   35s] [67/198] preinstalled libgomp1-13.0.1+git5428-6.1
[   35s] [68/198] preinstalled libgpg-error0-1.46-1.1
[   35s] [69/198] preinstalled libisl23-0.25-1.1
[   35s] [70/198] preinstalled liblua5_4-5-5.4.4-8.1
[   35s] [71/198] preinstalled liblzma5-5.4.1-1.1
[   35s] [72/198] preinstalled libmagic1-5.44-1.2
[   35s] [73/198] preinstalled libmount1-2.38.1-7.1
[   35s] [74/198] preinstalled libmpc3-1.3.1-1.2
[   35s] [75/198] preinstalled libmpdec3-2.5.1-2.1
[   35s] [76/198] preinstalled libmpfr6-4.2.0-1.1
[   35s] [77/198] preinstalled libncurses6-6.4.20230128-5.1
[   35s] [78/198] preinstalled libopenssl3-3.0.7-3.1
[   35s] [79/198] cumulate libpcre1-8.45-2.1
[   35s] [80/198] cumulate libpcre16-0-8.45-2.1
[   35s] [81/198] preinstalled libpcre2-8-0-10.42-3.2
[   35s] [82/198] preinstalled libpkgconf3-1.8.0-2.1
[   35s] [83/198] preinstalled libpopt0-1.19-1.1
[   35s] [84/198] preinstalled libpython3_10-1_0-3.10.9-2.2
[   35s] [85/198] preinstalled libpython3_11-1_0-3.11.1-4.2
[   35s] [86/198] preinstalled libpython3_8-1_0-3.8.16-3.2
[   35s] [87/198] preinstalled libpython3_9-1_0-3.9.16-3.2
[   35s] [88/198] preinstalled libreadline8-8.2-2.1
[   35s] [89/198] preinstalled librpmbuild9-4.18.0-3.2
[   35s] [90/198] preinstalled libseccomp2-2.5.4-2.1
[   35s] [91/198] preinstalled libselinux1-3.4-2.1
[   35s] [92/198] preinstalled libsemanage-conf-3.4-1.1
[   35s] [93/198] preinstalled libsemanage2-3.4-1.1
[   35s] [94/198] preinstalled libsepol2-3.4-1.1
[   35s] [95/198] preinstalled libsmartcols1-2.38.1-7.1
[   35s] [96/198] preinstalled libstdc++6-13.0.1+git5428-6.1
[   35s] [97/198] cumulate libstdc++6-devel-gcc12-12.2.1+git749-4.1
[   35s] [98/198] preinstalled libsubid4-4.13-3.1
[   35s] [99/198] preinstalled libubsan1-13.0.1+git5428-6.1
[   35s] [100/198] preinstalled libutempter0-1.2.0-3.2
[   35s] [101/198] preinstalled libuuid1-2.38.1-7.1
[   35s] [102/198] preinstalled libxcrypt-devel-4.4.33-1.1
[   35s] [103/198] preinstalled libz1-1.2.13-2.1
[   35s] [104/198] preinstalled libzstd1-1.5.2-2.1
[   35s] [105/198] preinstalled linux-glibc-devel-6.1-1.1
[   35s] [106/198] preinstalled login_defs-4.13-3.1
[   35s] [107/198] preinstalled lua54-5.4.4-8.1
[   35s] [108/198] preinstalled make-4.4-2.1
[   35s] [109/198] preinstalled ncurses-utils-6.4.20230128-5.1
[   35s] [110/198] preinstalled pam-1.5.2-12.1
[   35s] [111/198] preinstalled patch-2.7.6-6.1
[   35s] [112/198] preinstalled perl-5.36.0-4.1
[   35s] [113/198] preinstalled perl-base-5.36.0-4.1
[   35s] [114/198] preinstalled permissions-1599_20221220-1.2
[   35s] [115/198] preinstalled permissions-config-1599_20221220-1.2
[   35s] [116/198] preinstalled pkgconf-1.8.0-2.1
[   35s] [117/198] preinstalled pkgconf-m4-1.8.0-2.1
[   35s] [118/198] preinstalled pkgconf-pkg-config-1.8.0-2.1
[   35s] [119/198] preinstalled polkit-default-privs-1550+20221102.9f111fa-1.1
[   35s] [120/198] preinstalled post-build-checks-84.87+git20230106.3a359c5-1.1
[   35s] [121/198] preinstalled python-rpm-macros-20230128.e704796-1.2
[   35s] [122/198] preinstalled python-rpm-packaging-20210526+a18ca48-1.2
[   35s] [123/198] cumulate python310-attrs-22.2.0-1.2
[   35s] [124/198] preinstalled python310-base-3.10.9-2.2
[   35s] [125/198] cumulate python310-devel-3.10.9-2.2
[   35s] [126/198] cumulate python310-exceptiongroup-1.1.0-1.2
[   35s] [127/198] cumulate python310-iniconfig-1.1.1-3.2
[   35s] [128/198] preinstalled python310-packaging-23.0-1.1
[   35s] [129/198] cumulate python310-pluggy-1.0.0-1.5
[   35s] [130/198] preinstalled python310-setuptools-65.6.3-1.2
[   35s] [131/198] cumulate python310-six-1.16.0-2.5
[   35s] [132/198] cumulate python310-tomli-2.0.1-1.3
[   35s] [133/198] cumulate python310-zipp-3.8.1-1.2
[   35s] [134/198] cumulate python311-attrs-22.2.0-1.2
[   35s] [135/198] preinstalled python311-base-3.11.1-4.2
[   35s] [136/198] cumulate python311-devel-3.11.1-4.2
[   35s] [137/198] cumulate python311-exceptiongroup-1.1.0-1.2
[   35s] [138/198] cumulate python311-iniconfig-1.1.1-3.2
[   35s] [139/198] cumulate python311-packaging-23.0-1.2
[   35s] [140/198] cumulate python311-pluggy-1.0.0-1.5
[   35s] [141/198] preinstalled python311-setuptools-65.6.3-1.2
[   35s] [142/198] cumulate python311-six-1.16.0-2.5
[   35s] [143/198] cumulate python311-tomli-2.0.1-1.3
[   35s] [144/198] cumulate python311-zipp-3.8.1-1.2
[   35s] [145/198] cumulate python38-attrs-22.2.0-1.2
[   35s] [146/198] preinstalled python38-base-3.8.16-3.2
[   35s] [147/198] cumulate python38-devel-3.8.16-3.2
[   35s] [148/198] cumulate python38-exceptiongroup-1.1.0-1.2
[   35s] [149/198] cumulate python38-iniconfig-1.1.1-3.2
[   35s] [150/198] cumulate python38-packaging-23.0-1.2
[   35s] [151/198] cumulate python38-pluggy-1.0.0-1.5
[   35s] [152/198] preinstalled python38-setuptools-65.6.3-1.2
[   35s] [153/198] cumulate python38-six-1.16.0-2.5
[   35s] [154/198] cumulate python38-tomli-2.0.1-1.3
[   35s] [155/198] cumulate python38-zipp-3.8.1-1.2
[   35s] [156/198] cumulate python39-attrs-22.2.0-1.2
[   35s] [157/198] preinstalled python39-base-3.9.16-3.2
[   35s] [158/198] cumulate python39-devel-3.9.16-3.2
[   35s] [159/198] cumulate python39-exceptiongroup-1.1.0-1.2
[   35s] [160/198] cumulate python39-iniconfig-1.1.1-3.2
[   35s] [161/198] cumulate python39-packaging-23.0-1.2
[   35s] [162/198] cumulate python39-pluggy-1.0.0-1.5
[   35s] [163/198] preinstalled python39-setuptools-65.6.3-1.2
[   35s] [164/198] cumulate python39-six-1.16.0-2.5
[   35s] [165/198] cumulate python39-tomli-2.0.1-1.3
[   35s] [166/198] cumulate python39-zipp-3.8.1-1.2
[   35s] [167/198] preinstalled qemu-linux-user-7.1.0-50.1
[   35s] [168/198] preinstalled rpm-4.18.0-3.2
[   35s] [169/198] preinstalled rpm-build-4.18.0-3.2
[   35s] [170/198] preinstalled rpm-build-perl-4.18.0-3.2
[   35s] [171/198] preinstalled rpm-config-SUSE-20220926-1.1
[   35s] [172/198] preinstalled rpmlint-mini-2.4.0+git20230214.1bab129-9.4
[   35s] [173/198] preinstalled rpmlint-strict-2.4.0+git20230214.1bab129-1.1
[   35s] [174/198] preinstalled sed-4.9-2.1
[   35s] [175/198] preinstalled shadow-4.13-3.1
[   35s] [176/198] preinstalled system-group-hardware-20170617-24.1
[   35s] [177/198] preinstalled system-user-root-20190513-2.1
[   35s] [178/198] preinstalled systemd-rpm-macros-19-1.1
[   35s] [179/198] preinstalled sysuser-shadow-3.1-5.1
[   35s] [180/198] preinstalled tar-1.34-9.1
[   35s] [181/198] preinstalled terminfo-base-6.4.20230128-5.1
[   35s] [182/198] preinstalled update-alternatives-1.21.8-1.1
[   35s] [183/198] preinstalled util-linux-2.38.1-7.1
[   35s] [184/198] preinstalled which-2.21-5.1
[   35s] [185/198] preinstalled xz-5.4.1-1.1
[   35s] [186/198] cumulate alts-1.2+3.b848aad-3.1
[   35s] [187/198] cumulate libpcrecpp0-8.45-2.1
[   35s] [188/198] cumulate libpcreposix0-8.45-2.1
[   35s] [189/198] cumulate libstdc++-devel-12-2.1
[   35s] [190/198] cumulate python310-importlib-metadata-6.0.0-1.2
[   35s] [191/198] cumulate python311-importlib-metadata-6.0.0-1.2
[   35s] [192/198] cumulate python38-importlib-metadata-6.0.0-1.2
[   35s] [193/198] cumulate python39-importlib-metadata-6.0.0-1.2
[   35s] [194/198] cumulate pcre-devel-8.45-2.1
[   35s] [195/198] cumulate python310-pytest-7.2.0-2.2
[   35s] [196/198] cumulate python311-pytest-7.2.0-2.2
[   35s] [197/198] cumulate python38-pytest-7.2.0-2.2
[   35s] [198/198] cumulate python39-pytest-7.2.0-2.2
[   35s] now installing cumulated packages
[   36s] Preparing...                          ########################################
[   36s] Updating / installing...
[   36s] libpcre1-8.45-2.1                     ########################################
[   36s] libpcrecpp0-8.45-2.1                  ########################################
[   36s] libpcreposix0-8.45-2.1                ########################################
[   36s] python39-zipp-3.8.1-1.2               ########################################
[   36s] python39-importlib-metadata-6.0.0-1.2 ########################################
[   36s] python39-tomli-2.0.1-1.3              ########################################
[   36s] python39-pluggy-1.0.0-1.5             ########################################
[   36s] python39-packaging-23.0-1.2           ########################################
[   36s] python39-iniconfig-1.1.1-3.2          ########################################
[   36s] python39-exceptiongroup-1.1.0-1.2     ########################################
[   36s] python39-attrs-22.2.0-1.2             ########################################
[   36s] python38-zipp-3.8.1-1.2               ########################################
[   37s] python38-importlib-metadata-6.0.0-1.2 ########################################
[   37s] python38-tomli-2.0.1-1.3              ########################################
[   37s] python38-pluggy-1.0.0-1.5             ########################################
[   37s] python38-packaging-23.0-1.2           ########################################
[   37s] python38-iniconfig-1.1.1-3.2          ########################################
[   37s] python38-exceptiongroup-1.1.0-1.2     ########################################
[   37s] python38-attrs-22.2.0-1.2             ########################################
[   37s] python311-zipp-3.8.1-1.2              ########################################
[   37s] python311-importlib-metadata-6.0.0-1.2########################################
[   37s] python311-tomli-2.0.1-1.3             ########################################
[   37s] python311-pluggy-1.0.0-1.5            ########################################
[   37s] python311-packaging-23.0-1.2          ########################################
[   37s] python311-iniconfig-1.1.1-3.2         ########################################
[   37s] python311-exceptiongroup-1.1.0-1.2    ########################################
[   37s] python311-attrs-22.2.0-1.2            ########################################
[   37s] python310-zipp-3.8.1-1.2              ########################################
[   37s] python310-importlib-metadata-6.0.0-1.2########################################
[   37s] python310-tomli-2.0.1-1.3             ########################################
[   37s] python310-pluggy-1.0.0-1.5            ########################################
[   37s] python310-iniconfig-1.1.1-3.2         ########################################
[   37s] python310-exceptiongroup-1.1.0-1.2    ########################################
[   37s] python310-attrs-22.2.0-1.2            ########################################
[   48s] libstdc++6-devel-gcc12-12.2.1+git749-4########################################
[   49s] libstdc++-devel-12-2.1                ########################################
[   49s] libpcre16-0-8.45-2.1                  ########################################
[   49s] libalternatives1-1.2+3.b848aad-3.1    ########################################
[   49s] alts-1.2+3.b848aad-3.1                ########################################
[   49s] python310-pytest-7.2.0-2.2            ########################################
[   50s] python311-pytest-7.2.0-2.2            ########################################
[   50s] python38-pytest-7.2.0-2.2             ########################################
[   51s] python39-pytest-7.2.0-2.2             ########################################
[   51s] pcre-devel-8.45-2.1                   ########################################
[   51s] python39-six-1.16.0-2.5               ########################################
[   52s] python39-devel-3.9.16-3.2             ########################################
[   52s] python38-six-1.16.0-2.5               ########################################
[   52s] python38-devel-3.8.16-3.2             ########################################
[   52s] python311-six-1.16.0-2.5              ########################################
[   52s] python311-devel-3.11.1-4.2            ########################################
[   52s] python310-six-1.16.0-2.5              ########################################
[   52s] python310-devel-3.10.9-2.2            ########################################
[   55s] now finalizing build dir...
[   55s] ... running 01-add_abuild_user_to_trusted_group
[   55s] ... running 02-set_timezone_to_utc
[   55s] ... running 03-set-permissions-secure
[   56s] ... running 11-hack_uname_version_to_kernel_version
[   62s] -----------------------------------------------------------------
[   62s] I have the following modifications for python-pyScss.spec:
[   62s] 24c24
[   62s] < Release:        0
[   62s] ---
[   62s] > Release:        1.2
[   67s] build target is riscv64-suse-linux
[   67s] -----------------------------------------------------------------
[   67s] ----- building python-pyScss.spec (user abuild)
[   67s] -----------------------------------------------------------------
[   67s] -----------------------------------------------------------------
[   70s] + exec rpmbuild -ba --define '_srcdefattr (-,root,root)' --nosignature --target=riscv64-suse-linux --define '_build_create_debug 1' --define 'disturl obs://build.opensuse.org/openSUSE:Factory:RISCV/standard/bfee0fd2581d1d93b993cdff71876ad8-python-pyScss' /home/abuild/rpmbuild/SOURCES/python-pyScss.spec
[  117s] Building target platforms: riscv64-suse-linux
[  117s] Building for target riscv64-suse-linux
[  117s] setting SOURCE_DATE_EPOCH=1664582400
[  117s] Executing(%prep): /usr/bin/bash -e /var/tmp/rpm-tmp.2hM6iP
[  118s] + umask 022
[  118s] + cd /home/abuild/rpmbuild/BUILD
[  118s] + cd /home/abuild/rpmbuild/BUILD
[  118s] + rm -rf pyScss-1.4.0
[  118s] + /usr/lib/rpm/rpmuncompress -x /home/abuild/rpmbuild/SOURCES/pyScss-1.4.0.tar.gz
[  118s] + STATUS=0
[  118s] + '[' 0 -ne 0 ']'
[  118s] + cd pyScss-1.4.0
[  118s] + /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
[  118s] + RPM_EC=0
[  118s] ++ jobs -p
[  118s] + exit 0
[  118s] Executing(%build): /usr/bin/bash -e /var/tmp/rpm-tmp.58X3Vt
[  118s] + umask 022
[  118s] + cd /home/abuild/rpmbuild/BUILD
[  118s] + /usr/bin/rm -rf /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64
[  118s] ++ dirname /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64
[  118s] + /usr/bin/mkdir -p /home/abuild/rpmbuild/BUILDROOT
[  118s] + /usr/bin/mkdir /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64
[  118s] + cd pyScss-1.4.0
[  118s] + ref=/usr/lib/rpm
[  118s] + mints=0
[  118s] + case $(uname -m) in
[  118s] ++ uname -m
[  119s] + mints=20160911
[  119s] + for s in guess sub
[  119s] ++ find -maxdepth 8 -name config.guess
[  119s] + for s in guess sub
[  119s] ++ find -maxdepth 8 -name config.sub
[  119s] + export 'CFLAGS=-O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g'
[  119s] + CFLAGS='-O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g'
[  119s] ++ '[' -f _current_flavor ']'
[  119s] ++ true
[  119s] + last_flavor=
[  119s] + '[' -z '' ']'
[  119s] + last_flavor=tmp
[  119s] + '[' tmp '!=' python38 ']'
[  119s] + '[' -d build ']'
[  119s] + '[' -d _build.python38 ']'
[  119s] + echo python38
[  119s] + python_flavor=python38
[  119s] + /usr/bin/python3.8 setup.py build '--executable=/usr/bin/python3.8 -s'
[  122s] running build
[  122s] running build_py
[  122s] creating build
[  122s] creating build/lib.linux-riscv64-cpython-38
[  122s] creating build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/__init__.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/__main__.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/ast.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/calculator.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/compiler.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/config.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/cssdefs.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/errors.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/legacy.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/less2scss.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/namespace.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/rule.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/scss_meta.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/selector.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/setup.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/source.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/tool.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/types.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] copying scss/util.py -> build/lib.linux-riscv64-cpython-38/scss
[  122s] creating build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/__init__.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/api.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/bootstrap.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/core.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/extra.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] copying scss/extension/fonts.py -> build/lib.linux-riscv64-cpython-38/scss/extension
[  122s] creating build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/__init__.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/gradients.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/helpers.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/images.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/layouts.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] copying scss/extension/compass/sprites.py -> build/lib.linux-riscv64-cpython-38/scss/extension/compass
[  122s] creating build/lib.linux-riscv64-cpython-38/scss/grammar
[  122s] copying scss/grammar/__init__.py -> build/lib.linux-riscv64-cpython-38/scss/grammar
[  122s] copying scss/grammar/expression.py -> build/lib.linux-riscv64-cpython-38/scss/grammar
[  122s] copying scss/grammar/scanner.py -> build/lib.linux-riscv64-cpython-38/scss/grammar
[  122s] running build_ext
[  122s] building 'scss.grammar._scanner' extension
[  122s] creating build/temp.linux-riscv64-cpython-38
[  122s] creating build/temp.linux-riscv64-cpython-38/scss
[  122s] creating build/temp.linux-riscv64-cpython-38/scss/src
[  122s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.8 -c scss/src/_speedups.c -o build/temp.linux-riscv64-cpython-38/scss/src/_speedups.o
[  125s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.8 -c scss/src/block_locator.c -o build/temp.linux-riscv64-cpython-38/scss/src/block_locator.o
[  127s] scss/src/block_locator.c: In function ‘BlockLocator_new’:
[  127s] scss/src/block_locator.c:321:17: warning: ‘PyUnicode_GetSize’ is deprecated [-Wdeprecated-declarations]
[  127s]   321 |                 self->codestr_sz = PyUnicode_GetSize((PyObject*)codestr);
[  127s]       |                 ^~~~
[  127s] In file included from /usr/include/python3.8/Python.h:97,
[  127s]                  from scss/src/block_locator.c:11:
[  127s] /usr/include/python3.8/unicodeobject.h:177:43: note: declared here
[  127s]   177 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
[  127s]       |                                           ^~~~~~~~~~~~~~~~~
[  128s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.8 -c scss/src/hashtable.c -o build/temp.linux-riscv64-cpython-38/scss/src/hashtable.o
[  129s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.8 -c scss/src/scanner.c -o build/temp.linux-riscv64-cpython-38/scss/src/scanner.o
[  132s] gcc -shared -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g build/temp.linux-riscv64-cpython-38/scss/src/_speedups.o build/temp.linux-riscv64-cpython-38/scss/src/block_locator.o build/temp.linux-riscv64-cpython-38/scss/src/hashtable.o build/temp.linux-riscv64-cpython-38/scss/src/scanner.o -L/usr/lib64 -lpcre -o build/lib.linux-riscv64-cpython-38/scss/grammar/_scanner.cpython-38-riscv64-linux-gnu.so
[  142s] ++ '[' -f _current_flavor ']'
[  142s] ++ cat _current_flavor
[  142s] + last_flavor=python38
[  142s] + '[' -z python38 ']'
[  142s] + '[' python38 '!=' python39 ']'
[  142s] + '[' -d build ']'
[  142s] + mv build _build.python38
[  142s] + '[' -d _build.python39 ']'
[  142s] + echo python39
[  142s] + python_flavor=python39
[  142s] + /usr/bin/python3.9 setup.py build '--executable=/usr/bin/python3.9 -s'
[  144s] running build
[  144s] running build_py
[  145s] creating build
[  145s] creating build/lib.linux-riscv64-cpython-39
[  145s] creating build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/__init__.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/__main__.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/ast.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/calculator.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/compiler.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/config.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/cssdefs.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/errors.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/legacy.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/less2scss.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/namespace.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/rule.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/scss_meta.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/selector.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/setup.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/source.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/tool.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/types.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] copying scss/util.py -> build/lib.linux-riscv64-cpython-39/scss
[  145s] creating build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/__init__.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/api.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/bootstrap.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/core.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/extra.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] copying scss/extension/fonts.py -> build/lib.linux-riscv64-cpython-39/scss/extension
[  145s] creating build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/__init__.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/gradients.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/helpers.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/images.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/layouts.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] copying scss/extension/compass/sprites.py -> build/lib.linux-riscv64-cpython-39/scss/extension/compass
[  145s] creating build/lib.linux-riscv64-cpython-39/scss/grammar
[  145s] copying scss/grammar/__init__.py -> build/lib.linux-riscv64-cpython-39/scss/grammar
[  145s] copying scss/grammar/expression.py -> build/lib.linux-riscv64-cpython-39/scss/grammar
[  145s] copying scss/grammar/scanner.py -> build/lib.linux-riscv64-cpython-39/scss/grammar
[  145s] running build_ext
[  145s] building 'scss.grammar._scanner' extension
[  145s] creating build/temp.linux-riscv64-cpython-39
[  145s] creating build/temp.linux-riscv64-cpython-39/scss
[  145s] creating build/temp.linux-riscv64-cpython-39/scss/src
[  145s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.9 -c scss/src/_speedups.c -o build/temp.linux-riscv64-cpython-39/scss/src/_speedups.o
[  148s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.9 -c scss/src/block_locator.c -o build/temp.linux-riscv64-cpython-39/scss/src/block_locator.o
[  150s] scss/src/block_locator.c: In function ‘BlockLocator_new’:
[  150s] scss/src/block_locator.c:320:17: warning: ‘PyUnicode_AsUnicode’ is deprecated [-Wdeprecated-declarations]
[  150s]   320 |                 self->codestr = PyUnicode_AS_UNICODE(codestr);
[  150s]       |                 ^~~~
[  150s] In file included from /usr/include/python3.9/unicodeobject.h:1026,
[  150s]                  from /usr/include/python3.9/Python.h:93,
[  150s]                  from scss/src/block_locator.c:11:
[  150s] /usr/include/python3.9/cpython/unicodeobject.h:580:45: note: declared here
[  150s]   580 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(
[  150s]       |                                             ^~~~~~~~~~~~~~~~~~~
[  150s] scss/src/block_locator.c:321:17: warning: ‘PyUnicode_GetSize’ is deprecated [-Wdeprecated-declarations]
[  150s]   321 |                 self->codestr_sz = PyUnicode_GetSize((PyObject*)codestr);
[  150s]       |                 ^~~~
[  150s] /usr/include/python3.9/unicodeobject.h:177:43: note: declared here
[  150s]   177 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
[  150s]       |                                           ^~~~~~~~~~~~~~~~~
[  151s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.9 -c scss/src/hashtable.c -o build/temp.linux-riscv64-cpython-39/scss/src/hashtable.o
[  152s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.9 -c scss/src/scanner.c -o build/temp.linux-riscv64-cpython-39/scss/src/scanner.o
[  156s] gcc -shared -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g build/temp.linux-riscv64-cpython-39/scss/src/_speedups.o build/temp.linux-riscv64-cpython-39/scss/src/block_locator.o build/temp.linux-riscv64-cpython-39/scss/src/hashtable.o build/temp.linux-riscv64-cpython-39/scss/src/scanner.o -L/usr/lib64 -lpcre -o build/lib.linux-riscv64-cpython-39/scss/grammar/_scanner.cpython-39-riscv64-linux-gnu.so
[  165s] ++ '[' -f _current_flavor ']'
[  165s] ++ cat _current_flavor
[  165s] + last_flavor=python39
[  165s] + '[' -z python39 ']'
[  165s] + '[' python39 '!=' python311 ']'
[  165s] + '[' -d build ']'
[  165s] + mv build _build.python39
[  165s] + '[' -d _build.python311 ']'
[  165s] + echo python311
[  165s] + python_flavor=python311
[  165s] + /usr/bin/python3.11 setup.py build '--executable=/usr/bin/python3.11 -s'
[  167s] running build
[  167s] running build_py
[  167s] creating build
[  167s] creating build/lib.linux-riscv64-cpython-311
[  167s] creating build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/__init__.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/__main__.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/ast.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/calculator.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/compiler.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/config.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/cssdefs.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/errors.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/legacy.py -> build/lib.linux-riscv64-cpython-311/scss
[  167s] copying scss/less2scss.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/namespace.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/rule.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/scss_meta.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/selector.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/setup.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/source.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/tool.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/types.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] copying scss/util.py -> build/lib.linux-riscv64-cpython-311/scss
[  168s] creating build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/__init__.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/api.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/bootstrap.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/core.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/extra.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] copying scss/extension/fonts.py -> build/lib.linux-riscv64-cpython-311/scss/extension
[  168s] creating build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/__init__.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/gradients.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/helpers.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/images.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/layouts.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] copying scss/extension/compass/sprites.py -> build/lib.linux-riscv64-cpython-311/scss/extension/compass
[  168s] creating build/lib.linux-riscv64-cpython-311/scss/grammar
[  168s] copying scss/grammar/__init__.py -> build/lib.linux-riscv64-cpython-311/scss/grammar
[  168s] copying scss/grammar/expression.py -> build/lib.linux-riscv64-cpython-311/scss/grammar
[  168s] copying scss/grammar/scanner.py -> build/lib.linux-riscv64-cpython-311/scss/grammar
[  168s] running build_ext
[  168s] building 'scss.grammar._scanner' extension
[  168s] creating build/temp.linux-riscv64-cpython-311
[  168s] creating build/temp.linux-riscv64-cpython-311/scss
[  168s] creating build/temp.linux-riscv64-cpython-311/scss/src
[  168s] gcc -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.11 -c scss/src/_speedups.c -o build/temp.linux-riscv64-cpython-311/scss/src/_speedups.o
[  171s] gcc -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.11 -c scss/src/block_locator.c -o build/temp.linux-riscv64-cpython-311/scss/src/block_locator.o
[  173s] scss/src/block_locator.c: In function ‘BlockLocator_new’:
[  173s] scss/src/block_locator.c:320:17: warning: ‘PyUnicode_AS_UNICODE’ is deprecated [-Wdeprecated-declarations]
[  173s]   320 |                 self->codestr = PyUnicode_AS_UNICODE(codestr);
[  173s]       |                 ^~~~
[  173s] In file included from /usr/include/python3.11/unicodeobject.h:1042,
[  173s]                  from /usr/include/python3.11/Python.h:51,
[  173s]                  from scss/src/block_locator.c:11:
[  173s] /usr/include/python3.11/cpython/unicodeobject.h:685:27: note: declared here
[  173s]   685 | static inline Py_UNICODE* PyUnicode_AS_UNICODE(PyObject *op)
[  173s]       |                           ^~~~~~~~~~~~~~~~~~~~
[  173s] scss/src/block_locator.c:321:17: warning: ‘PyUnicode_GetSize’ is deprecated [-Wdeprecated-declarations]
[  173s]   321 |                 self->codestr_sz = PyUnicode_GetSize((PyObject*)codestr);
[  173s]       |                 ^~~~
[  173s] /usr/include/python3.11/unicodeobject.h:177:43: note: declared here
[  173s]   177 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
[  173s]       |                                           ^~~~~~~~~~~~~~~~~
[  174s] gcc -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.11 -c scss/src/hashtable.c -o build/temp.linux-riscv64-cpython-311/scss/src/hashtable.o
[  175s] gcc -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.11 -c scss/src/scanner.c -o build/temp.linux-riscv64-cpython-311/scss/src/scanner.o
[  178s] gcc -shared -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g build/temp.linux-riscv64-cpython-311/scss/src/_speedups.o build/temp.linux-riscv64-cpython-311/scss/src/block_locator.o build/temp.linux-riscv64-cpython-311/scss/src/hashtable.o build/temp.linux-riscv64-cpython-311/scss/src/scanner.o -L/usr/lib64 -lpcre -o build/lib.linux-riscv64-cpython-311/scss/grammar/_scanner.cpython-311-riscv64-linux-gnu.so
[  186s] ++ '[' -f _current_flavor ']'
[  186s] ++ cat _current_flavor
[  186s] + last_flavor=python311
[  186s] + '[' -z python311 ']'
[  186s] + '[' python311 '!=' python310 ']'
[  186s] + '[' -d build ']'
[  186s] + mv build _build.python311
[  186s] + '[' -d _build.python310 ']'
[  186s] + echo python310
[  186s] + python_flavor=python310
[  186s] + /usr/bin/python3.10 setup.py build '--executable=/usr/bin/python3.10 -s'
[  189s] running build
[  189s] running build_py
[  189s] creating build
[  189s] creating build/lib.linux-riscv64-cpython-310
[  189s] creating build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/__init__.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/__main__.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/ast.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/calculator.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/compiler.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/config.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/cssdefs.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/errors.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/legacy.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/less2scss.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/namespace.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/rule.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/scss_meta.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/selector.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/setup.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/source.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/tool.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/types.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] copying scss/util.py -> build/lib.linux-riscv64-cpython-310/scss
[  189s] creating build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/__init__.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/api.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/bootstrap.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/core.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/extra.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] copying scss/extension/fonts.py -> build/lib.linux-riscv64-cpython-310/scss/extension
[  189s] creating build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/__init__.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/gradients.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/helpers.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/images.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/layouts.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] copying scss/extension/compass/sprites.py -> build/lib.linux-riscv64-cpython-310/scss/extension/compass
[  189s] creating build/lib.linux-riscv64-cpython-310/scss/grammar
[  189s] copying scss/grammar/__init__.py -> build/lib.linux-riscv64-cpython-310/scss/grammar
[  189s] copying scss/grammar/expression.py -> build/lib.linux-riscv64-cpython-310/scss/grammar
[  189s] copying scss/grammar/scanner.py -> build/lib.linux-riscv64-cpython-310/scss/grammar
[  189s] running build_ext
[  189s] building 'scss.grammar._scanner' extension
[  189s] creating build/temp.linux-riscv64-cpython-310
[  189s] creating build/temp.linux-riscv64-cpython-310/scss
[  189s] creating build/temp.linux-riscv64-cpython-310/scss/src
[  189s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.10 -c scss/src/_speedups.c -o build/temp.linux-riscv64-cpython-310/scss/src/_speedups.o
[  191s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.10 -c scss/src/block_locator.c -o build/temp.linux-riscv64-cpython-310/scss/src/block_locator.o
[  193s] scss/src/block_locator.c: In function ‘BlockLocator_new’:
[  193s] scss/src/block_locator.c:320:17: warning: ‘PyUnicode_AsUnicode’ is deprecated [-Wdeprecated-declarations]
[  193s]   320 |                 self->codestr = PyUnicode_AS_UNICODE(codestr);
[  193s]       |                 ^~~~
[  193s] In file included from /usr/include/python3.10/unicodeobject.h:1046,
[  193s]                  from /usr/include/python3.10/Python.h:83,
[  193s]                  from scss/src/block_locator.c:11:
[  193s] /usr/include/python3.10/cpython/unicodeobject.h:580:45: note: declared here
[  193s]   580 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(
[  193s]       |                                             ^~~~~~~~~~~~~~~~~~~
[  193s] scss/src/block_locator.c:321:17: warning: ‘PyUnicode_GetSize’ is deprecated [-Wdeprecated-declarations]
[  193s]   321 |                 self->codestr_sz = PyUnicode_GetSize((PyObject*)codestr);
[  193s]       |                 ^~~~
[  193s] /usr/include/python3.10/unicodeobject.h:177:43: note: declared here
[  193s]   177 | Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
[  193s]       |                                           ^~~~~~~~~~~~~~~~~
[  194s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.10 -c scss/src/hashtable.c -o build/temp.linux-riscv64-cpython-310/scss/src/hashtable.o
[  195s] gcc -Wno-unused-result -Wsign-compare -DNDEBUG -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -DOPENSSL_LOAD_CONF -fwrapv -fno-semantic-interposition -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -g -IVendor/ -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g -fPIC -I/usr/include/python3.10 -c scss/src/scanner.c -o build/temp.linux-riscv64-cpython-310/scss/src/scanner.o
[  198s] gcc -shared -O2 -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -Werror=return-type -flto=auto -g build/temp.linux-riscv64-cpython-310/scss/src/_speedups.o build/temp.linux-riscv64-cpython-310/scss/src/block_locator.o build/temp.linux-riscv64-cpython-310/scss/src/hashtable.o build/temp.linux-riscv64-cpython-310/scss/src/scanner.o -L/usr/lib64 -lpcre -o build/lib.linux-riscv64-cpython-310/scss/grammar/_scanner.cpython-310-riscv64-linux-gnu.so
[  206s] + RPM_EC=0
[  206s] ++ jobs -p
[  206s] + exit 0
[  206s] Executing(%install): /usr/bin/bash -e /var/tmp/rpm-tmp.N5bL6n
[  206s] + umask 022
[  206s] + cd /home/abuild/rpmbuild/BUILD
[  206s] + /usr/bin/rm -rf /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64
[  206s] + /usr/bin/mkdir -p /home/abuild/rpmbuild/BUILDROOT
[  206s] + /usr/bin/mkdir /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64
[  206s] + cd pyScss-1.4.0
[  206s] ++ '[' -f _current_flavor ']'
[  206s] ++ cat _current_flavor
[  206s] + last_flavor=python310
[  206s] + '[' -z python310 ']'
[  206s] + '[' python310 '!=' python38 ']'
[  206s] + '[' -d build ']'
[  206s] + mv build _build.python310
[  206s] + '[' -d _build.python38 ']'
[  206s] + mv _build.python38 build
[  206s] + echo python38
[  206s] + python_flavor=python38
[  206s] + /usr/bin/python3.8 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64 --prefix /usr
[  209s] running install
[  209s] running install_lib
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/__main__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/ast.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/calculator.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/compiler.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/config.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/cssdefs.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/errors.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/legacy.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/less2scss.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/namespace.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/rule.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/scss_meta.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/selector.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/setup.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/source.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/tool.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/types.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/util.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/api.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/bootstrap.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/core.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/extra.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/fonts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/gradients.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/helpers.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/images.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/layouts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/extension/compass/sprites.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass
[  209s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/grammar/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/grammar/expression.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/grammar/scanner.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar
[  209s] copying build/lib.linux-riscv64-cpython-38/scss/grammar/_scanner.cpython-38-riscv64-linux-gnu.so -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/__init__.py to __init__.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/__main__.py to __main__.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/ast.py to ast.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/calculator.py to calculator.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/compiler.py to compiler.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/config.py to config.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/cssdefs.py to cssdefs.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/errors.py to errors.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/legacy.py to legacy.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/less2scss.py to less2scss.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/namespace.py to namespace.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/rule.py to rule.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/scss_meta.py to scss_meta.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/selector.py to selector.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/setup.py to setup.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/source.py to source.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/tool.py to tool.cpython-38.pyc
[  209s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/types.py to types.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/util.py to util.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/__init__.py to __init__.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/api.py to api.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/bootstrap.py to bootstrap.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/core.py to core.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/extra.py to extra.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/fonts.py to fonts.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/__init__.py to __init__.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/gradients.py to gradients.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/helpers.py to helpers.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/images.py to images.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/layouts.py to layouts.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/extension/compass/sprites.py to sprites.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar/__init__.py to __init__.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar/expression.py to expression.cpython-38.pyc
[  210s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar/scanner.py to scanner.cpython-38.pyc
[  210s] writing byte-compilation script '/tmp/tmpm7a6o7cd.py'
[  210s] /usr/bin/python3.8 /tmp/tmpm7a6o7cd.py
[  213s] removing /tmp/tmpm7a6o7cd.py
[  213s] running install_egg_info
[  213s] running egg_info
[  213s] creating pyScss.egg-info
[  213s] writing pyScss.egg-info/PKG-INFO
[  213s] writing dependency_links to pyScss.egg-info/dependency_links.txt
[  213s] writing entry points to pyScss.egg-info/entry_points.txt
[  213s] writing requirements to pyScss.egg-info/requires.txt
[  213s] writing top-level names to pyScss.egg-info/top_level.txt
[  213s] writing manifest file 'pyScss.egg-info/SOURCES.txt'
[  213s] reading manifest file 'pyScss.egg-info/SOURCES.txt'
[  213s] reading manifest template 'MANIFEST.in'
[  213s] adding license file 'LICENSE'
[  213s] writing manifest file 'pyScss.egg-info/SOURCES.txt'
[  213s] Copying pyScss.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/pyScss-1.4.0-py3.8.egg-info
[  213s] running install_scripts
[  214s] Installing less2scss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  214s] Installing pyscss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  214s] /usr/lib/python3.8/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[  214s]   warnings.warn(
[  214s] ++ '[' -f _current_flavor ']'
[  214s] ++ cat _current_flavor
[  214s] + last_flavor=python38
[  214s] + '[' -z python38 ']'
[  214s] + '[' python38 '!=' python39 ']'
[  214s] + '[' -d build ']'
[  214s] + mv build _build.python38
[  214s] + '[' -d _build.python39 ']'
[  214s] + mv _build.python39 build
[  214s] + echo python39
[  214s] + python_flavor=python39
[  214s] + /usr/bin/python3.9 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64 --prefix /usr
[  216s] running install
[  216s] /usr/lib/python3.9/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[  216s]   warnings.warn(
[  216s] running install_lib
[  216s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9
[  217s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages
[  217s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/__main__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/ast.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/calculator.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/compiler.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/config.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/cssdefs.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/errors.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/legacy.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/less2scss.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/namespace.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/rule.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/scss_meta.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/selector.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/setup.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/source.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/tool.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/types.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/util.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss
[  217s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/api.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/bootstrap.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/core.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/extra.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/fonts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension
[  217s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/gradients.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/helpers.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/images.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/layouts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/extension/compass/sprites.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass
[  217s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/grammar/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/grammar/expression.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/grammar/scanner.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar
[  217s] copying build/lib.linux-riscv64-cpython-39/scss/grammar/_scanner.cpython-39-riscv64-linux-gnu.so -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/__init__.py to __init__.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/__main__.py to __main__.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/ast.py to ast.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/calculator.py to calculator.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/compiler.py to compiler.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/config.py to config.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/cssdefs.py to cssdefs.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/errors.py to errors.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/legacy.py to legacy.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/less2scss.py to less2scss.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/namespace.py to namespace.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/rule.py to rule.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/scss_meta.py to scss_meta.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/selector.py to selector.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/setup.py to setup.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/source.py to source.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/tool.py to tool.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/types.py to types.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/util.py to util.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/__init__.py to __init__.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/api.py to api.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/bootstrap.py to bootstrap.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/core.py to core.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/extra.py to extra.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/fonts.py to fonts.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/__init__.py to __init__.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/gradients.py to gradients.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/helpers.py to helpers.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/images.py to images.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/layouts.py to layouts.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/extension/compass/sprites.py to sprites.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar/__init__.py to __init__.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar/expression.py to expression.cpython-39.pyc
[  217s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar/scanner.py to scanner.cpython-39.pyc
[  218s] writing byte-compilation script '/tmp/tmp3la7m9d1.py'
[  218s] /usr/bin/python3.9 /tmp/tmp3la7m9d1.py
[  221s] removing /tmp/tmp3la7m9d1.py
[  221s] running install_egg_info
[  221s] running egg_info
[  221s] writing pyScss.egg-info/PKG-INFO
[  221s] writing dependency_links to pyScss.egg-info/dependency_links.txt
[  221s] writing entry points to pyScss.egg-info/entry_points.txt
[  221s] writing requirements to pyScss.egg-info/requires.txt
[  221s] writing top-level names to pyScss.egg-info/top_level.txt
[  221s] reading manifest file 'pyScss.egg-info/SOURCES.txt'
[  221s] reading manifest template 'MANIFEST.in'
[  221s] adding license file 'LICENSE'
[  221s] writing manifest file 'pyScss.egg-info/SOURCES.txt'
[  221s] Copying pyScss.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/pyScss-1.4.0-py3.9.egg-info
[  221s] running install_scripts
[  221s] Installing less2scss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  221s] Installing pyscss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  221s] ++ '[' -f _current_flavor ']'
[  221s] ++ cat _current_flavor
[  221s] + last_flavor=python39
[  221s] + '[' -z python39 ']'
[  221s] + '[' python39 '!=' python311 ']'
[  221s] + '[' -d build ']'
[  221s] + mv build _build.python39
[  221s] + '[' -d _build.python311 ']'
[  221s] + mv _build.python311 build
[  221s] + echo python311
[  221s] + python_flavor=python311
[  221s] + /usr/bin/python3.11 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64 --prefix /usr
[  224s] running install
[  224s] /usr/lib/python3.11/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[  224s]   warnings.warn(
[  224s] running install_lib
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/__main__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/ast.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/calculator.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/compiler.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/config.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/cssdefs.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/errors.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/legacy.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/less2scss.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/namespace.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/rule.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/scss_meta.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/selector.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/setup.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/source.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/tool.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/types.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/util.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/api.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/bootstrap.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/core.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/extra.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/fonts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/gradients.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/helpers.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/images.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/layouts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/extension/compass/sprites.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass
[  224s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/grammar/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/grammar/expression.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/grammar/scanner.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar
[  224s] copying build/lib.linux-riscv64-cpython-311/scss/grammar/_scanner.cpython-311-riscv64-linux-gnu.so -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/__init__.py to __init__.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/__main__.py to __main__.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/ast.py to ast.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/calculator.py to calculator.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/compiler.py to compiler.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/config.py to config.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/cssdefs.py to cssdefs.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/errors.py to errors.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/legacy.py to legacy.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/less2scss.py to less2scss.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/namespace.py to namespace.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/rule.py to rule.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/scss_meta.py to scss_meta.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/selector.py to selector.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/setup.py to setup.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/source.py to source.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/tool.py to tool.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/types.py to types.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/util.py to util.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/__init__.py to __init__.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/api.py to api.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/bootstrap.py to bootstrap.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/core.py to core.cpython-311.pyc
[  224s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/extra.py to extra.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/fonts.py to fonts.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/__init__.py to __init__.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/gradients.py to gradients.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/helpers.py to helpers.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/images.py to images.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/layouts.py to layouts.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/extension/compass/sprites.py to sprites.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar/__init__.py to __init__.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar/expression.py to expression.cpython-311.pyc
[  225s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar/scanner.py to scanner.cpython-311.pyc
[  225s] writing byte-compilation script '/tmp/tmp12o1mke0.py'
[  225s] /usr/bin/python3.11 /tmp/tmp12o1mke0.py
[  228s] removing /tmp/tmp12o1mke0.py
[  228s] running install_egg_info
[  228s] running egg_info
[  228s] writing pyScss.egg-info/PKG-INFO
[  228s] writing dependency_links to pyScss.egg-info/dependency_links.txt
[  228s] writing entry points to pyScss.egg-info/entry_points.txt
[  228s] writing requirements to pyScss.egg-info/requires.txt
[  228s] writing top-level names to pyScss.egg-info/top_level.txt
[  228s] reading manifest file 'pyScss.egg-info/SOURCES.txt'
[  228s] reading manifest template 'MANIFEST.in'
[  228s] adding license file 'LICENSE'
[  228s] writing manifest file 'pyScss.egg-info/SOURCES.txt'
[  228s] Copying pyScss.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/pyScss-1.4.0-py3.11.egg-info
[  228s] running install_scripts
[  229s] Installing less2scss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  229s] Installing pyscss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  229s] ++ '[' -f _current_flavor ']'
[  229s] ++ cat _current_flavor
[  229s] + last_flavor=python311
[  229s] + '[' -z python311 ']'
[  229s] + '[' python311 '!=' python310 ']'
[  229s] + '[' -d build ']'
[  229s] + mv build _build.python311
[  229s] + '[' -d _build.python310 ']'
[  229s] + mv _build.python310 build
[  229s] + echo python310
[  229s] + python_flavor=python310
[  229s] + /usr/bin/python3.10 setup.py install -O1 --skip-build --force --root /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64 --prefix /usr
[  231s] running install
[  231s] /usr/lib/python3.10/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
[  231s]   warnings.warn(
[  232s] running install_lib
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/__main__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/ast.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/calculator.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/compiler.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/config.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/cssdefs.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/errors.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/legacy.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/less2scss.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/namespace.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/rule.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/scss_meta.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/selector.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/setup.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/source.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/tool.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/types.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/util.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/api.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/bootstrap.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/core.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/extra.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/fonts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/gradients.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/helpers.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/images.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/layouts.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/extension/compass/sprites.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass
[  232s] creating /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/grammar/__init__.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/grammar/expression.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/grammar/scanner.py -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar
[  232s] copying build/lib.linux-riscv64-cpython-310/scss/grammar/_scanner.cpython-310-riscv64-linux-gnu.so -> /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/__init__.py to __init__.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/__main__.py to __main__.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/ast.py to ast.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/calculator.py to calculator.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/compiler.py to compiler.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/config.py to config.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/cssdefs.py to cssdefs.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/errors.py to errors.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/legacy.py to legacy.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/less2scss.py to less2scss.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/namespace.py to namespace.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/rule.py to rule.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/scss_meta.py to scss_meta.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/selector.py to selector.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/setup.py to setup.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/source.py to source.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/tool.py to tool.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/types.py to types.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/util.py to util.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/__init__.py to __init__.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/api.py to api.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/bootstrap.py to bootstrap.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/core.py to core.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/extra.py to extra.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/fonts.py to fonts.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/__init__.py to __init__.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/gradients.py to gradients.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/helpers.py to helpers.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/images.py to images.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/layouts.py to layouts.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/extension/compass/sprites.py to sprites.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar/__init__.py to __init__.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar/expression.py to expression.cpython-310.pyc
[  232s] byte-compiling /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar/scanner.py to scanner.cpython-310.pyc
[  232s] writing byte-compilation script '/tmp/tmp125mlyl_.py'
[  232s] /usr/bin/python3.10 /tmp/tmp125mlyl_.py
[  236s] removing /tmp/tmp125mlyl_.py
[  236s] running install_egg_info
[  236s] running egg_info
[  236s] writing pyScss.egg-info/PKG-INFO
[  236s] writing dependency_links to pyScss.egg-info/dependency_links.txt
[  236s] writing entry points to pyScss.egg-info/entry_points.txt
[  236s] writing requirements to pyScss.egg-info/requires.txt
[  236s] writing top-level names to pyScss.egg-info/top_level.txt
[  236s] reading manifest file 'pyScss.egg-info/SOURCES.txt'
[  236s] reading manifest template 'MANIFEST.in'
[  236s] adding license file 'LICENSE'
[  236s] writing manifest file 'pyScss.egg-info/SOURCES.txt'
[  236s] Copying pyScss.egg-info to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/pyScss-1.4.0-py3.10.egg-info
[  236s] running install_scripts
[  237s] Installing less2scss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  237s] Installing pyscss script to /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.8
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.8@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.8
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.9
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.9@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.9
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.11
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.11@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.11
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.10
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.10@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss-3.10
[  237s] + rm -f /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss
[  237s] + alternative_target=/usr/bin/pyscss
[  237s] + [[ /usr/bin/pyscss == /usr/share/man* ]]
[  237s] + '[' 0 -eq 1 ']'
[  237s] + mkdir -p /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/etc/alternatives
[  237s] + touch /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/etc/alternatives/pyscss
[  237s] + ln -sf /etc/alternatives/pyscss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/pyscss
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.8
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.8@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.8
[  237s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.9
[  237s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.9@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.9
[  238s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.11
[  238s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.11@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.11
[  238s] + cp /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.10
[  238s] + sed -ri '1s@#!.*python.*@#!/usr/bin/python3.10@' /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss-3.10
[  238s] + rm -f /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss
[  238s] + alternative_target=/usr/bin/less2scss
[  238s] + [[ /usr/bin/less2scss == /usr/share/man* ]]
[  238s] + '[' 0 -eq 1 ']'
[  238s] + mkdir -p /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/etc/alternatives
[  238s] + touch /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/etc/alternatives/less2scss
[  238s] + ln -sf /etc/alternatives/less2scss /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/bin/less2scss
[  238s] + /usr/lib/rpm/find-debuginfo -j6 -n --run-dwz --dwz-low-mem-die-limit 10000000 --dwz-max-die-limit 50000000 -S debugsourcefiles.list /home/abuild/rpmbuild/BUILD/pyScss-1.4.0
[  240s] extracting debug info from /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.10/site-packages/scss/grammar/_scanner.cpython-310-riscv64-linux-gnu.so
[  240s] extracting debug info from /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.11/site-packages/scss/grammar/_scanner.cpython-311-riscv64-linux-gnu.so
[  240s] extracting debug info from /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.8/site-packages/scss/grammar/_scanner.cpython-38-riscv64-linux-gnu.so
[  240s] extracting debug info from /home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib64/python3.9/site-packages/scss/grammar/_scanner.cpython-39-riscv64-linux-gnu.so
[  241s] original debug info size: 464kB, size after compression: 428kB
[  241s] /usr/lib/rpm/sepdebugcrcfix: Updated 4 CRC32s, 0 CRC32s did match.
[  241s] 99 blocks
[  242s] + /usr/lib/rpm/brp-compress
[  242s] + /usr/lib/rpm/brp-suse
[  242s] calling /usr/lib/rpm/brp-suse.d/brp-05-permissions
[  242s] calling /usr/lib/rpm/brp-suse.d/brp-15-strip-debug
[  242s] calling /usr/lib/rpm/brp-suse.d/brp-25-symlink
[  242s] calling /usr/lib/rpm/brp-suse.d/brp-50-generate-fips-hmac
[  242s] calling /usr/lib/rpm/brp-suse.d/brp-75-ar
[  243s] Executing(%check): /usr/bin/bash -e /var/tmp/rpm-tmp.B6AkES
[  243s] + umask 022
[  243s] + cd /home/abuild/rpmbuild/BUILD
[  243s] + cd pyScss-1.4.0
[  243s] + set +x
[  243s] Using libalternatives variant 38 for py.test in XDG_CONFIG_HOME during Python 3.8 expansions.
[  243s] Using libalternatives variant 38 for pytest in XDG_CONFIG_HOME during Python 3.8 expansions.
[  243s] Using alternative less2scss-3.8 for less2scss in ./build/flavorbin during Python 3.8 expansions.
[  244s] Using alternative pyscss-3.8 for pyscss in ./build/flavorbin during Python 3.8 expansions.
[  244s] Using libalternatives variant 39 for py.test in XDG_CONFIG_HOME during Python 3.9 expansions.
[  244s] Using libalternatives variant 39 for pytest in XDG_CONFIG_HOME during Python 3.9 expansions.
[  244s] Using alternative less2scss-3.9 for less2scss in ./build/flavorbin during Python 3.9 expansions.
[  244s] Using alternative pyscss-3.9 for pyscss in ./build/flavorbin during Python 3.9 expansions.
[  245s] Using libalternatives variant 311 for py.test in XDG_CONFIG_HOME during Python 3.11 expansions.
[  245s] Using libalternatives variant 311 for pytest in XDG_CONFIG_HOME during Python 3.11 expansions.
[  245s] Using alternative less2scss-3.11 for less2scss in ./build/flavorbin during Python 3.11 expansions.
[  245s] Using alternative pyscss-3.11 for pyscss in ./build/flavorbin during Python 3.11 expansions.
[  246s] Using alternative less2scss-3.10 for less2scss in ./build/flavorbin during Python 3.10 expansions.
[  246s] Using alternative pyscss-3.10 for pyscss in ./build/flavorbin during Python 3.10 expansions.
[  246s] + export PATH=/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/build/flavorbin:/usr/local/bin:/usr/bin:/bin
[  246s] + PATH=/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/build/flavorbin:/usr/local/bin:/usr/bin:/bin
[  246s] ++ '[' -f _current_flavor ']'
[  246s] ++ cat _current_flavor
[  246s] + last_flavor=python310
[  246s] + '[' -z python310 ']'
[  246s] + '[' python310 '!=' python38 ']'
[  246s] + '[' -d build ']'
[  246s] + mv build _build.python310
[  246s] + '[' -d _build.python38 ']'
[  246s] + mv _build.python38 build
[  246s] + echo python38
[  246s] + python_flavor=python38
[  246s] + PYTHONPATH=/home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib/python3.8/site-packages
[  246s] + PYTHONDONTWRITEBYTECODE=1
[  246s] + pytest-3.8 --ignore=_build.python38 --ignore=_build.python39 --ignore=_build.python311 --ignore=_build.python310 -v -k 'not test_stdio'
[  250s] ============================= test session starts ==============================
[  250s] platform linux -- Python 3.8.16, pytest-7.2.0, pluggy-1.0.0 -- /usr/bin/python3.8
[  250s] cachedir: .pytest_cache
[  250s] rootdir: /home/abuild/rpmbuild/BUILD/pyScss-1.4.0
[  256s] collecting ... collected 249 items / 1 deselected / 1 skipped / 248 selected
[  256s] 
[  256s] scss/tests/test_expression.py::test_reference_operations PASSED          [  0%]
[  256s] scss/tests/test_expression.py::test_functions PASSED                     [  0%]
[  256s] scss/tests/test_expression.py::test_parse_strings PASSED                 [  1%]
[  256s] scss/tests/test_expression.py::test_parse_bang_important PASSED          [  1%]
[  257s] scss/tests/test_expression.py::test_parse_special_functions PASSED       [  2%]
[  257s] scss/tests/test_interactive.py::test_repl_expression PASSED              [  2%]
[  257s] scss/tests/test_interactive.py::test_repl_show PASSED                    [  2%]
[  257s] scss/tests/test_misc.py::test_super_selector PASSED                      [  3%]
[  257s] scss/tests/test_misc.py::test_debug_info PASSED                          [  3%]
[  257s] scss/tests/test_misc.py::test_live_errors PASSED                         [  4%]
[  257s] scss/tests/test_misc.py::test_extend_across_files PASSED                 [  4%]
[  257s] scss/tests/test_misc.py::test_unicode_files PASSED                       [  4%]
[  257s] scss/tests/test_misc.py::test_missing_import PASSED                      [  5%]
[  257s] scss/tests/test_types.py::test_addition PASSED                           [  5%]
[  257s] scss/tests/test_types.py::test_subtraction PASSED                        [  6%]
[  257s] scss/tests/test_types.py::test_division PASSED                           [  6%]
[  257s] scss/tests/test_types.py::test_comparison_numeric PASSED                 [  6%]
[  257s] scss/tests/test_types.py::test_comparison_stringerific PASSED            [  7%]
[  257s] scss/tests/test_types.py::test_comparison_null PASSED                    [  7%]
[  257s] scss/tests/test_types.py::test_unrenderable PASSED                       [  8%]
[  257s] scss/tests/extension/test_core.py::test_rgb PASSED                       [  8%]
[  257s] scss/tests/extension/test_core.py::test_rgba PASSED                      [  8%]
[  257s] scss/tests/extension/test_core.py::test_red PASSED                       [  9%]
[  257s] scss/tests/extension/test_core.py::test_green PASSED                     [  9%]
[  257s] scss/tests/extension/test_core.py::test_blue PASSED                      [ 10%]
[  257s] scss/tests/extension/test_core.py::test_mix PASSED                       [ 10%]
[  257s] scss/tests/extension/test_core.py::test_hsl PASSED                       [ 10%]
[  257s] scss/tests/extension/test_core.py::test_hsla PASSED                      [ 11%]
[  257s] scss/tests/extension/test_core.py::test_hue PASSED                       [ 11%]
[  257s] scss/tests/extension/test_core.py::test_saturation PASSED                [ 12%]
[  257s] scss/tests/extension/test_core.py::test_lightness PASSED                 [ 12%]
[  257s] scss/tests/extension/test_core.py::test_adjust_hue PASSED                [ 12%]
[  257s] scss/tests/extension/test_core.py::test_lighten PASSED                   [ 13%]
[  257s] scss/tests/extension/test_core.py::test_darken PASSED                    [ 13%]
[  257s] scss/tests/extension/test_core.py::test_saturate PASSED                  [ 14%]
[  257s] scss/tests/extension/test_core.py::test_desaturate PASSED                [ 14%]
[  257s] scss/tests/extension/test_core.py::test_grayscale PASSED                 [ 14%]
[  257s] scss/tests/extension/test_core.py::test_grayscale_css_filter PASSED      [ 15%]
[  257s] scss/tests/extension/test_core.py::test_complement PASSED                [ 15%]
[  257s] scss/tests/extension/test_core.py::test_invert PASSED                    [ 16%]
[  257s] scss/tests/extension/test_core.py::test_invert_css_filter PASSED         [ 16%]
[  257s] scss/tests/extension/test_core.py::test_alpha_opacity PASSED             [ 16%]
[  257s] scss/tests/extension/test_core.py::test_alpha_ie_filter PASSED           [ 17%]
[  257s] scss/tests/extension/test_core.py::test_opacify_fadein PASSED            [ 17%]
[  257s] scss/tests/extension/test_core.py::test_transparentize_fadeout PASSED    [ 18%]
[  257s] scss/tests/extension/test_core.py::test_adjust_color PASSED              [ 18%]
[  257s] scss/tests/extension/test_core.py::test_scale_color PASSED               [ 18%]
[  257s] scss/tests/extension/test_core.py::test_change_color PASSED              [ 19%]
[  258s] scss/tests/extension/test_core.py::test_ie_hex_str PASSED                [ 19%]
[  258s] scss/tests/extension/test_core.py::test_unquote PASSED                   [ 20%]
[  258s] scss/tests/extension/test_core.py::test_quote PASSED                     [ 20%]
[  258s] scss/tests/extension/test_core.py::test_str_length PASSED                [ 20%]
[  258s] scss/tests/extension/test_core.py::test_str_insert PASSED                [ 21%]
[  258s] scss/tests/extension/test_core.py::test_str_index PASSED                 [ 21%]
[  258s] scss/tests/extension/test_core.py::test_str_slice PASSED                 [ 22%]
[  258s] scss/tests/extension/test_core.py::test_to_upper_case PASSED             [ 22%]
[  258s] scss/tests/extension/test_core.py::test_to_lower_case PASSED             [ 22%]
[  258s] scss/tests/extension/test_core.py::test_percentage PASSED                [ 23%]
[  258s] scss/tests/extension/test_core.py::test_round PASSED                     [ 23%]
[  258s] scss/tests/extension/test_core.py::test_ceil PASSED                      [ 24%]
[  258s] scss/tests/extension/test_core.py::test_floor PASSED                     [ 24%]
[  258s] scss/tests/extension/test_core.py::test_abs PASSED                       [ 25%]
[  258s] scss/tests/extension/test_core.py::test_min PASSED                       [ 25%]
[  258s] scss/tests/extension/test_core.py::test_max PASSED                       [ 25%]
[  258s] scss/tests/extension/test_core.py::test_length PASSED                    [ 26%]
[  258s] scss/tests/extension/test_core.py::test_nth PASSED                       [ 26%]
[  258s] scss/tests/extension/test_core.py::test_join PASSED                      [ 27%]
[  258s] scss/tests/extension/test_core.py::test_append PASSED                    [ 27%]
[  258s] scss/tests/extension/test_core.py::test_zip PASSED                       [ 27%]
[  258s] scss/tests/extension/test_core.py::test_index PASSED                     [ 28%]
[  258s] scss/tests/extension/test_core.py::test_list_separator PASSED            [ 28%]
[  258s] scss/tests/extension/test_core.py::test_set_nth PASSED                   [ 29%]
[  258s] scss/tests/extension/test_core.py::test_map_get PASSED                   [ 29%]
[  258s] scss/tests/extension/test_core.py::test_map_merge PASSED                 [ 29%]
[  258s] scss/tests/extension/test_core.py::test_map_keys PASSED                  [ 30%]
[  258s] scss/tests/extension/test_core.py::test_map_values PASSED                [ 30%]
[  258s] scss/tests/extension/test_core.py::test_map_has_key PASSED               [ 31%]
[  258s] scss/tests/extension/test_core.py::test_type_of PASSED                   [ 31%]
[  258s] scss/tests/extension/test_core.py::test_unit PASSED                      [ 31%]
[  258s] scss/tests/extension/test_core.py::test_unitless PASSED                  [ 32%]
[  258s] scss/tests/extension/test_core.py::test_comparable PASSED                [ 32%]
[  258s] scss/tests/extension/test_core.py::test_if PASSED                        [ 33%]
[  258s] scss/tests/extension/test_extra.py::test_background_noise SKIPPED (i...) [ 33%]
[  258s] scss/tests/extension/test_extra.py::test_background_brushed SKIPPED      [ 33%]
[  258s] scss/tests/extension/test_extra.py::test_grid_image SKIPPED (image t...) [ 34%]
[  258s] scss/tests/extension/test_extra.py::test_image_color SKIPPED (image ...) [ 34%]
[  258s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient PASSED [ 35%]
[  259s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient_idempotent XFAIL [ 35%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_blank PASSED          [ 35%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_compact PASSED        [ 36%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_reject PASSED         [ 36%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_first_value_of PASSED [ 37%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_enumerate PASSED      [ 37%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_headings PASSED       [ 37%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_nest PASSED           [ 38%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_opposite_position PASSED [ 38%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_pi PASSED             [ 39%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_e PASSED              [ 39%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_sqrt PASSED           [ 39%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_log PASSED            [ 40%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_pow PASSED            [ 40%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_font_url PASSED       [ 41%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_font_files PASSED     [ 41%]
[  259s] scss/tests/extension/compass/test_helpers.py::test_inline_font_files PASSED [ 41%]
[  259s] scss/tests/extension/compass/test_images.py::test_image_url PASSED       [ 42%]
[  259s] scss/tests/extension/compass/test_images.py::test_inline_image SKIPPED   [ 42%]
[  259s] scss/tests/extension/compass/test_images.py::test_inline_cursor SKIPPED  [ 43%]
[  259s] scss/tests/files/bugs/append.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append::scss PASSED [ 43%]
[  259s] scss/tests/files/bugs/argspec-named-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments::scss PASSED [ 43%]
[  259s] scss/tests/files/bugs/argspec-slurpy-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments::scss PASSED [ 44%]
[  259s] scss/tests/files/bugs/at-rules-1.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1::scss PASSED [ 44%]
[  259s] scss/tests/files/bugs/at-rules-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-2::scss PASSED [ 45%]
[  259s] scss/tests/files/bugs/at-rules-compressed-semicolon.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon::scss PASSED [ 45%]
[  259s] scss/tests/files/bugs/at-rules-duplicate-media-queries.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-duplicate-media-queries::scss PASSED [ 45%]
[  259s] scss/tests/files/bugs/at-rules-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation::scss PASSED [ 46%]
[  259s] scss/tests/files/bugs/base64url.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url::scss PASSED [ 46%]
[  259s] scss/tests/files/bugs/colors-preserve-names.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names::scss PASSED [ 47%]
[  259s] scss/tests/files/bugs/division-in-assignment.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-in-assignment::scss PASSED [ 47%]
[  259s] scss/tests/files/bugs/division-vs-literal-slash.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-vs-literal-slash::scss PASSED [ 47%]
[  259s] scss/tests/files/bugs/extend-child-selector.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector::scss PASSED [ 48%]
[  259s] scss/tests/files/bugs/extend-common-prefix-complex.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex::scss PASSED [ 48%]
[  259s] scss/tests/files/bugs/extend-common-prefix.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix::scss PASSED [ 49%]
[  259s] scss/tests/files/bugs/extend-selector-order.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order::scss PASSED [ 49%]
[  259s] scss/tests/files/bugs/for-to-vs-through.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/for-to-vs-through::scss PASSED [ 50%]
[  259s] scss/tests/files/bugs/if-with-parentheses.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses::scss PASSED [ 50%]
[  259s] scss/tests/files/bugs/interpolation-timing.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing::scss PASSED [ 50%]
[  259s] scss/tests/files/bugs/names-equivalence.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence::scss PASSED [ 51%]
[  259s] scss/tests/files/bugs/selectors-adjacent-is-not-include.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/selectors-adjacent-is-not-include::scss PASSED [ 51%]
[  259s] scss/tests/files/bugs/trailing-combinators.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators::scss PASSED [ 52%]
[  259s] scss/tests/files/bugs/unit-float-precision.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision::scss PASSED [ 52%]
[  260s] scss/tests/files/bugs/variables-font-face-default.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default::scss PASSED [ 52%]
[  260s] scss/tests/files/compass/current-color.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color::scss PASSED [ 53%]
[  260s] scss/tests/files/compass/gradients.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients::scss PASSED [ 53%]
[  260s] scss/tests/files/general/000-smoketest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest::scss PASSED [ 54%]
[  260s] scss/tests/files/general/css-calc.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/css-calc::scss PASSED [ 54%]
[  260s] scss/tests/files/general/each-destructuring-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2::scss PASSED [ 54%]
[  260s] scss/tests/files/general/each-destructuring-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3::scss PASSED [ 55%]
[  260s] scss/tests/files/general/each-destructuring.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring::scss PASSED [ 55%]
[  260s] scss/tests/files/general/empty-list-included.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included::scss PASSED [ 56%]
[  260s] scss/tests/files/general/global-variable-exists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists::scss PASSED [ 56%]
[  260s] scss/tests/files/general/if-lazy.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy::scss PASSED [ 56%]
[  260s] scss/tests/files/general/interpolation-acid.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid::scss PASSED [ 57%]
[  260s] scss/tests/files/general/interpolation-mixin-name.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name::scss PASSED [ 57%]
[  260s] scss/tests/files/general/maps-complex-keys.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys::scss PASSED [ 58%]
[  260s] scss/tests/files/general/maps-example-lists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists::scss PASSED [ 58%]
[  260s] scss/tests/files/general/maps-example.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example::scss PASSED [ 58%]
[  260s] scss/tests/files/general/names-loop-variable.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable::scss PASSED [ 59%]
[  260s] scss/tests/files/general/null-values.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values::scss PASSED [ 59%]
[  260s] scss/tests/files/general/scoping-mixin-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2::scss PASSED [ 60%]
[  260s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin::scss PASSED [ 60%]
[  260s] scss/tests/files/general/scoping-nested-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2::scss PASSED [ 60%]
[  260s] scss/tests/files/general/scoping-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested::scss PASSED [ 61%]
[  260s] scss/tests/files/general/slurpy-keyword-args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args::scss PASSED [ 61%]
[  260s] scss/tests/files/kronuz/args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args::scss PASSED [ 62%]
[  260s] scss/tests/files/kronuz/functions-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context::scss PASSED [ 62%]
[  260s] scss/tests/files/kronuz/image-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors::scss SKIPPED [ 62%]
[  260s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused::scss PASSED [ 63%]
[  260s] scss/tests/files/kronuz/linear-gradient.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient::scss PASSED [ 63%]
[  260s] scss/tests/files/kronuz/lists-circular-nth.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth::scss PASSED [ 64%]
[  260s] scss/tests/files/kronuz/lists-operations.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-operations::scss PASSED [ 64%]
[  261s] scss/tests/files/kronuz/mixin-varargs.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs::scss PASSED [ 64%]
[  261s] scss/tests/files/kronuz/mixins-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context::scss PASSED [ 65%]
[  261s] scss/tests/files/kronuz/mul-em.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-em::scss PASSED [ 65%]
[  261s] scss/tests/files/kronuz/mul-list.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-list::scss PASSED [ 66%]
[  261s] scss/tests/files/kronuz/order-test-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-each::scss PASSED [ 66%]
[  261s] scss/tests/files/kronuz/order-test-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-for::scss PASSED [ 66%]
[  261s] scss/tests/files/kronuz/order-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test::scss PASSED [ 67%]
[  261s] scss/tests/files/kronuz/reversed-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-for::scss PASSED [ 67%]
[  261s] scss/tests/files/kronuz/reversed-range.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range::scss PASSED [ 68%]
[  261s] scss/tests/files/kronuz/rgba-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors::scss PASSED [ 68%]
[  261s] scss/tests/files/kronuz/scope-loop-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables::scss PASSED [ 68%]
[  261s] scss/tests/files/kronuz/scoping-control.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control::scss PASSED [ 69%]
[  261s] scss/tests/files/kronuz/selectors-append-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest::scss PASSED [ 69%]
[  261s] scss/tests/files/kronuz/selectors-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest::scss PASSED [ 70%]
[  261s] scss/tests/files/kronuz/selectors-special.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special::scss PASSED [ 70%]
[  261s] scss/tests/files/kronuz/sprite-map.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map::scss SKIPPED [ 70%]
[  261s] scss/tests/files/kronuz/style-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested::scss PASSED [ 71%]
[  261s] scss/tests/files/kronuz/while-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/while-test::scss PASSED [ 71%]
[  261s] scss/tests/files/original-doctests/000-general.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general::scss PASSED [ 72%]
[  261s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables::scss PASSED [ 72%]
[  261s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children::scss PASSED [ 72%]
[  261s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2::scss PASSED [ 73%]
[  261s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3::scss PASSED [ 73%]
[  261s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends::scss PASSED [ 74%]
[  261s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2::scss PASSED [ 74%]
[  261s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3::scss PASSED [ 75%]
[  261s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4::scss PASSED [ 75%]
[  261s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5::scss PASSED [ 75%]
[  261s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math::scss PASSED [ 76%]
[  261s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2::scss PASSED [ 76%]
[  261s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3::scss PASSED [ 77%]
[  261s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting::scss PASSED [ 77%]
[  261s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2::scss PASSED [ 77%]
[  261s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3::scss PASSED [ 78%]
[  261s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables::scss PASSED [ 78%]
[  261s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation::scss PASSED [ 79%]
[  261s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins::scss PASSED [ 79%]
[  261s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2::scss PASSED [ 79%]
[  261s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3::scss PASSED [ 80%]
[  261s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend::scss PASSED [ 80%]
[  261s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple::scss PASSED [ 81%]
[  261s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2::scss PASSED [ 81%]
[  261s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder::scss PASSED [ 81%]
[  261s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum::scss PASSED [ 82%]
[  261s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2::scss PASSED [ 82%]
[  261s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3::scss PASSED [ 83%]
[  261s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors::scss PASSED [ 83%]
[  261s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2::scss PASSED [ 83%]
[  262s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3::scss PASSED [ 84%]
[  262s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test::scss PASSED [ 84%]
[  262s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2::scss PASSED [ 85%]
[  262s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3::scss PASSED [ 85%]
[  262s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4::scss PASSED [ 85%]
[  262s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5::scss PASSED [ 86%]
[  262s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6::scss PASSED [ 86%]
[  262s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7::scss PASSED [ 87%]
[  262s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8::scss PASSED [ 87%]
[  262s] scss/tests/files/original-doctests/039-hover-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend::scss PASSED [ 87%]
[  262s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4::scss PASSED [ 88%]
[  262s] scss/tests/files/original-doctests/040-complex-sequence-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend::scss PASSED [ 88%]
[  262s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend::scss PASSED [ 89%]
[  262s] scss/tests/files/regressions/args-vars.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars::scss PASSED [ 89%]
[  262s] scss/tests/files/regressions/argspec-default-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments::scss PASSED [ 89%]
[  262s] scss/tests/files/regressions/argspec-no-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments::scss PASSED [ 90%]
[  262s] scss/tests/files/regressions/argspec-trailing-comma.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma::scss PASSED [ 90%]
[  262s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2::scss PASSED [ 91%]
[  262s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation::scss PASSED [ 91%]
[  262s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10::scss PASSED [ 91%]
[  262s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110::scss PASSED [ 92%]
[  262s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2::scss PASSED [ 92%]
[  262s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21::scss PASSED [ 93%]
[  262s] scss/tests/files/regressions/issue-258.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258::scss PASSED [ 93%]
[  262s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32::scss PASSED [ 93%]
[  262s] scss/tests/files/regressions/issue-334-a.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a::scss PASSED [ 94%]
[  262s] scss/tests/files/regressions/issue-334-b.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b::scss PASSED [ 94%]
[  262s] scss/tests/files/regressions/issue-334-c.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c::scss PASSED [ 95%]
[  262s] scss/tests/files/regressions/issue-334-d.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d::scss PASSED [ 95%]
[  262s] scss/tests/files/regressions/issue-334-e.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e::scss PASSED [ 95%]
[  262s] scss/tests/files/regressions/issue-334-f.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f::scss PASSED [ 96%]
[  262s] scss/tests/files/regressions/issue-334-g.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g::scss PASSED [ 96%]
[  262s] scss/tests/files/regressions/issue-334-h.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h::scss PASSED [ 97%]
[  262s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4::scss PASSED [ 97%]
[  262s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40::scss PASSED [ 97%]
[  262s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5::scss PASSED [ 98%]
[  262s] scss/tests/files/regressions/issue-52.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52::scss PASSED [ 98%]
[  262s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6::scss PASSED [ 99%]
[  262s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7::scss PASSED [ 99%]
[  262s] scss/tests/files/regressions/nth-inside-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each::scss PASSED [100%]
[  262s] 
[  262s] =============================== warnings summary ===============================
[  262s] scss/compiler.py:1430
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1430: DeprecationWarning: invalid escape sequence \:
[  262s]     result = tb * (i + nesting) + "@media -sass-debug-info{filename{font-family:file\:\/\/%s}line{font-family:\\00003%s}}" % (filename, lineno) + nl
[  262s] 
[  262s] scss/cssdefs.py:497
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/cssdefs.py:497: DeprecationWarning: invalid escape sequence \s
[  262s]     _has_code_re = re.compile('''
[  262s] 
[  262s] conftest.py:62: 142 warnings
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/conftest.py:62: PytestRemovedIn8Warning: The (fspath: py.path.local) argument to SassFile is deprecated. Please use the (path: pathlib.Path) argument instead.
[  262s]   See https://docs.pytest.org/en/latest/deprecations.html#fspath-argument-for-node-constructors-replaced-with-pathlib-path
[  262s]     return SassFile.from_parent(parent, fspath=path)
[  262s] 
[  262s] scss/tests/test_misc.py:55
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/test_misc.py:55: DeprecationWarning: invalid escape sequence \:
[  262s]     expected = """\
[  262s] 
[  262s] scss/tests/test_expression.py::test_reference_operations
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/grammar/expression.py:104: DeprecationWarning: Flags not at the start of the expression '((?i)opacity)'
[  262s]     self.patterns.append((t, re.compile(p)))
[  262s] 
[  262s] scss/tests/test_misc.py::test_extend_across_files
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at first.css:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/test_misc.py::test_extend_across_files
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at first.css:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/test_misc.py::test_extend_across_files
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at second.css:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'reverse_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:337: DeprecationWarning: The 'warn' method is deprecated, use 'warning' instead
[  262s]     log.warn("Unused @import: '%s' (%s)", name, file_and_line)
[  262s] 
[  262s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  262s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  262s] 
[  262s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  262s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  262s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  262s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  262s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  262s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/selector.py:180: FutureWarning: The xCSS 'self' selector is deprecated and will be removed in 2.0.  Use & instead.  (<SimpleSelector: 'self'>)
[  262s]     warn(FutureWarning(
[  262s] 
[  262s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss:14)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  262s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  262s] 
[  262s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  262s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  262s] 
[  262s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:4)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:7)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss
[  262s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss:1)
[  262s]     warn_deprecated(
[  262s] 
[  262s] -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
[  262s] ==== 239 passed, 9 skipped, 1 deselected, 1 xfailed, 230 warnings in 12.80s ====
[  263s] ++ '[' -f _current_flavor ']'
[  263s] ++ cat _current_flavor
[  263s] + last_flavor=python38
[  263s] + '[' -z python38 ']'
[  263s] + '[' python38 '!=' python39 ']'
[  263s] + '[' -d build ']'
[  263s] + mv build _build.python38
[  263s] + '[' -d _build.python39 ']'
[  263s] + mv _build.python39 build
[  263s] + echo python39
[  263s] + python_flavor=python39
[  263s] + PYTHONPATH=/home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib/python3.9/site-packages
[  263s] + PYTHONDONTWRITEBYTECODE=1
[  263s] + pytest-3.9 --ignore=_build.python38 --ignore=_build.python39 --ignore=_build.python311 --ignore=_build.python310 -v -k 'not test_stdio'
[  266s] ============================= test session starts ==============================
[  266s] platform linux -- Python 3.9.16, pytest-7.2.0, pluggy-1.0.0 -- /usr/bin/python3.9
[  266s] cachedir: .pytest_cache
[  266s] rootdir: /home/abuild/rpmbuild/BUILD/pyScss-1.4.0
[  272s] collecting ... collected 249 items / 1 deselected / 1 skipped / 248 selected
[  272s] 
[  272s] scss/tests/test_expression.py::test_reference_operations PASSED          [  0%]
[  272s] scss/tests/test_expression.py::test_functions PASSED                     [  0%]
[  273s] scss/tests/test_expression.py::test_parse_strings PASSED                 [  1%]
[  273s] scss/tests/test_expression.py::test_parse_bang_important PASSED          [  1%]
[  273s] scss/tests/test_expression.py::test_parse_special_functions PASSED       [  2%]
[  273s] scss/tests/test_interactive.py::test_repl_expression PASSED              [  2%]
[  273s] scss/tests/test_interactive.py::test_repl_show PASSED                    [  2%]
[  273s] scss/tests/test_misc.py::test_super_selector PASSED                      [  3%]
[  273s] scss/tests/test_misc.py::test_debug_info PASSED                          [  3%]
[  273s] scss/tests/test_misc.py::test_live_errors PASSED                         [  4%]
[  273s] scss/tests/test_misc.py::test_extend_across_files PASSED                 [  4%]
[  273s] scss/tests/test_misc.py::test_unicode_files PASSED                       [  4%]
[  273s] scss/tests/test_misc.py::test_missing_import PASSED                      [  5%]
[  273s] scss/tests/test_types.py::test_addition PASSED                           [  5%]
[  273s] scss/tests/test_types.py::test_subtraction PASSED                        [  6%]
[  273s] scss/tests/test_types.py::test_division PASSED                           [  6%]
[  273s] scss/tests/test_types.py::test_comparison_numeric PASSED                 [  6%]
[  273s] scss/tests/test_types.py::test_comparison_stringerific PASSED            [  7%]
[  273s] scss/tests/test_types.py::test_comparison_null PASSED                    [  7%]
[  273s] scss/tests/test_types.py::test_unrenderable PASSED                       [  8%]
[  273s] scss/tests/extension/test_core.py::test_rgb PASSED                       [  8%]
[  273s] scss/tests/extension/test_core.py::test_rgba PASSED                      [  8%]
[  273s] scss/tests/extension/test_core.py::test_red PASSED                       [  9%]
[  273s] scss/tests/extension/test_core.py::test_green PASSED                     [  9%]
[  273s] scss/tests/extension/test_core.py::test_blue PASSED                      [ 10%]
[  273s] scss/tests/extension/test_core.py::test_mix PASSED                       [ 10%]
[  273s] scss/tests/extension/test_core.py::test_hsl PASSED                       [ 10%]
[  273s] scss/tests/extension/test_core.py::test_hsla PASSED                      [ 11%]
[  273s] scss/tests/extension/test_core.py::test_hue PASSED                       [ 11%]
[  273s] scss/tests/extension/test_core.py::test_saturation PASSED                [ 12%]
[  273s] scss/tests/extension/test_core.py::test_lightness PASSED                 [ 12%]
[  273s] scss/tests/extension/test_core.py::test_adjust_hue PASSED                [ 12%]
[  273s] scss/tests/extension/test_core.py::test_lighten PASSED                   [ 13%]
[  273s] scss/tests/extension/test_core.py::test_darken PASSED                    [ 13%]
[  273s] scss/tests/extension/test_core.py::test_saturate PASSED                  [ 14%]
[  273s] scss/tests/extension/test_core.py::test_desaturate PASSED                [ 14%]
[  273s] scss/tests/extension/test_core.py::test_grayscale PASSED                 [ 14%]
[  273s] scss/tests/extension/test_core.py::test_grayscale_css_filter PASSED      [ 15%]
[  273s] scss/tests/extension/test_core.py::test_complement PASSED                [ 15%]
[  273s] scss/tests/extension/test_core.py::test_invert PASSED                    [ 16%]
[  273s] scss/tests/extension/test_core.py::test_invert_css_filter PASSED         [ 16%]
[  273s] scss/tests/extension/test_core.py::test_alpha_opacity PASSED             [ 16%]
[  273s] scss/tests/extension/test_core.py::test_alpha_ie_filter PASSED           [ 17%]
[  273s] scss/tests/extension/test_core.py::test_opacify_fadein PASSED            [ 17%]
[  273s] scss/tests/extension/test_core.py::test_transparentize_fadeout PASSED    [ 18%]
[  273s] scss/tests/extension/test_core.py::test_adjust_color PASSED              [ 18%]
[  273s] scss/tests/extension/test_core.py::test_scale_color PASSED               [ 18%]
[  273s] scss/tests/extension/test_core.py::test_change_color PASSED              [ 19%]
[  273s] scss/tests/extension/test_core.py::test_ie_hex_str PASSED                [ 19%]
[  273s] scss/tests/extension/test_core.py::test_unquote PASSED                   [ 20%]
[  273s] scss/tests/extension/test_core.py::test_quote PASSED                     [ 20%]
[  273s] scss/tests/extension/test_core.py::test_str_length PASSED                [ 20%]
[  273s] scss/tests/extension/test_core.py::test_str_insert PASSED                [ 21%]
[  273s] scss/tests/extension/test_core.py::test_str_index PASSED                 [ 21%]
[  273s] scss/tests/extension/test_core.py::test_str_slice PASSED                 [ 22%]
[  273s] scss/tests/extension/test_core.py::test_to_upper_case PASSED             [ 22%]
[  273s] scss/tests/extension/test_core.py::test_to_lower_case PASSED             [ 22%]
[  273s] scss/tests/extension/test_core.py::test_percentage PASSED                [ 23%]
[  273s] scss/tests/extension/test_core.py::test_round PASSED                     [ 23%]
[  273s] scss/tests/extension/test_core.py::test_ceil PASSED                      [ 24%]
[  273s] scss/tests/extension/test_core.py::test_floor PASSED                     [ 24%]
[  273s] scss/tests/extension/test_core.py::test_abs PASSED                       [ 25%]
[  273s] scss/tests/extension/test_core.py::test_min PASSED                       [ 25%]
[  274s] scss/tests/extension/test_core.py::test_max PASSED                       [ 25%]
[  274s] scss/tests/extension/test_core.py::test_length PASSED                    [ 26%]
[  274s] scss/tests/extension/test_core.py::test_nth PASSED                       [ 26%]
[  274s] scss/tests/extension/test_core.py::test_join PASSED                      [ 27%]
[  274s] scss/tests/extension/test_core.py::test_append PASSED                    [ 27%]
[  274s] scss/tests/extension/test_core.py::test_zip PASSED                       [ 27%]
[  274s] scss/tests/extension/test_core.py::test_index PASSED                     [ 28%]
[  274s] scss/tests/extension/test_core.py::test_list_separator PASSED            [ 28%]
[  274s] scss/tests/extension/test_core.py::test_set_nth PASSED                   [ 29%]
[  274s] scss/tests/extension/test_core.py::test_map_get PASSED                   [ 29%]
[  274s] scss/tests/extension/test_core.py::test_map_merge PASSED                 [ 29%]
[  274s] scss/tests/extension/test_core.py::test_map_keys PASSED                  [ 30%]
[  274s] scss/tests/extension/test_core.py::test_map_values PASSED                [ 30%]
[  274s] scss/tests/extension/test_core.py::test_map_has_key PASSED               [ 31%]
[  274s] scss/tests/extension/test_core.py::test_type_of PASSED                   [ 31%]
[  274s] scss/tests/extension/test_core.py::test_unit PASSED                      [ 31%]
[  274s] scss/tests/extension/test_core.py::test_unitless PASSED                  [ 32%]
[  274s] scss/tests/extension/test_core.py::test_comparable PASSED                [ 32%]
[  274s] scss/tests/extension/test_core.py::test_if PASSED                        [ 33%]
[  274s] scss/tests/extension/test_extra.py::test_background_noise SKIPPED (i...) [ 33%]
[  274s] scss/tests/extension/test_extra.py::test_background_brushed SKIPPED      [ 33%]
[  274s] scss/tests/extension/test_extra.py::test_grid_image SKIPPED (image t...) [ 34%]
[  274s] scss/tests/extension/test_extra.py::test_image_color SKIPPED (image ...) [ 34%]
[  274s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient PASSED [ 35%]
[  274s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient_idempotent XFAIL [ 35%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_blank PASSED          [ 35%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_compact PASSED        [ 36%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_reject PASSED         [ 36%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_first_value_of PASSED [ 37%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_enumerate PASSED      [ 37%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_headings PASSED       [ 37%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_nest PASSED           [ 38%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_opposite_position PASSED [ 38%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_pi PASSED             [ 39%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_e PASSED              [ 39%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_sqrt PASSED           [ 39%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_log PASSED            [ 40%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_pow PASSED            [ 40%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_font_url PASSED       [ 41%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_font_files PASSED     [ 41%]
[  274s] scss/tests/extension/compass/test_helpers.py::test_inline_font_files PASSED [ 41%]
[  275s] scss/tests/extension/compass/test_images.py::test_image_url PASSED       [ 42%]
[  275s] scss/tests/extension/compass/test_images.py::test_inline_image SKIPPED   [ 42%]
[  275s] scss/tests/extension/compass/test_images.py::test_inline_cursor SKIPPED  [ 43%]
[  275s] scss/tests/files/bugs/append.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append::scss PASSED [ 43%]
[  275s] scss/tests/files/bugs/argspec-named-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments::scss PASSED [ 43%]
[  275s] scss/tests/files/bugs/argspec-slurpy-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments::scss PASSED [ 44%]
[  275s] scss/tests/files/bugs/at-rules-1.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1::scss PASSED [ 44%]
[  275s] scss/tests/files/bugs/at-rules-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-2::scss PASSED [ 45%]
[  275s] scss/tests/files/bugs/at-rules-compressed-semicolon.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon::scss PASSED [ 45%]
[  275s] scss/tests/files/bugs/at-rules-duplicate-media-queries.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-duplicate-media-queries::scss PASSED [ 45%]
[  275s] scss/tests/files/bugs/at-rules-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation::scss PASSED [ 46%]
[  275s] scss/tests/files/bugs/base64url.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url::scss PASSED [ 46%]
[  275s] scss/tests/files/bugs/colors-preserve-names.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names::scss PASSED [ 47%]
[  275s] scss/tests/files/bugs/division-in-assignment.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-in-assignment::scss PASSED [ 47%]
[  275s] scss/tests/files/bugs/division-vs-literal-slash.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-vs-literal-slash::scss PASSED [ 47%]
[  275s] scss/tests/files/bugs/extend-child-selector.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector::scss PASSED [ 48%]
[  275s] scss/tests/files/bugs/extend-common-prefix-complex.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex::scss PASSED [ 48%]
[  275s] scss/tests/files/bugs/extend-common-prefix.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix::scss PASSED [ 49%]
[  275s] scss/tests/files/bugs/extend-selector-order.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order::scss PASSED [ 49%]
[  275s] scss/tests/files/bugs/for-to-vs-through.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/for-to-vs-through::scss PASSED [ 50%]
[  275s] scss/tests/files/bugs/if-with-parentheses.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses::scss PASSED [ 50%]
[  275s] scss/tests/files/bugs/interpolation-timing.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing::scss PASSED [ 50%]
[  275s] scss/tests/files/bugs/names-equivalence.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence::scss PASSED [ 51%]
[  275s] scss/tests/files/bugs/selectors-adjacent-is-not-include.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/selectors-adjacent-is-not-include::scss PASSED [ 51%]
[  275s] scss/tests/files/bugs/trailing-combinators.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators::scss PASSED [ 52%]
[  275s] scss/tests/files/bugs/unit-float-precision.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision::scss PASSED [ 52%]
[  275s] scss/tests/files/bugs/variables-font-face-default.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default::scss PASSED [ 52%]
[  275s] scss/tests/files/compass/current-color.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color::scss PASSED [ 53%]
[  275s] scss/tests/files/compass/gradients.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients::scss PASSED [ 53%]
[  275s] scss/tests/files/general/000-smoketest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest::scss PASSED [ 54%]
[  275s] scss/tests/files/general/css-calc.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/css-calc::scss PASSED [ 54%]
[  275s] scss/tests/files/general/each-destructuring-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2::scss PASSED [ 54%]
[  275s] scss/tests/files/general/each-destructuring-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3::scss PASSED [ 55%]
[  275s] scss/tests/files/general/each-destructuring.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring::scss PASSED [ 55%]
[  275s] scss/tests/files/general/empty-list-included.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included::scss PASSED [ 56%]
[  275s] scss/tests/files/general/global-variable-exists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists::scss PASSED [ 56%]
[  275s] scss/tests/files/general/if-lazy.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy::scss PASSED [ 56%]
[  276s] scss/tests/files/general/interpolation-acid.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid::scss PASSED [ 57%]
[  276s] scss/tests/files/general/interpolation-mixin-name.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name::scss PASSED [ 57%]
[  276s] scss/tests/files/general/maps-complex-keys.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys::scss PASSED [ 58%]
[  276s] scss/tests/files/general/maps-example-lists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists::scss PASSED [ 58%]
[  276s] scss/tests/files/general/maps-example.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example::scss PASSED [ 58%]
[  276s] scss/tests/files/general/names-loop-variable.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable::scss PASSED [ 59%]
[  276s] scss/tests/files/general/null-values.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values::scss PASSED [ 59%]
[  276s] scss/tests/files/general/scoping-mixin-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2::scss PASSED [ 60%]
[  276s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin::scss PASSED [ 60%]
[  276s] scss/tests/files/general/scoping-nested-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2::scss PASSED [ 60%]
[  276s] scss/tests/files/general/scoping-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested::scss PASSED [ 61%]
[  276s] scss/tests/files/general/slurpy-keyword-args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args::scss PASSED [ 61%]
[  276s] scss/tests/files/kronuz/args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args::scss PASSED [ 62%]
[  276s] scss/tests/files/kronuz/functions-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context::scss PASSED [ 62%]
[  276s] scss/tests/files/kronuz/image-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors::scss SKIPPED [ 62%]
[  276s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused::scss PASSED [ 63%]
[  276s] scss/tests/files/kronuz/linear-gradient.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient::scss PASSED [ 63%]
[  276s] scss/tests/files/kronuz/lists-circular-nth.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth::scss PASSED [ 64%]
[  276s] scss/tests/files/kronuz/lists-operations.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-operations::scss PASSED [ 64%]
[  276s] scss/tests/files/kronuz/mixin-varargs.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs::scss PASSED [ 64%]
[  276s] scss/tests/files/kronuz/mixins-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context::scss PASSED [ 65%]
[  276s] scss/tests/files/kronuz/mul-em.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-em::scss PASSED [ 65%]
[  276s] scss/tests/files/kronuz/mul-list.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-list::scss PASSED [ 66%]
[  276s] scss/tests/files/kronuz/order-test-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-each::scss PASSED [ 66%]
[  276s] scss/tests/files/kronuz/order-test-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-for::scss PASSED [ 66%]
[  276s] scss/tests/files/kronuz/order-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test::scss PASSED [ 67%]
[  276s] scss/tests/files/kronuz/reversed-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-for::scss PASSED [ 67%]
[  276s] scss/tests/files/kronuz/reversed-range.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range::scss PASSED [ 68%]
[  276s] scss/tests/files/kronuz/rgba-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors::scss PASSED [ 68%]
[  276s] scss/tests/files/kronuz/scope-loop-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables::scss PASSED [ 68%]
[  276s] scss/tests/files/kronuz/scoping-control.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control::scss PASSED [ 69%]
[  276s] scss/tests/files/kronuz/selectors-append-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest::scss PASSED [ 69%]
[  276s] scss/tests/files/kronuz/selectors-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest::scss PASSED [ 70%]
[  276s] scss/tests/files/kronuz/selectors-special.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special::scss PASSED [ 70%]
[  276s] scss/tests/files/kronuz/sprite-map.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map::scss SKIPPED [ 70%]
[  276s] scss/tests/files/kronuz/style-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested::scss PASSED [ 71%]
[  277s] scss/tests/files/kronuz/while-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/while-test::scss PASSED [ 71%]
[  277s] scss/tests/files/original-doctests/000-general.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general::scss PASSED [ 72%]
[  277s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables::scss PASSED [ 72%]
[  277s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children::scss PASSED [ 72%]
[  277s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2::scss PASSED [ 73%]
[  277s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3::scss PASSED [ 73%]
[  277s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends::scss PASSED [ 74%]
[  277s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2::scss PASSED [ 74%]
[  277s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3::scss PASSED [ 75%]
[  277s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4::scss PASSED [ 75%]
[  277s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5::scss PASSED [ 75%]
[  277s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math::scss PASSED [ 76%]
[  277s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2::scss PASSED [ 76%]
[  277s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3::scss PASSED [ 77%]
[  277s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting::scss PASSED [ 77%]
[  277s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2::scss PASSED [ 77%]
[  277s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3::scss PASSED [ 78%]
[  277s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables::scss PASSED [ 78%]
[  277s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation::scss PASSED [ 79%]
[  277s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins::scss PASSED [ 79%]
[  277s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2::scss PASSED [ 79%]
[  277s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3::scss PASSED [ 80%]
[  277s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend::scss PASSED [ 80%]
[  277s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple::scss PASSED [ 81%]
[  277s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2::scss PASSED [ 81%]
[  277s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder::scss PASSED [ 81%]
[  277s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum::scss PASSED [ 82%]
[  277s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2::scss PASSED [ 82%]
[  277s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3::scss PASSED [ 83%]
[  277s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors::scss PASSED [ 83%]
[  277s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2::scss PASSED [ 83%]
[  277s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3::scss PASSED [ 84%]
[  277s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test::scss PASSED [ 84%]
[  277s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2::scss PASSED [ 85%]
[  277s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3::scss PASSED [ 85%]
[  277s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4::scss PASSED [ 85%]
[  277s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5::scss PASSED [ 86%]
[  277s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6::scss PASSED [ 86%]
[  277s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7::scss PASSED [ 87%]
[  277s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8::scss PASSED [ 87%]
[  277s] scss/tests/files/original-doctests/039-hover-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend::scss PASSED [ 87%]
[  277s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4::scss PASSED [ 88%]
[  278s] scss/tests/files/original-doctests/040-complex-sequence-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend::scss PASSED [ 88%]
[  278s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend::scss PASSED [ 89%]
[  278s] scss/tests/files/regressions/args-vars.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars::scss PASSED [ 89%]
[  278s] scss/tests/files/regressions/argspec-default-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments::scss PASSED [ 89%]
[  278s] scss/tests/files/regressions/argspec-no-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments::scss PASSED [ 90%]
[  278s] scss/tests/files/regressions/argspec-trailing-comma.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma::scss PASSED [ 90%]
[  278s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2::scss PASSED [ 91%]
[  278s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation::scss PASSED [ 91%]
[  278s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10::scss PASSED [ 91%]
[  278s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110::scss PASSED [ 92%]
[  278s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2::scss PASSED [ 92%]
[  278s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21::scss PASSED [ 93%]
[  278s] scss/tests/files/regressions/issue-258.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258::scss PASSED [ 93%]
[  278s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32::scss PASSED [ 93%]
[  278s] scss/tests/files/regressions/issue-334-a.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a::scss PASSED [ 94%]
[  278s] scss/tests/files/regressions/issue-334-b.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b::scss PASSED [ 94%]
[  278s] scss/tests/files/regressions/issue-334-c.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c::scss PASSED [ 95%]
[  278s] scss/tests/files/regressions/issue-334-d.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d::scss PASSED [ 95%]
[  278s] scss/tests/files/regressions/issue-334-e.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e::scss PASSED [ 95%]
[  278s] scss/tests/files/regressions/issue-334-f.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f::scss PASSED [ 96%]
[  278s] scss/tests/files/regressions/issue-334-g.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g::scss PASSED [ 96%]
[  278s] scss/tests/files/regressions/issue-334-h.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h::scss PASSED [ 97%]
[  278s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4::scss PASSED [ 97%]
[  278s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40::scss PASSED [ 97%]
[  278s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5::scss PASSED [ 98%]
[  278s] scss/tests/files/regressions/issue-52.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52::scss PASSED [ 98%]
[  278s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6::scss PASSED [ 99%]
[  278s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7::scss PASSED [ 99%]
[  278s] scss/tests/files/regressions/nth-inside-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each::scss PASSED [100%]
[  278s] 
[  278s] =============================== warnings summary ===============================
[  278s] scss/compiler.py:1430
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1430: DeprecationWarning: invalid escape sequence \:
[  278s]     result = tb * (i + nesting) + "@media -sass-debug-info{filename{font-family:file\:\/\/%s}line{font-family:\\00003%s}}" % (filename, lineno) + nl
[  278s] 
[  278s] scss/cssdefs.py:497
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/cssdefs.py:497: DeprecationWarning: invalid escape sequence \s
[  278s]     _has_code_re = re.compile('''
[  278s] 
[  278s] conftest.py:62: 142 warnings
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/conftest.py:62: PytestRemovedIn8Warning: The (fspath: py.path.local) argument to SassFile is deprecated. Please use the (path: pathlib.Path) argument instead.
[  278s]   See https://docs.pytest.org/en/latest/deprecations.html#fspath-argument-for-node-constructors-replaced-with-pathlib-path
[  278s]     return SassFile.from_parent(parent, fspath=path)
[  278s] 
[  278s] scss/tests/test_misc.py:55
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/test_misc.py:55: DeprecationWarning: invalid escape sequence \:
[  278s]     expected = """\
[  278s] 
[  278s] scss/tests/test_expression.py::test_reference_operations
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/grammar/expression.py:104: DeprecationWarning: Flags not at the start of the expression '((?i)opacity)' but at position 1
[  278s]     self.patterns.append((t, re.compile(p)))
[  278s] 
[  278s] scss/tests/test_misc.py::test_extend_across_files
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at first.css:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/test_misc.py::test_extend_across_files
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at first.css:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/test_misc.py::test_extend_across_files
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at second.css:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'reverse_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:337: DeprecationWarning: The 'warn' method is deprecated, use 'warning' instead
[  278s]     log.warn("Unused @import: '%s' (%s)", name, file_and_line)
[  278s] 
[  278s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  278s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  278s] 
[  278s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  278s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  278s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  278s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  278s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  278s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/selector.py:180: FutureWarning: The xCSS 'self' selector is deprecated and will be removed in 2.0.  Use & instead.  (<SimpleSelector: 'self'>)
[  278s]     warn(FutureWarning(
[  278s] 
[  278s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss:14)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  278s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  278s] 
[  278s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  278s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  278s] 
[  278s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:4)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:7)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss
[  278s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss:1)
[  278s]     warn_deprecated(
[  278s] 
[  278s] -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
[  278s] ==== 239 passed, 9 skipped, 1 deselected, 1 xfailed, 230 warnings in 11.70s ====
[  278s] ++ '[' -f _current_flavor ']'
[  278s] ++ cat _current_flavor
[  278s] + last_flavor=python39
[  278s] + '[' -z python39 ']'
[  278s] + '[' python39 '!=' python311 ']'
[  278s] + '[' -d build ']'
[  278s] + mv build _build.python39
[  278s] + '[' -d _build.python311 ']'
[  278s] + mv _build.python311 build
[  278s] + echo python311
[  278s] + python_flavor=python311
[  278s] + PYTHONPATH=/home/abuild/rpmbuild/BUILDROOT/python-pyScss-1.4.0-1.2.riscv64/usr/lib/python3.11/site-packages
[  278s] + PYTHONDONTWRITEBYTECODE=1
[  278s] + pytest-3.11 --ignore=_build.python38 --ignore=_build.python39 --ignore=_build.python311 --ignore=_build.python310 -v -k 'not test_stdio'
[  282s] ============================= test session starts ==============================
[  282s] platform linux -- Python 3.11.1, pytest-7.2.0, pluggy-1.0.0 -- /usr/bin/python3.11
[  282s] cachedir: .pytest_cache
[  282s] rootdir: /home/abuild/rpmbuild/BUILD/pyScss-1.4.0
[  287s] collecting ... collected 249 items / 1 deselected / 1 skipped / 248 selected
[  287s] 
[  289s] scss/tests/test_expression.py::test_reference_operations FAILED          [  0%]
[  289s] scss/tests/test_expression.py::test_functions FAILED                     [  0%]
[  290s] scss/tests/test_expression.py::test_parse_strings FAILED                 [  1%]
[  291s] scss/tests/test_expression.py::test_parse_bang_important FAILED          [  1%]
[  292s] scss/tests/test_expression.py::test_parse_special_functions FAILED       [  2%]
[  292s] scss/tests/test_interactive.py::test_repl_expression PASSED              [  2%]
[  292s] scss/tests/test_interactive.py::test_repl_show PASSED                    [  2%]
[  294s] scss/tests/test_misc.py::test_super_selector FAILED                      [  3%]
[  295s] scss/tests/test_misc.py::test_debug_info FAILED                          [  3%]
[  297s] scss/tests/test_misc.py::test_live_errors FAILED                         [  4%]
[  297s] scss/tests/test_misc.py::test_extend_across_files PASSED                 [  4%]
[  297s] scss/tests/test_misc.py::test_unicode_files PASSED                       [  4%]
[  297s] scss/tests/test_misc.py::test_missing_import PASSED                      [  5%]
[  297s] scss/tests/test_types.py::test_addition PASSED                           [  5%]
[  297s] scss/tests/test_types.py::test_subtraction PASSED                        [  6%]
[  297s] scss/tests/test_types.py::test_division PASSED                           [  6%]
[  297s] scss/tests/test_types.py::test_comparison_numeric PASSED                 [  6%]
[  297s] scss/tests/test_types.py::test_comparison_stringerific PASSED            [  7%]
[  297s] scss/tests/test_types.py::test_comparison_null PASSED                    [  7%]
[  297s] scss/tests/test_types.py::test_unrenderable PASSED                       [  8%]
[  298s] scss/tests/extension/test_core.py::test_rgb FAILED                       [  8%]
[  298s] scss/tests/extension/test_core.py::test_rgba FAILED                      [  8%]
[  299s] scss/tests/extension/test_core.py::test_red FAILED                       [  9%]
[  300s] scss/tests/extension/test_core.py::test_green FAILED                     [  9%]
[  301s] scss/tests/extension/test_core.py::test_blue FAILED                      [ 10%]
[  301s] scss/tests/extension/test_core.py::test_mix FAILED                       [ 10%]
[  302s] scss/tests/extension/test_core.py::test_hsl FAILED                       [ 10%]
[  303s] scss/tests/extension/test_core.py::test_hsla FAILED                      [ 11%]
[  304s] scss/tests/extension/test_core.py::test_hue FAILED                       [ 11%]
[  304s] scss/tests/extension/test_core.py::test_saturation FAILED                [ 12%]
[  305s] scss/tests/extension/test_core.py::test_lightness FAILED                 [ 12%]
[  306s] scss/tests/extension/test_core.py::test_adjust_hue FAILED                [ 12%]
[  307s] scss/tests/extension/test_core.py::test_lighten FAILED                   [ 13%]
[  307s] scss/tests/extension/test_core.py::test_darken FAILED                    [ 13%]
[  308s] scss/tests/extension/test_core.py::test_saturate FAILED                  [ 14%]
[  309s] scss/tests/extension/test_core.py::test_desaturate FAILED                [ 14%]
[  310s] scss/tests/extension/test_core.py::test_grayscale FAILED                 [ 14%]
[  310s] scss/tests/extension/test_core.py::test_grayscale_css_filter FAILED      [ 15%]
[  311s] scss/tests/extension/test_core.py::test_complement FAILED                [ 15%]
[  312s] scss/tests/extension/test_core.py::test_invert FAILED                    [ 16%]
[  313s] scss/tests/extension/test_core.py::test_invert_css_filter FAILED         [ 16%]
[  314s] scss/tests/extension/test_core.py::test_alpha_opacity FAILED             [ 16%]
[  315s] scss/tests/extension/test_core.py::test_alpha_ie_filter FAILED           [ 17%]
[  316s] scss/tests/extension/test_core.py::test_opacify_fadein FAILED            [ 17%]
[  316s] scss/tests/extension/test_core.py::test_transparentize_fadeout FAILED    [ 18%]
[  317s] scss/tests/extension/test_core.py::test_adjust_color FAILED              [ 18%]
[  318s] scss/tests/extension/test_core.py::test_scale_color FAILED               [ 18%]
[  318s] scss/tests/extension/test_core.py::test_change_color FAILED              [ 19%]
[  319s] scss/tests/extension/test_core.py::test_ie_hex_str FAILED                [ 19%]
[  320s] scss/tests/extension/test_core.py::test_unquote FAILED                   [ 20%]
[  321s] scss/tests/extension/test_core.py::test_quote FAILED                     [ 20%]
[  322s] scss/tests/extension/test_core.py::test_str_length FAILED                [ 20%]
[  323s] scss/tests/extension/test_core.py::test_str_insert FAILED                [ 21%]
[  323s] scss/tests/extension/test_core.py::test_str_index FAILED                 [ 21%]
[  324s] scss/tests/extension/test_core.py::test_str_slice FAILED                 [ 22%]
[  325s] scss/tests/extension/test_core.py::test_to_upper_case FAILED             [ 22%]
[  326s] scss/tests/extension/test_core.py::test_to_lower_case FAILED             [ 22%]
[  327s] scss/tests/extension/test_core.py::test_percentage FAILED                [ 23%]
[  327s] scss/tests/extension/test_core.py::test_round FAILED                     [ 23%]
[  328s] scss/tests/extension/test_core.py::test_ceil FAILED                      [ 24%]
[  329s] scss/tests/extension/test_core.py::test_floor FAILED                     [ 24%]
[  330s] scss/tests/extension/test_core.py::test_abs FAILED                       [ 25%]
[  331s] scss/tests/extension/test_core.py::test_min FAILED                       [ 25%]
[  331s] scss/tests/extension/test_core.py::test_max FAILED                       [ 25%]
[  332s] scss/tests/extension/test_core.py::test_length FAILED                    [ 26%]
[  333s] scss/tests/extension/test_core.py::test_nth FAILED                       [ 26%]
[  334s] scss/tests/extension/test_core.py::test_join FAILED                      [ 27%]
[  335s] scss/tests/extension/test_core.py::test_append FAILED                    [ 27%]
[  336s] scss/tests/extension/test_core.py::test_zip FAILED                       [ 27%]
[  336s] scss/tests/extension/test_core.py::test_index FAILED                     [ 28%]
[  337s] scss/tests/extension/test_core.py::test_list_separator FAILED            [ 28%]
[  338s] scss/tests/extension/test_core.py::test_set_nth FAILED                   [ 29%]
[  339s] scss/tests/extension/test_core.py::test_map_get FAILED                   [ 29%]
[  340s] scss/tests/extension/test_core.py::test_map_merge FAILED                 [ 29%]
[  340s] scss/tests/extension/test_core.py::test_map_keys FAILED                  [ 30%]
[  341s] scss/tests/extension/test_core.py::test_map_values FAILED                [ 30%]
[  342s] scss/tests/extension/test_core.py::test_map_has_key FAILED               [ 31%]
[  342s] scss/tests/extension/test_core.py::test_type_of FAILED                   [ 31%]
[  343s] scss/tests/extension/test_core.py::test_unit FAILED                      [ 31%]
[  344s] scss/tests/extension/test_core.py::test_unitless FAILED                  [ 32%]
[  345s] scss/tests/extension/test_core.py::test_comparable FAILED                [ 32%]
[  346s] scss/tests/extension/test_core.py::test_if FAILED                        [ 33%]
[  346s] scss/tests/extension/test_extra.py::test_background_noise SKIPPED (i...) [ 33%]
[  346s] scss/tests/extension/test_extra.py::test_background_brushed SKIPPED      [ 33%]
[  346s] scss/tests/extension/test_extra.py::test_grid_image SKIPPED (image t...) [ 34%]
[  346s] scss/tests/extension/test_extra.py::test_image_color SKIPPED (image ...) [ 34%]
[  346s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient PASSED [ 35%]
[  347s] scss/tests/extension/compass/test_gradients.py::test_linear_gradient_idempotent XFAIL [ 35%]
[  347s] scss/tests/extension/compass/test_helpers.py::test_blank FAILED          [ 35%]
[  348s] scss/tests/extension/compass/test_helpers.py::test_compact FAILED        [ 36%]
[  348s] scss/tests/extension/compass/test_helpers.py::test_reject FAILED         [ 36%]
[  349s] scss/tests/extension/compass/test_helpers.py::test_first_value_of FAILED [ 37%]
[  350s] scss/tests/extension/compass/test_helpers.py::test_enumerate FAILED      [ 37%]
[  350s] scss/tests/extension/compass/test_helpers.py::test_headings FAILED       [ 37%]
[  351s] scss/tests/extension/compass/test_helpers.py::test_nest FAILED           [ 38%]
[  352s] scss/tests/extension/compass/test_helpers.py::test_opposite_position FAILED [ 38%]
[  352s] scss/tests/extension/compass/test_helpers.py::test_pi FAILED             [ 39%]
[  353s] scss/tests/extension/compass/test_helpers.py::test_e FAILED              [ 39%]
[  354s] scss/tests/extension/compass/test_helpers.py::test_sqrt FAILED           [ 39%]
[  354s] scss/tests/extension/compass/test_helpers.py::test_log FAILED            [ 40%]
[  355s] scss/tests/extension/compass/test_helpers.py::test_pow FAILED            [ 40%]
[  356s] scss/tests/extension/compass/test_helpers.py::test_font_url FAILED       [ 41%]
[  356s] scss/tests/extension/compass/test_helpers.py::test_font_files FAILED     [ 41%]
[  357s] scss/tests/extension/compass/test_helpers.py::test_inline_font_files FAILED [ 41%]
[  357s] scss/tests/extension/compass/test_images.py::test_image_url FAILED       [ 42%]
[  357s] scss/tests/extension/compass/test_images.py::test_inline_image SKIPPED   [ 42%]
[  357s] scss/tests/extension/compass/test_images.py::test_inline_cursor SKIPPED  [ 43%]
[  359s] scss/tests/files/bugs/append.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append::scss FAILED [ 43%]
[  361s] scss/tests/files/bugs/argspec-named-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments::scss FAILED [ 43%]
[  363s] scss/tests/files/bugs/argspec-slurpy-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments::scss FAILED [ 44%]
[  366s] scss/tests/files/bugs/at-rules-1.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1::scss FAILED [ 44%]
[  366s] scss/tests/files/bugs/at-rules-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-2::scss PASSED [ 45%]
[  368s] scss/tests/files/bugs/at-rules-compressed-semicolon.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon::scss FAILED [ 45%]
[  368s] scss/tests/files/bugs/at-rules-duplicate-media-queries.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-duplicate-media-queries::scss PASSED [ 45%]
[  370s] scss/tests/files/bugs/at-rules-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation::scss FAILED [ 46%]
[  372s] scss/tests/files/bugs/base64url.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url::scss FAILED [ 46%]
[  374s] scss/tests/files/bugs/colors-preserve-names.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names::scss FAILED [ 47%]
[  374s] scss/tests/files/bugs/division-in-assignment.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-in-assignment::scss PASSED [ 47%]
[  374s] scss/tests/files/bugs/division-vs-literal-slash.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/division-vs-literal-slash::scss PASSED [ 47%]
[  375s] scss/tests/files/bugs/extend-child-selector.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector::scss FAILED [ 48%]
[  377s] scss/tests/files/bugs/extend-common-prefix-complex.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex::scss FAILED [ 48%]
[  377s] scss/tests/files/bugs/extend-common-prefix.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix::scss PASSED [ 49%]
[  379s] scss/tests/files/bugs/extend-selector-order.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order::scss FAILED [ 49%]
[  379s] scss/tests/files/bugs/for-to-vs-through.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/for-to-vs-through::scss PASSED [ 50%]
[  382s] scss/tests/files/bugs/if-with-parentheses.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses::scss FAILED [ 50%]
[  383s] scss/tests/files/bugs/interpolation-timing.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing::scss FAILED [ 50%]
[  385s] scss/tests/files/bugs/names-equivalence.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence::scss FAILED [ 51%]
[  385s] scss/tests/files/bugs/selectors-adjacent-is-not-include.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/selectors-adjacent-is-not-include::scss PASSED [ 51%]
[  387s] scss/tests/files/bugs/trailing-combinators.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators::scss FAILED [ 52%]
[  389s] scss/tests/files/bugs/unit-float-precision.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision::scss FAILED [ 52%]
[  390s] scss/tests/files/bugs/variables-font-face-default.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default::scss FAILED [ 52%]
[  392s] scss/tests/files/compass/current-color.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color::scss FAILED [ 53%]
[  394s] scss/tests/files/compass/gradients.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients::scss FAILED [ 53%]
[  396s] scss/tests/files/general/000-smoketest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest::scss FAILED [ 54%]
[  396s] scss/tests/files/general/css-calc.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/css-calc::scss PASSED [ 54%]
[  398s] scss/tests/files/general/each-destructuring-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2::scss FAILED [ 54%]
[  400s] scss/tests/files/general/each-destructuring-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3::scss FAILED [ 55%]
[  402s] scss/tests/files/general/each-destructuring.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring::scss FAILED [ 55%]
[  403s] scss/tests/files/general/empty-list-included.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included::scss FAILED [ 56%]
[  405s] scss/tests/files/general/global-variable-exists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists::scss FAILED [ 56%]
[  407s] scss/tests/files/general/if-lazy.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy::scss FAILED [ 56%]
[  409s] scss/tests/files/general/interpolation-acid.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid::scss FAILED [ 57%]
[  411s] scss/tests/files/general/interpolation-mixin-name.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name::scss FAILED [ 57%]
[  413s] scss/tests/files/general/maps-complex-keys.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys::scss FAILED [ 58%]
[  415s] scss/tests/files/general/maps-example-lists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists::scss FAILED [ 58%]
[  417s] scss/tests/files/general/maps-example.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example::scss FAILED [ 58%]
[  419s] scss/tests/files/general/names-loop-variable.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable::scss FAILED [ 59%]
[  421s] scss/tests/files/general/null-values.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values::scss FAILED [ 59%]
[  423s] scss/tests/files/general/scoping-mixin-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2::scss FAILED [ 60%]
[  424s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin::scss FAILED [ 60%]
[  426s] scss/tests/files/general/scoping-nested-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2::scss FAILED [ 60%]
[  428s] scss/tests/files/general/scoping-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested::scss FAILED [ 61%]
[  429s] scss/tests/files/general/slurpy-keyword-args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args::scss FAILED [ 61%]
[  431s] scss/tests/files/kronuz/args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args::scss FAILED [ 62%]
[  432s] scss/tests/files/kronuz/functions-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context::scss FAILED [ 62%]
[  434s] scss/tests/files/kronuz/image-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors::scss FAILED [ 62%]
[  437s] scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused::scss FAILED [ 63%]
[  439s] scss/tests/files/kronuz/linear-gradient.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient::scss FAILED [ 63%]
[  440s] scss/tests/files/kronuz/lists-circular-nth.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth::scss FAILED [ 64%]
[  440s] scss/tests/files/kronuz/lists-operations.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-operations::scss PASSED [ 64%]
[  442s] scss/tests/files/kronuz/mixin-varargs.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs::scss FAILED [ 64%]
[  444s] scss/tests/files/kronuz/mixins-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context::scss FAILED [ 65%]
[  444s] scss/tests/files/kronuz/mul-em.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-em::scss PASSED [ 65%]
[  444s] scss/tests/files/kronuz/mul-list.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mul-list::scss PASSED [ 66%]
[  444s] scss/tests/files/kronuz/order-test-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-each::scss PASSED [ 66%]
[  444s] scss/tests/files/kronuz/order-test-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test-for::scss PASSED [ 66%]
[  446s] scss/tests/files/kronuz/order-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test::scss FAILED [ 67%]
[  446s] scss/tests/files/kronuz/reversed-for.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-for::scss PASSED [ 67%]
[  447s] scss/tests/files/kronuz/reversed-range.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range::scss FAILED [ 68%]
[  449s] scss/tests/files/kronuz/rgba-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors::scss FAILED [ 68%]
[  451s] scss/tests/files/kronuz/scope-loop-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables::scss FAILED [ 68%]
[  453s] scss/tests/files/kronuz/scoping-control.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control::scss FAILED [ 69%]
[  454s] scss/tests/files/kronuz/selectors-append-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest::scss FAILED [ 69%]
[  456s] scss/tests/files/kronuz/selectors-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest::scss FAILED [ 70%]
[  458s] scss/tests/files/kronuz/selectors-special.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special::scss FAILED [ 70%]
[  460s] scss/tests/files/kronuz/sprite-map.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map::scss FAILED [ 70%]
[  462s] scss/tests/files/kronuz/style-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested::scss FAILED [ 71%]
[  462s] scss/tests/files/kronuz/while-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/while-test::scss PASSED [ 71%]
[  464s] scss/tests/files/original-doctests/000-general.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general::scss FAILED [ 72%]
[  466s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables::scss FAILED [ 72%]
[  468s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children::scss FAILED [ 72%]
[  470s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2::scss FAILED [ 73%]
[  472s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3::scss FAILED [ 73%]
[  472s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends::scss PASSED [ 74%]
[  472s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2::scss PASSED [ 74%]
[  474s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3::scss FAILED [ 75%]
[  476s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4::scss FAILED [ 75%]
[  479s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5::scss FAILED [ 75%]
[  479s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math::scss PASSED [ 76%]
[  479s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2::scss PASSED [ 76%]
[  479s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3::scss PASSED [ 77%]
[  481s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting::scss FAILED [ 77%]
[  483s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2::scss FAILED [ 77%]
[  483s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3::scss PASSED [ 78%]
[  484s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables::scss FAILED [ 78%]
[  486s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation::scss FAILED [ 79%]
[  488s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins::scss FAILED [ 79%]
[  489s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2::scss FAILED [ 79%]
[  492s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3::scss FAILED [ 80%]
[  494s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend::scss FAILED [ 80%]
[  494s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple::scss PASSED [ 81%]
[  496s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2::scss FAILED [ 81%]
[  498s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder::scss FAILED [ 81%]
[  498s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum::scss PASSED [ 82%]
[  499s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2::scss FAILED [ 82%]
[  499s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3::scss PASSED [ 83%]
[  501s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors::scss FAILED [ 83%]
[  503s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2::scss FAILED [ 83%]
[  503s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3::scss PASSED [ 84%]
[  505s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test::scss FAILED [ 84%]
[  507s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2::scss FAILED [ 85%]
[  508s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3::scss FAILED [ 85%]
[  510s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4::scss FAILED [ 85%]
[  512s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5::scss FAILED [ 86%]
[  514s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6::scss FAILED [ 86%]
[  515s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7::scss FAILED [ 87%]
[  517s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8::scss FAILED [ 87%]
[  519s] scss/tests/files/original-doctests/039-hover-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend::scss FAILED [ 87%]
[  519s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4::scss PASSED [ 88%]
[  520s] scss/tests/files/original-doctests/040-complex-sequence-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend::scss FAILED [ 88%]
[  520s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend::scss PASSED [ 89%]
[  522s] scss/tests/files/regressions/args-vars.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars::scss FAILED [ 89%]
[  524s] scss/tests/files/regressions/argspec-default-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments::scss FAILED [ 89%]
[  526s] scss/tests/files/regressions/argspec-no-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments::scss FAILED [ 90%]
[  528s] scss/tests/files/regressions/argspec-trailing-comma.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma::scss FAILED [ 90%]
[  531s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2::scss FAILED [ 91%]
[  534s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation::scss FAILED [ 91%]
[  536s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10::scss FAILED [ 91%]
[  537s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110::scss FAILED [ 92%]
[  538s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2::scss FAILED [ 92%]
[  540s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21::scss FAILED [ 93%]
[  542s] scss/tests/files/regressions/issue-258.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258::scss FAILED [ 93%]
[  542s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32::scss PASSED [ 93%]
[  544s] scss/tests/files/regressions/issue-334-a.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a::scss FAILED [ 94%]
[  546s] scss/tests/files/regressions/issue-334-b.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b::scss FAILED [ 94%]
[  548s] scss/tests/files/regressions/issue-334-c.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c::scss FAILED [ 95%]
[  550s] scss/tests/files/regressions/issue-334-d.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d::scss FAILED [ 95%]
[  552s] scss/tests/files/regressions/issue-334-e.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e::scss FAILED [ 95%]
[  554s] scss/tests/files/regressions/issue-334-f.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f::scss FAILED [ 96%]
[  557s] scss/tests/files/regressions/issue-334-g.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g::scss FAILED [ 96%]
[  559s] scss/tests/files/regressions/issue-334-h.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h::scss FAILED [ 97%]
[  559s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4::scss PASSED [ 97%]
[  560s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40::scss FAILED [ 97%]
[  562s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5::scss FAILED [ 98%]
[  564s] scss/tests/files/regressions/issue-52.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52::scss FAILED [ 98%]
[  566s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6::scss FAILED [ 99%]
[  566s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7::scss PASSED [ 99%]
[  567s] scss/tests/files/regressions/nth-inside-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each::scss FAILED [100%]
[  567s] 
[  567s] =================================== FAILURES ===================================
[  567s] __________________________ test_reference_operations ___________________________
[  567s] 
[  567s]     def test_reference_operations():
[  567s]         """Test the example expressions in the reference document:
[  567s]     
[  567s]         http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#operations
[  567s]         """
[  567s]         # TODO: break this into its own file and add the entire reference guide
[  567s]     
[  567s]         # Need to build the calculator manually to get at its namespace, and need
[  567s]         # to use calculate() instead of evaluate_expression() so interpolation
[  567s]         # works
[  567s]         ns = CoreExtension.namespace.derive()
[  567s]         calc = Calculator(ns).calculate
[  567s]     
[  567s]         # Simple example
[  567s] >       assert calc('1in + 8pt') == Number(1.1111111111111112, "in")
[  567s] 
[  567s] scss/tests/test_expression.py:44: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:166: in parse_expression
[  567s]     parser = SassExpression(SassExpressionScanner(expr))
[  567s] scss/grammar/expression.py:104: in __init__
[  567s]     self.patterns.append((t, re.compile(p)))
[  567s] /usr/lib64/python3.11/re/__init__.py:227: in compile
[  567s]     return _compile(pattern, flags)
[  567s] /usr/lib64/python3.11/re/__init__.py:294: in _compile
[  567s]     p = _compiler.compile(pattern, flags)
[  567s] /usr/lib64/python3.11/re/_compiler.py:743: in compile
[  567s]     p = _parser.parse(p, flags)
[  567s] /usr/lib64/python3.11/re/_parser.py:980: in parse
[  567s]     p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
[  567s] /usr/lib64/python3.11/re/_parser.py:455: in _parse_sub
[  567s]     itemsappend(_parse(source, state, verbose, nested + 1,
[  567s] /usr/lib64/python3.11/re/_parser.py:863: in _parse
[  567s]     p = _parse_sub(source, state, sub_verbose, nested + 1)
[  567s] /usr/lib64/python3.11/re/_parser.py:455: in _parse_sub
[  567s]     itemsappend(_parse(source, state, verbose, nested + 1,
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] source = <re._parser.Tokenizer object at 0x40049f99d0>
[  567s] state = <re._parser.State object at 0x40049f8f10>, verbose = 0, nested = 3
[  567s] first = False
[  567s] 
[  567s]     def _parse(source, state, verbose, nested, first=False):
[  567s]         # parse a simple pattern
[  567s]         subpattern = SubPattern(state)
[  567s]     
[  567s]         # precompute constants into local variables
[  567s]         subpatternappend = subpattern.append
[  567s]         sourceget = source.get
[  567s]         sourcematch = source.match
[  567s]         _len = len
[  567s]         _ord = ord
[  567s]     
[  567s]         while True:
[  567s]     
[  567s]             this = source.next
[  567s]             if this is None:
[  567s]                 break # end of pattern
[  567s]             if this in "|)":
[  567s]                 break # end of subpattern
[  567s]             sourceget()
[  567s]     
[  567s]             if verbose:
[  567s]                 # skip whitespace and comments
[  567s]                 if this in WHITESPACE:
[  567s]                     continue
[  567s]                 if this == "#":
[  567s]                     while True:
[  567s]                         this = sourceget()
[  567s]                         if this is None or this == "\n":
[  567s]                             break
[  567s]                     continue
[  567s]     
[  567s]             if this[0] == "\\":
[  567s]                 code = _escape(source, this, state)
[  567s]                 subpatternappend(code)
[  567s]     
[  567s]             elif this not in SPECIAL_CHARS:
[  567s]                 subpatternappend((LITERAL, _ord(this)))
[  567s]     
[  567s]             elif this == "[":
[  567s]                 here = source.tell() - 1
[  567s]                 # character set
[  567s]                 set = []
[  567s]                 setappend = set.append
[  567s]     ##          if sourcematch(":"):
[  567s]     ##              pass # handle character classes
[  567s]                 if source.next == '[':
[  567s]                     import warnings
[  567s]                     warnings.warn(
[  567s]                         'Possible nested set at position %d' % source.tell(),
[  567s]                         FutureWarning, stacklevel=nested + 6
[  567s]                     )
[  567s]                 negate = sourcematch("^")
[  567s]                 # check remaining characters
[  567s]                 while True:
[  567s]                     this = sourceget()
[  567s]                     if this is None:
[  567s]                         raise source.error("unterminated character set",
[  567s]                                            source.tell() - here)
[  567s]                     if this == "]" and set:
[  567s]                         break
[  567s]                     elif this[0] == "\\":
[  567s]                         code1 = _class_escape(source, this)
[  567s]                     else:
[  567s]                         if set and this in '-&~|' and source.next == this:
[  567s]                             import warnings
[  567s]                             warnings.warn(
[  567s]                                 'Possible set %s at position %d' % (
[  567s]                                     'difference' if this == '-' else
[  567s]                                     'intersection' if this == '&' else
[  567s]                                     'symmetric difference' if this == '~' else
[  567s]                                     'union',
[  567s]                                     source.tell() - 1),
[  567s]                                 FutureWarning, stacklevel=nested + 6
[  567s]                             )
[  567s]                         code1 = LITERAL, _ord(this)
[  567s]                     if sourcematch("-"):
[  567s]                         # potential range
[  567s]                         that = sourceget()
[  567s]                         if that is None:
[  567s]                             raise source.error("unterminated character set",
[  567s]                                                source.tell() - here)
[  567s]                         if that == "]":
[  567s]                             if code1[0] is IN:
[  567s]                                 code1 = code1[1][0]
[  567s]                             setappend(code1)
[  567s]                             setappend((LITERAL, _ord("-")))
[  567s]                             break
[  567s]                         if that[0] == "\\":
[  567s]                             code2 = _class_escape(source, that)
[  567s]                         else:
[  567s]                             if that == '-':
[  567s]                                 import warnings
[  567s]                                 warnings.warn(
[  567s]                                     'Possible set difference at position %d' % (
[  567s]                                         source.tell() - 2),
[  567s]                                     FutureWarning, stacklevel=nested + 6
[  567s]                                 )
[  567s]                             code2 = LITERAL, _ord(that)
[  567s]                         if code1[0] != LITERAL or code2[0] != LITERAL:
[  567s]                             msg = "bad character range %s-%s" % (this, that)
[  567s]                             raise source.error(msg, len(this) + 1 + len(that))
[  567s]                         lo = code1[1]
[  567s]                         hi = code2[1]
[  567s]                         if hi < lo:
[  567s]                             msg = "bad character range %s-%s" % (this, that)
[  567s]                             raise source.error(msg, len(this) + 1 + len(that))
[  567s]                         setappend((RANGE, (lo, hi)))
[  567s]                     else:
[  567s]                         if code1[0] is IN:
[  567s]                             code1 = code1[1][0]
[  567s]                         setappend(code1)
[  567s]     
[  567s]                 set = _uniq(set)
[  567s]                 # XXX: <fl> should move set optimization to compiler!
[  567s]                 if _len(set) == 1 and set[0][0] is LITERAL:
[  567s]                     # optimization
[  567s]                     if negate:
[  567s]                         subpatternappend((NOT_LITERAL, set[0][1]))
[  567s]                     else:
[  567s]                         subpatternappend(set[0])
[  567s]                 else:
[  567s]                     if negate:
[  567s]                         set.insert(0, (NEGATE, None))
[  567s]                     # charmap optimization can't be added here because
[  567s]                     # global flags still are not known
[  567s]                     subpatternappend((IN, set))
[  567s]     
[  567s]             elif this in REPEAT_CHARS:
[  567s]                 # repeat previous item
[  567s]                 here = source.tell()
[  567s]                 if this == "?":
[  567s]                     min, max = 0, 1
[  567s]                 elif this == "*":
[  567s]                     min, max = 0, MAXREPEAT
[  567s]     
[  567s]                 elif this == "+":
[  567s]                     min, max = 1, MAXREPEAT
[  567s]                 elif this == "{":
[  567s]                     if source.next == "}":
[  567s]                         subpatternappend((LITERAL, _ord(this)))
[  567s]                         continue
[  567s]     
[  567s]                     min, max = 0, MAXREPEAT
[  567s]                     lo = hi = ""
[  567s]                     while source.next in DIGITS:
[  567s]                         lo += sourceget()
[  567s]                     if sourcematch(","):
[  567s]                         while source.next in DIGITS:
[  567s]                             hi += sourceget()
[  567s]                     else:
[  567s]                         hi = lo
[  567s]                     if not sourcematch("}"):
[  567s]                         subpatternappend((LITERAL, _ord(this)))
[  567s]                         source.seek(here)
[  567s]                         continue
[  567s]     
[  567s]                     if lo:
[  567s]                         min = int(lo)
[  567s]                         if min >= MAXREPEAT:
[  567s]                             raise OverflowError("the repetition number is too large")
[  567s]                     if hi:
[  567s]                         max = int(hi)
[  567s]                         if max >= MAXREPEAT:
[  567s]                             raise OverflowError("the repetition number is too large")
[  567s]                         if max < min:
[  567s]                             raise source.error("min repeat greater than max repeat",
[  567s]                                                source.tell() - here)
[  567s]                 else:
[  567s]                     raise AssertionError("unsupported quantifier %r" % (char,))
[  567s]                 # figure out which item to repeat
[  567s]                 if subpattern:
[  567s]                     item = subpattern[-1:]
[  567s]                 else:
[  567s]                     item = None
[  567s]                 if not item or item[0][0] is AT:
[  567s]                     raise source.error("nothing to repeat",
[  567s]                                        source.tell() - here + len(this))
[  567s]                 if item[0][0] in _REPEATCODES:
[  567s]                     raise source.error("multiple repeat",
[  567s]                                        source.tell() - here + len(this))
[  567s]                 if item[0][0] is SUBPATTERN:
[  567s]                     group, add_flags, del_flags, p = item[0][1]
[  567s]                     if group is None and not add_flags and not del_flags:
[  567s]                         item = p
[  567s]                 if sourcematch("?"):
[  567s]                     # Non-Greedy Match
[  567s]                     subpattern[-1] = (MIN_REPEAT, (min, max, item))
[  567s]                 elif sourcematch("+"):
[  567s]                     # Possessive Match (Always Greedy)
[  567s]                     subpattern[-1] = (POSSESSIVE_REPEAT, (min, max, item))
[  567s]                 else:
[  567s]                     # Greedy Match
[  567s]                     subpattern[-1] = (MAX_REPEAT, (min, max, item))
[  567s]     
[  567s]             elif this == ".":
[  567s]                 subpatternappend((ANY, None))
[  567s]     
[  567s]             elif this == "(":
[  567s]                 start = source.tell() - 1
[  567s]                 capture = True
[  567s]                 atomic = False
[  567s]                 name = None
[  567s]                 add_flags = 0
[  567s]                 del_flags = 0
[  567s]                 if sourcematch("?"):
[  567s]                     # options
[  567s]                     char = sourceget()
[  567s]                     if char is None:
[  567s]                         raise source.error("unexpected end of pattern")
[  567s]                     if char == "P":
[  567s]                         # python extensions
[  567s]                         if sourcematch("<"):
[  567s]                             # named group: skip forward to end of name
[  567s]                             name = source.getuntil(">", "group name")
[  567s]                             source.checkgroupname(name, 1, nested)
[  567s]                         elif sourcematch("="):
[  567s]                             # named backreference
[  567s]                             name = source.getuntil(")", "group name")
[  567s]                             source.checkgroupname(name, 1, nested)
[  567s]                             gid = state.groupdict.get(name)
[  567s]                             if gid is None:
[  567s]                                 msg = "unknown group name %r" % name
[  567s]                                 raise source.error(msg, len(name) + 1)
[  567s]                             if not state.checkgroup(gid):
[  567s]                                 raise source.error("cannot refer to an open group",
[  567s]                                                    len(name) + 1)
[  567s]                             state.checklookbehindgroup(gid, source)
[  567s]                             subpatternappend((GROUPREF, gid))
[  567s]                             continue
[  567s]     
[  567s]                         else:
[  567s]                             char = sourceget()
[  567s]                             if char is None:
[  567s]                                 raise source.error("unexpected end of pattern")
[  567s]                             raise source.error("unknown extension ?P" + char,
[  567s]                                                len(char) + 2)
[  567s]                     elif char == ":":
[  567s]                         # non-capturing group
[  567s]                         capture = False
[  567s]                     elif char == "#":
[  567s]                         # comment
[  567s]                         while True:
[  567s]                             if source.next is None:
[  567s]                                 raise source.error("missing ), unterminated comment",
[  567s]                                                    source.tell() - start)
[  567s]                             if sourceget() == ")":
[  567s]                                 break
[  567s]                         continue
[  567s]     
[  567s]                     elif char in "=!<":
[  567s]                         # lookahead assertions
[  567s]                         dir = 1
[  567s]                         if char == "<":
[  567s]                             char = sourceget()
[  567s]                             if char is None:
[  567s]                                 raise source.error("unexpected end of pattern")
[  567s]                             if char not in "=!":
[  567s]                                 raise source.error("unknown extension ?<" + char,
[  567s]                                                    len(char) + 2)
[  567s]                             dir = -1 # lookbehind
[  567s]                             lookbehindgroups = state.lookbehindgroups
[  567s]                             if lookbehindgroups is None:
[  567s]                                 state.lookbehindgroups = state.groups
[  567s]                         p = _parse_sub(source, state, verbose, nested + 1)
[  567s]                         if dir < 0:
[  567s]                             if lookbehindgroups is None:
[  567s]                                 state.lookbehindgroups = None
[  567s]                         if not sourcematch(")"):
[  567s]                             raise source.error("missing ), unterminated subpattern",
[  567s]                                                source.tell() - start)
[  567s]                         if char == "=":
[  567s]                             subpatternappend((ASSERT, (dir, p)))
[  567s]                         else:
[  567s]                             subpatternappend((ASSERT_NOT, (dir, p)))
[  567s]                         continue
[  567s]     
[  567s]                     elif char == "(":
[  567s]                         # conditional backreference group
[  567s]                         condname = source.getuntil(")", "group name")
[  567s]                         if condname.isidentifier():
[  567s]                             source.checkgroupname(condname, 1, nested)
[  567s]                             condgroup = state.groupdict.get(condname)
[  567s]                             if condgroup is None:
[  567s]                                 msg = "unknown group name %r" % condname
[  567s]                                 raise source.error(msg, len(condname) + 1)
[  567s]                         else:
[  567s]                             try:
[  567s]                                 condgroup = int(condname)
[  567s]                                 if condgroup < 0:
[  567s]                                     raise ValueError
[  567s]                             except ValueError:
[  567s]                                 msg = "bad character in group name %r" % condname
[  567s]                                 raise source.error(msg, len(condname) + 1) from None
[  567s]                             if not condgroup:
[  567s]                                 raise source.error("bad group number",
[  567s]                                                    len(condname) + 1)
[  567s]                             if condgroup >= MAXGROUPS:
[  567s]                                 msg = "invalid group reference %d" % condgroup
[  567s]                                 raise source.error(msg, len(condname) + 1)
[  567s]                             if condgroup not in state.grouprefpos:
[  567s]                                 state.grouprefpos[condgroup] = (
[  567s]                                     source.tell() - len(condname) - 1
[  567s]                                 )
[  567s]                             if not (condname.isdecimal() and condname.isascii()):
[  567s]                                 import warnings
[  567s]                                 warnings.warn(
[  567s]                                     "bad character in group name %s at position %d" %
[  567s]                                     (repr(condname) if source.istext else ascii(condname),
[  567s]                                      source.tell() - len(condname) - 1),
[  567s]                                     DeprecationWarning, stacklevel=nested + 6
[  567s]                                 )
[  567s]                         state.checklookbehindgroup(condgroup, source)
[  567s]                         item_yes = _parse(source, state, verbose, nested + 1)
[  567s]                         if source.match("|"):
[  567s]                             item_no = _parse(source, state, verbose, nested + 1)
[  567s]                             if source.next == "|":
[  567s]                                 raise source.error("conditional backref with more than two branches")
[  567s]                         else:
[  567s]                             item_no = None
[  567s]                         if not source.match(")"):
[  567s]                             raise source.error("missing ), unterminated subpattern",
[  567s]                                                source.tell() - start)
[  567s]                         subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
[  567s]                         continue
[  567s]     
[  567s]                     elif char == ">":
[  567s]                         # non-capturing, atomic group
[  567s]                         capture = False
[  567s]                         atomic = True
[  567s]                     elif char in FLAGS or char == "-":
[  567s]                         # flags
[  567s]                         flags = _parse_flags(source, state, char)
[  567s]                         if flags is None:  # global flags
[  567s]                             if not first or subpattern:
[  567s] >                               raise source.error('global flags not at the start '
[  567s]                                                    'of the expression',
[  567s]                                                    source.tell() - start)
[  567s] E                               re.error: global flags not at the start of the expression at position 1
[  567s] 
[  567s] /usr/lib64/python3.11/re/_parser.py:841: error
[  567s] ________________________________ test_functions ________________________________
[  567s] 
[  567s] calc = <bound method Calculator.calculate of <scss.calculator.Calculator object at 0x400465b4d0>>
[  567s] 
[  567s]     def test_functions(calc):
[  567s]         calc = Calculator(CoreExtension.namespace).calculate
[  567s]     
[  567s] >       assert calc('grayscale(red)') == Color.from_rgb(0.5, 0.5, 0.5)
[  567s] 
[  567s] scss/tests/test_expression.py:87: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'grayscale(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_parse_strings ______________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x400475d250>>
[  567s] 
[  567s]     def test_parse_strings(calc):
[  567s]         # Escapes in barewords are preserved.
[  567s] >       assert calc('auto\\9') == String.unquoted('auto\\9')
[  567s] 
[  567s] scss/tests/test_expression.py:96: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'auto\\9' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________ test_parse_bang_important ___________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40045c0910>>
[  567s] 
[  567s]     def test_parse_bang_important(calc):
[  567s]         # The !important flag is treated as part of a spaced list.
[  567s] >       assert calc('40px !important') == List([
[  567s]             Number(40, 'px'), String.unquoted('!important'),
[  567s]         ], use_comma=False)
[  567s] 
[  567s] scss/tests/test_expression.py:105: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:236: in not_expr
[  567s]     comparison = self.comparison()
[  567s] scss/grammar/expression.py:244: in comparison
[  567s]     a_expr = self.a_expr()
[  567s] scss/grammar/expression.py:275: in a_expr
[  567s]     m_expr = self.m_expr()
[  567s] scss/grammar/expression.py:292: in m_expr
[  567s]     while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s]   (@0)  NUM  =  '40'
[  567s]   (@2)  UNITS  =  'px'
[  567s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error after '40px ': Found '!important' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________ test_parse_special_functions _________________________
[  567s] 
[  567s]     def test_parse_special_functions():
[  567s]         ns = CoreExtension.namespace.derive()
[  567s]         calc = Calculator(ns).calculate
[  567s]     
[  567s]         # expression() allows absolutely any old garbage inside
[  567s]         # TODO we can't deal with an unmatched { due to the block locator, but ruby
[  567s]         # can
[  567s]         for gnarly_expression in (
[  567s]                 "not ~* remotely *~ valid {syntax}",
[  567s]                 "expression( ( -0 - floater.offsetHeight + ( document"
[  567s]                 ".documentElement.clientHeight ? document.documentElement"
[  567s]                 ".clientHeight : document.body.clientHeight ) + ( ignoreMe"
[  567s]                 " = document.documentElement.scrollTop ? document"
[  567s]                 ".documentElement.scrollTop : document.body.scrollTop ) ) +"
[  567s]                 " 'px' )"):
[  567s]             expr = 'expression(' + gnarly_expression + ')'
[  567s]             assert calc(expr).render() == expr
[  567s]     
[  567s]         # alpha() doubles as a special function if it contains opacity=n, the IE
[  567s]         # filter syntax
[  567s] >       assert calc('alpha(black)') == Number(1)
[  567s] 
[  567s] scss/tests/test_expression.py:140: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:236: in not_expr
[  567s]     comparison = self.comparison()
[  567s] scss/grammar/expression.py:244: in comparison
[  567s]     a_expr = self.a_expr()
[  567s] scss/grammar/expression.py:275: in a_expr
[  567s]     m_expr = self.m_expr()
[  567s] scss/grammar/expression.py:290: in m_expr
[  567s]     u_expr = self.u_expr()
[  567s] scss/grammar/expression.py:319: in u_expr
[  567s]     atom = self.atom()
[  567s] scss/grammar/expression.py:343: in atom
[  567s]     _token_ = self._peek(self.atom_rsts_)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s]   (@0)  ALPHA_FUNCTION  =  'alpha'
[  567s]   (@5)  LPAR  =  '('
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error after 'alpha(': Found 'black)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, OPACITY, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _____________________________ test_super_selector ______________________________
[  567s] 
[  567s]     def test_super_selector():
[  567s]         compiler = Scss(scss_opts=dict(style='expanded'))
[  567s]         input = """\
[  567s]     foo, bar {
[  567s]       a: b;
[  567s]     }
[  567s]     baz {
[  567s]       c: d;
[  567s]     }
[  567s]     """
[  567s]         expected = """\
[  567s]     super foo, super bar {
[  567s]       a: b;
[  567s]     }
[  567s]     
[  567s]     super baz {
[  567s]       c: d;
[  567s]     }
[  567s]     """
[  567s]     
[  567s] >       output = compiler.compile(input, super_selector='super')
[  567s] 
[  567s] scss/tests/test_misc.py:39: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/legacy.py:189: in compile
[  567s]     compiled = compiler.call_and_catch_errors(compilation.run)
[  567s] scss/compiler.py:176: in call_and_catch_errors
[  567s]     return f(*args, **kwargs)
[  567s] scss/compiler.py:296: in run
[  567s]     self.manage_children(rule, scope=None)
[  567s] scss/compiler.py:349: in manage_children
[  567s]     self._manage_children_impl(rule, scope)
[  567s] scss/compiler.py:398: in _manage_children_impl
[  567s]     self._nest_rules(rule, scope, block)
[  567s] scss/compiler.py:1203: in _nest_rules
[  567s]     self.manage_children(new_rule, scope)
[  567s] scss/compiler.py:349: in manage_children
[  567s]     self._manage_children_impl(rule, scope)
[  567s] scss/compiler.py:383: in _manage_children_impl
[  567s]     self._get_properties(rule, scope, block)
[  567s] scss/compiler.py:1090: in _get_properties
[  567s]     value = calculator.calculate(raw_value)
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'b' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_debug_info ________________________________
[  567s] 
[  567s]     def test_debug_info():
[  567s]         # nb: debug info doesn't work if the source isn't a file
[  567s]         compiler = Scss(scss_opts=dict(style='expanded', debug_info=True))
[  567s]         compiler._scss_files = {}
[  567s]         compiler._scss_files['input.css'] = """\
[  567s]     div {
[  567s]         color: green;
[  567s]     }
[  567s]     table {
[  567s]         color: red;
[  567s]     }
[  567s]     """
[  567s]         expected = """\
[  567s]     @media -sass-debug-info{filename{font-family:file\:\/\/input\.css}line{font-family:\\000031}}
[  567s]     div {
[  567s]       color: green;
[  567s]     }
[  567s]     
[  567s]     @media -sass-debug-info{filename{font-family:file\:\/\/input\.css}line{font-family:\\000034}}
[  567s]     table {
[  567s]       color: red;
[  567s]     }
[  567s]     """
[  567s]     
[  567s] >       output = compiler.compile()
[  567s] 
[  567s] scss/tests/test_misc.py:67: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/legacy.py:189: in compile
[  567s]     compiled = compiler.call_and_catch_errors(compilation.run)
[  567s] scss/compiler.py:176: in call_and_catch_errors
[  567s]     return f(*args, **kwargs)
[  567s] scss/compiler.py:296: in run
[  567s]     self.manage_children(rule, scope=None)
[  567s] scss/compiler.py:349: in manage_children
[  567s]     self._manage_children_impl(rule, scope)
[  567s] scss/compiler.py:398: in _manage_children_impl
[  567s]     self._nest_rules(rule, scope, block)
[  567s] scss/compiler.py:1203: in _nest_rules
[  567s]     self.manage_children(new_rule, scope)
[  567s] scss/compiler.py:349: in manage_children
[  567s]     self._manage_children_impl(rule, scope)
[  567s] scss/compiler.py:383: in _manage_children_impl
[  567s]     self._get_properties(rule, scope, block)
[  567s] scss/compiler.py:1090: in _get_properties
[  567s]     value = calculator.calculate(raw_value)
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'green' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_live_errors _______________________________
[  567s] 
[  567s]     def test_live_errors():
[  567s]         compiler = Scss(live_errors=True)
[  567s] >       output = compiler.compile("""$foo: unitless(one);""")
[  567s] 
[  567s] scss/tests/test_misc.py:73: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/legacy.py:189: in compile
[  567s]     compiled = compiler.call_and_catch_errors(compilation.run)
[  567s] scss/compiler.py:176: in call_and_catch_errors
[  567s]     return f(*args, **kwargs)
[  567s] scss/compiler.py:296: in run
[  567s]     self.manage_children(rule, scope=None)
[  567s] scss/compiler.py:349: in manage_children
[  567s]     self._manage_children_impl(rule, scope)
[  567s] scss/compiler.py:383: in _manage_children_impl
[  567s]     self._get_properties(rule, scope, block)
[  567s] scss/compiler.py:1081: in _get_properties
[  567s]     value = calculator.calculate(raw_value, divide=True)
[  567s] scss/calculator.py:116: in calculate
[  567s]     result = self.evaluate_expression(expression, divide=divide)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'unitless(o' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_rgb ___________________________________
[  567s] 
[  567s]     def test_rgb():
[  567s] >       assert calc('rgb(128, 192, 224)') == Color.from_rgb(128/255, 192/255, 224/255)
[  567s] 
[  567s] scss/tests/extension/test_core.py:33: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'rgb(128, 1' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_rgba ___________________________________
[  567s] 
[  567s]     def test_rgba():
[  567s]         # four args (css-style)
[  567s] >       assert calc('rgba(128, 192, 224, 0.5)') == Color.from_rgb(128/255, 192/255, 224/255, 0.5)
[  567s] 
[  567s] scss/tests/extension/test_core.py:39: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'rgba(128, ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_red ___________________________________
[  567s] 
[  567s]     def test_red():
[  567s] >       assert calc('red(orange)') == Number(255)
[  567s] 
[  567s] scss/tests/extension/test_core.py:47: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red(orange' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_green __________________________________
[  567s] 
[  567s]     def test_green():
[  567s] >       assert calc('green(orange)') == Number(165)
[  567s] 
[  567s] scss/tests/extension/test_core.py:51: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'green(oran' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_blue ___________________________________
[  567s] 
[  567s]     def test_blue():
[  567s] >       assert calc('blue(orange)') == Number(0)
[  567s] 
[  567s] scss/tests/extension/test_core.py:55: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue(orang' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_mix ___________________________________
[  567s] 
[  567s]     def test_mix():
[  567s]         # Examples from the Ruby docs
[  567s]         # Note that the results have been adjusted slightly; Ruby floors the mixed
[  567s]         # channels, but we round
[  567s] >       assert calc('mix(#f00, #00f)') == calc('#800080')
[  567s] 
[  567s] scss/tests/extension/test_core.py:62: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'mix(#f00, ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_hsl ___________________________________
[  567s] 
[  567s]     def test_hsl():
[  567s]         # Examples from the CSS 3 color spec, which Sass uses
[  567s]         # (http://www.w3.org/TR/css3-color/#hsl-color)
[  567s] >       assert calc('hsl(0, 100%, 50%)') == Color.from_rgb(1., 0., 0.)
[  567s] 
[  567s] scss/tests/extension/test_core.py:73: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'hsl(0, 100' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_hsla ___________________________________
[  567s] 
[  567s]     def test_hsla():
[  567s]         # Examples from the CSS 3 color spec
[  567s] >       assert calc('hsla(120, 100%, 50%, 1)') == Color.from_rgb(0., 1., 0.,)
[  567s] 
[  567s] scss/tests/extension/test_core.py:82: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'hsla(120, ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_hue ___________________________________
[  567s] 
[  567s]     def test_hue():
[  567s] >       assert calc('hue(yellow)') == Number(60, unit='deg')
[  567s] 
[  567s] scss/tests/extension/test_core.py:88: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'hue(yellow' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_saturation ________________________________
[  567s] 
[  567s]     def test_saturation():
[  567s] >       assert calc('saturation(yellow)') == Number(100, unit='%')
[  567s] 
[  567s] scss/tests/extension/test_core.py:92: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'saturation' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_lightness ________________________________
[  567s] 
[  567s]     def test_lightness():
[  567s] >       assert calc('lightness(yellow)') == Number(50, unit='%')
[  567s] 
[  567s] scss/tests/extension/test_core.py:96: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'lightness(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_adjust_hue ________________________________
[  567s] 
[  567s]     def test_adjust_hue():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('adjust-hue(hsl(120, 30%, 90%), 60deg)') == calc('hsl(180, 30%, 90%)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:103: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'adjust-hue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_lighten _________________________________
[  567s] 
[  567s]     def test_lighten():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('lighten(hsl(0, 0%, 0%), 30%)') == calc('hsl(0, 0, 30)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:110: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'lighten(hs' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_darken __________________________________
[  567s] 
[  567s]     def test_darken():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('darken(hsl(25, 100%, 80%), 30%)') == calc('hsl(25, 100%, 50%)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:116: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'darken(hsl' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_saturate _________________________________
[  567s] 
[  567s]     def test_saturate():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('saturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 50%, 90%)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:122: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'saturate(h' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_desaturate ________________________________
[  567s] 
[  567s]     def test_desaturate():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('desaturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 10%, 90%)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:128: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'desaturate' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_grayscale ________________________________
[  567s] 
[  567s]     def test_grayscale():
[  567s] >       assert calc('grayscale(black)') == Color.from_rgb(0., 0., 0.)
[  567s] 
[  567s] scss/tests/extension/test_core.py:133: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'grayscale(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________ test_grayscale_css_filter ___________________________
[  567s] 
[  567s]     def test_grayscale_css_filter():
[  567s]         # grayscale(number) is a CSS filter and should be left alone
[  567s] >       assert calc('grayscale(1)') == String("grayscale(1)")
[  567s] 
[  567s] scss/tests/extension/test_core.py:140: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'grayscale(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_complement ________________________________
[  567s] 
[  567s]     def test_complement():
[  567s] >       assert calc('complement(black)') == Color.from_rgb(0., 0., 0.)
[  567s] 
[  567s] scss/tests/extension/test_core.py:144: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'complement' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_invert __________________________________
[  567s] 
[  567s]     def test_invert():
[  567s] >       assert calc('invert(black)') == Color.from_rgb(1., 1., 1.)
[  567s] 
[  567s] scss/tests/extension/test_core.py:150: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'invert(bla' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ____________________________ test_invert_css_filter ____________________________
[  567s] 
[  567s]     def test_invert_css_filter():
[  567s]         # invert(number) is a CSS filter and should be left alone
[  567s] >       assert calc('invert(50%)') == String("invert(50%)")
[  567s] 
[  567s] scss/tests/extension/test_core.py:157: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'invert(50%' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_alpha_opacity ______________________________
[  567s] 
[  567s]     def test_alpha_opacity():
[  567s] >       assert calc('alpha(black)') == Number(1.)
[  567s] 
[  567s] scss/tests/extension/test_core.py:164: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:236: in not_expr
[  567s]     comparison = self.comparison()
[  567s] scss/grammar/expression.py:244: in comparison
[  567s]     a_expr = self.a_expr()
[  567s] scss/grammar/expression.py:275: in a_expr
[  567s]     m_expr = self.m_expr()
[  567s] scss/grammar/expression.py:290: in m_expr
[  567s]     u_expr = self.u_expr()
[  567s] scss/grammar/expression.py:319: in u_expr
[  567s]     atom = self.atom()
[  567s] scss/grammar/expression.py:343: in atom
[  567s]     _token_ = self._peek(self.atom_rsts_)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s]   (@0)  ALPHA_FUNCTION  =  'alpha'
[  567s]   (@5)  LPAR  =  '('
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error after 'alpha(': Found 'black)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, OPACITY, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _____________________________ test_alpha_ie_filter _____________________________
[  567s] 
[  567s]     def test_alpha_ie_filter():
[  567s]         # alpha() is supposed to leave the IE filter syntax alone
[  567s] >       assert render('alpha(opacity=20)') == "alpha(opacity=20)"
[  567s] 
[  567s] scss/tests/extension/test_core.py:176: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:22: in render
[  567s]     return calc(expression).render()
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:236: in not_expr
[  567s]     comparison = self.comparison()
[  567s] scss/grammar/expression.py:244: in comparison
[  567s]     a_expr = self.a_expr()
[  567s] scss/grammar/expression.py:275: in a_expr
[  567s]     m_expr = self.m_expr()
[  567s] scss/grammar/expression.py:290: in m_expr
[  567s]     u_expr = self.u_expr()
[  567s] scss/grammar/expression.py:319: in u_expr
[  567s]     atom = self.atom()
[  567s] scss/grammar/expression.py:343: in atom
[  567s]     _token_ = self._peek(self.atom_rsts_)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s]   (@0)  ALPHA_FUNCTION  =  'alpha'
[  567s]   (@5)  LPAR  =  '('
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error after 'alpha(': Found 'opacity=20' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, OPACITY, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _____________________________ test_opacify_fadein ______________________________
[  567s] 
[  567s]     def test_opacify_fadein():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('opacify(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.6)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:181: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'opacify(rg' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________ test_transparentize_fadeout __________________________
[  567s] 
[  567s]     def test_transparentize_fadeout():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('transparentize(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.4)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:191: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'transparen' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_adjust_color _______________________________
[  567s] 
[  567s]     def test_adjust_color():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('adjust-color(#102030, $blue: 5)') == calc('#102035')
[  567s] 
[  567s] scss/tests/extension/test_core.py:204: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'adjust-col' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_scale_color _______________________________
[  567s] 
[  567s]     def test_scale_color():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('scale-color(hsl(120, 70, 80), $lightness: 50%)') == calc('hsl(120, 70, 90)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:211: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'scale-colo' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_change_color _______________________________
[  567s] 
[  567s]     def test_change_color():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('change-color(#102030, $blue: 5)') == calc('#102005')
[  567s] 
[  567s] scss/tests/extension/test_core.py:218: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'change-col' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_ie_hex_str ________________________________
[  567s] 
[  567s]     def test_ie_hex_str():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('ie-hex-str(#abc)') == calc('"#FFAABBCC"')
[  567s] 
[  567s] scss/tests/extension/test_core.py:227: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'ie-hex-str' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_unquote _________________________________
[  567s] 
[  567s]     def test_unquote():
[  567s]         # Examples from the Ruby docs
[  567s] >       ret = calc('unquote("foo")')
[  567s] 
[  567s] scss/tests/extension/test_core.py:237: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'unquote("f' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_quote __________________________________
[  567s] 
[  567s]     def test_quote():
[  567s]         # Examples from the Ruby docs
[  567s] >       ret = calc('quote("foo")')
[  567s] 
[  567s] scss/tests/extension/test_core.py:249: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'quote("foo' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_str_length ________________________________
[  567s] 
[  567s]     def test_str_length():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('str-length("foo")') == calc('3')
[  567s] 
[  567s] scss/tests/extension/test_core.py:260: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'str-length' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_str_insert ________________________________
[  567s] 
[  567s]     def test_str_insert():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('str-insert("abcd", "X", 1)') == calc('"Xabcd"')
[  567s] 
[  567s] scss/tests/extension/test_core.py:265: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'str-insert' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_str_index ________________________________
[  567s] 
[  567s]     def test_str_index():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('str-index(abcd, a)') == calc('1')
[  567s] 
[  567s] scss/tests/extension/test_core.py:273: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'str-index(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_str_slice ________________________________
[  567s] 
[  567s]     def test_str_slice():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('str-slice("abcd", 2, 3)') == calc('"bc"')
[  567s] 
[  567s] scss/tests/extension/test_core.py:281: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'str-slice(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_to_upper_case ______________________________
[  567s] 
[  567s]     def test_to_upper_case():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('to-upper-case(abcd)') == calc('ABCD')
[  567s] 
[  567s] scss/tests/extension/test_core.py:292: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'to-upper-c' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________________ test_to_lower_case ______________________________
[  567s] 
[  567s]     def test_to_lower_case():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('to-lower-case(ABCD)') == calc('abcd')
[  567s] 
[  567s] scss/tests/extension/test_core.py:297: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'to-lower-c' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_percentage ________________________________
[  567s] 
[  567s]     def test_percentage():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('percentage(100px / 50px)') == calc('200%')
[  567s] 
[  567s] scss/tests/extension/test_core.py:305: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'percentage' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_round __________________________________
[  567s] 
[  567s]     def test_round():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('round(10.4px)') == calc('10px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:310: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'round(10.4' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_ceil ___________________________________
[  567s] 
[  567s]     def test_ceil():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('ceil(10.4px)') == calc('11px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:316: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'ceil(10.4p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_floor __________________________________
[  567s] 
[  567s]     def test_floor():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('floor(10.4px)') == calc('10px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:322: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'floor(10.4' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_abs ___________________________________
[  567s] 
[  567s]     def test_abs():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('abs(10px)') == calc('10px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:328: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'abs(10px)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_min ___________________________________
[  567s] 
[  567s]     def test_min():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('min(1px, 4px)') == calc('1px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:334: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'min(1px, 4' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_max ___________________________________
[  567s] 
[  567s]     def test_max():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('max(1px, 4px)') == calc('4px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:340: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'max(1px, 4' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_length __________________________________
[  567s] 
[  567s]     def test_length():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('length(10px)') == calc('1')
[  567s] 
[  567s] scss/tests/extension/test_core.py:349: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'length(10p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_nth ___________________________________
[  567s] 
[  567s]     def test_nth():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('nth(10px 20px 30px, 1)') == calc('10px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:355: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'nth(10px 2' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_join ___________________________________
[  567s] 
[  567s]     def test_join():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert_equivalent('join(10px 20px, 30px 40px)', '10px 20px 30px 40px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:364: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:26: in assert_equivalent
[  567s]     assert render(actual) == render(expected)
[  567s] scss/tests/extension/test_core.py:22: in render
[  567s]     return calc(expression).render()
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'join(10px ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_append __________________________________
[  567s] 
[  567s]     def test_append():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('append(10px 20px, 30px)') == calc('10px 20px 30px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:373: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'append(10p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_zip ___________________________________
[  567s] 
[  567s]     def test_zip():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('zip(1px 1px 3px, solid dashed solid, red green blue)') == calc('1px solid red, 1px dashed green, 3px solid blue')
[  567s] 
[  567s] scss/tests/extension/test_core.py:385: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'zip(1px 1p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_index __________________________________
[  567s] 
[  567s]     def test_index():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('index(1px solid red, solid)') == calc('2')
[  567s] 
[  567s] scss/tests/extension/test_core.py:390: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'index(1px ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _____________________________ test_list_separator ______________________________
[  567s] 
[  567s]     def test_list_separator():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('list-separator(1px 2px 3px)') == calc('space')
[  567s] 
[  567s] scss/tests/extension/test_core.py:396: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'list-separ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_set_nth _________________________________
[  567s] 
[  567s]     def test_set_nth():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('set-nth($list: 10px 20px 30px, $n: 2, $value: -20px)') == calc('10px -20px 30px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:403: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'set-nth($l' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_map_get _________________________________
[  567s] 
[  567s]     def test_map_get():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('map-get(("foo": 1, "bar": 2), "foo")') == calc('1')
[  567s] 
[  567s] scss/tests/extension/test_core.py:412: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'map-get(("' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_map_merge ________________________________
[  567s] 
[  567s]     def test_map_merge():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('map-merge(("foo": 1), ("bar": 2))') == calc('("foo": 1, "bar": 2)')
[  567s] 
[  567s] scss/tests/extension/test_core.py:419: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'map-merge(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_map_keys _________________________________
[  567s] 
[  567s]     def test_map_keys():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('map-keys(("foo": 1, "bar": 2))') == calc('"foo", "bar"')
[  567s] 
[  567s] scss/tests/extension/test_core.py:425: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'map-keys((' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_map_values ________________________________
[  567s] 
[  567s]     def test_map_values():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('map-values(("foo": 1, "bar": 2))') == calc('1, 2')
[  567s] 
[  567s] scss/tests/extension/test_core.py:430: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'map-values' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_map_has_key _______________________________
[  567s] 
[  567s]     def test_map_has_key():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('map-has-key(("foo": 1, "bar": 2), "foo")') == calc('true')
[  567s] 
[  567s] scss/tests/extension/test_core.py:436: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'map-has-ke' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_type_of _________________________________
[  567s] 
[  567s]     def test_type_of():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('type-of(100px)') == calc('number')
[  567s] 
[  567s] scss/tests/extension/test_core.py:445: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'type-of(10' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_unit ___________________________________
[  567s] 
[  567s]     def test_unit():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('unit(100)') == calc('""')
[  567s] 
[  567s] scss/tests/extension/test_core.py:455: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'unit(100)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_unitless _________________________________
[  567s] 
[  567s]     def test_unitless():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('unitless(100)') == calc('true')
[  567s] 
[  567s] scss/tests/extension/test_core.py:466: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'unitless(1' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_comparable ________________________________
[  567s] 
[  567s]     def test_comparable():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('comparable(2px, 1px)') == calc('true')
[  567s] 
[  567s] scss/tests/extension/test_core.py:472: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'comparable' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_if ____________________________________
[  567s] 
[  567s]     def test_if():
[  567s]         # Examples from the Ruby docs
[  567s] >       assert calc('if(true, 1px, 2px)') == calc('1px')
[  567s] 
[  567s] scss/tests/extension/test_core.py:482: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/tests/extension/test_core.py:18: in calc
[  567s]     return Calculator(CoreExtension.namespace).evaluate_expression(expression)
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'if(true, 1' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_blank __________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004ac4ed0>>
[  567s] 
[  567s]     def test_blank(calc):
[  567s] >       assert calc('blank(false)')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:36: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blank(fals' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_compact _________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004627950>>
[  567s] 
[  567s]     def test_compact(calc):
[  567s] >       assert calc('compact(1 2 3 false 4 5 null 6 7)') == calc('1 2 3 4 5 6 7')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:49: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'compact(1 ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _________________________________ test_reject __________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40045de4d0>>
[  567s] 
[  567s]     def test_reject(calc):
[  567s] >       assert calc('reject(a b c d, a, c)') == calc('b d')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:53: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'reject(a b' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _____________________________ test_first_value_of ______________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004b58850>>
[  567s] 
[  567s]     def test_first_value_of(calc):
[  567s] >       assert calc('first-value-of(a b c d)') == calc('a')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:58: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'first-valu' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_enumerate ________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40045e97d0>>
[  567s] 
[  567s]     def test_enumerate(calc):
[  567s] >       assert calc('enumerate(foo, 4, 7)') == calc('foo-4, foo-5, foo-6, foo-7')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:84: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'enumerate(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_headings _________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40044480d0>>
[  567s] 
[  567s]     def test_headings(calc):
[  567s] >       assert calc('headings()') == calc('h1, h2, h3, h4, h5, h6')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:89: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'headings()' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_nest ___________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004ab0fd0>>
[  567s] 
[  567s]     def test_nest(calc):
[  567s]         # Using .render() here because the structure is complicated and only the
[  567s]         # output matters
[  567s] >       assert calc('nest(selector1, selector2, selector3)').render() == 'selector1 selector2 selector3'
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:98: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'nest(selec' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ____________________________ test_opposite_position ____________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40046819d0>>
[  567s] 
[  567s]     def test_opposite_position(calc):
[  567s] >       assert calc('opposite-position(left)') == calc('right')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:111: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'opposite-p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_pi ____________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004610cd0>>
[  567s] 
[  567s]     def test_pi(calc):
[  567s] >       assert calc('pi()') == calc('3.141592653589793')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:121: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'pi()' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ____________________________________ test_e ____________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40049b53d0>>
[  567s] 
[  567s]     def test_e(calc):
[  567s] >       assert calc('e()') == calc('2.718281828459045')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:125: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'e()' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] __________________________________ test_sqrt ___________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004625ad0>>
[  567s] 
[  567s]     def test_sqrt(calc):
[  567s] >       assert calc('sqrt(9)') == calc('3')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:129: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'sqrt(9)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_log ___________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40046aab50>>
[  567s] 
[  567s]     def test_log(calc):
[  567s] >       assert calc('log(9, 3)') == calc('2')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:133: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'log(9, 3)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ___________________________________ test_pow ___________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004ba5210>>
[  567s] 
[  567s]     def test_pow(calc):
[  567s] >       assert calc('pow(3, 2)') == calc('9')
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:137: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'pow(3, 2)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_font_url _________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004b18b90>>
[  567s] 
[  567s]     def test_font_url(calc):
[  567s]         # nb: config.FONTS_URL is None and defaults to this
[  567s]         fonts_url = config.STATIC_URL
[  567s] >       assert calc('font-url("/some_path.woff")').render() == 'url({0}some_path.woff)'.format(fonts_url)
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:153: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'font-url("' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] _______________________________ test_font_files ________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004b67fd0>>
[  567s] 
[  567s]     def test_font_files(calc):
[  567s]         """
[  567s]         @author: funvit
[  567s]         @note: adapted from  compass / test / units / sass_extensions_test.rb
[  567s]         """
[  567s]         # nb: config.FONTS_URL is None and defaults to this
[  567s]         fonts_url = config.STATIC_URL
[  567s] >       assert '' == calc('font-files()').render()
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:165: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'font-files' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ____________________________ test_inline_font_files ____________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x40048a2210>>
[  567s] monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x40048a0fd0>
[  567s] 
[  567s]     def test_inline_font_files(calc, monkeypatch):
[  567s]         """
[  567s]         @author: funvit
[  567s]         @note: adapted from  compass / test / units / sass_extensions_test.rb
[  567s]         """
[  567s]         monkeypatch.setattr(config, 'FONTS_ROOT', os.path.join(config.PROJECT_ROOT, 'tests/files/fonts'))
[  567s]     
[  567s]         with open(os.path.join(config.PROJECT_ROOT, 'tests/files/fonts/bgrove.base64.txt'), 'r') as f:
[  567s]             font_base64 = ''.join((f.readlines()))
[  567s]     
[  567s] >       assert 'url(data:font/truetype;base64,%s) format("truetype")' % font_base64 == calc('inline_font_files("/bgrove.ttf", truetype)').render()
[  567s] 
[  567s] scss/tests/extension/compass/test_helpers.py:188: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'inline_fon' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ________________________________ test_image_url ________________________________
[  567s] 
[  567s] calc = <bound method Calculator.evaluate_expression of <scss.calculator.Calculator object at 0x4004b92c90>>
[  567s] 
[  567s]     def test_image_url(calc):
[  567s]         # nb: config.IMAGES_URL is None and defaults to this
[  567s]         images_url = config.STATIC_URL
[  567s] >       assert calc('image-url("/some_path.jpg")').render() == 'url({0}some_path.jpg)'.format(images_url)
[  567s] 
[  567s] scss/tests/extension/compass/test_images.py:36: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] scss/calculator.py:134: in evaluate_expression
[  567s]     ast = self.parse_expression(expr)
[  567s] scss/calculator.py:167: in parse_expression
[  567s]     ast = getattr(parser, target)()
[  567s] scss/grammar/expression.py:110: in goal
[  567s]     expr_lst = self.expr_lst()
[  567s] scss/grammar/expression.py:199: in expr_lst
[  567s]     expr_slst = self.expr_slst()
[  567s] scss/grammar/expression.py:208: in expr_slst
[  567s]     or_expr = self.or_expr()
[  567s] scss/grammar/expression.py:216: in or_expr
[  567s]     and_expr = self.and_expr()
[  567s] scss/grammar/expression.py:225: in and_expr
[  567s]     not_expr = self.not_expr()
[  567s] scss/grammar/expression.py:234: in not_expr
[  567s]     _token_ = self._peek(self.argspec_item_chks)
[  567s] scss/grammar/scanner.py:141: in _peek
[  567s]     tok = self._scanner.token(self._pos, types)
[  567s] scss/grammar/scanner.py:270: in token
[  567s]     tokens_len += self._scan(restrict)
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = 
[  567s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  567s] 
[  567s]     def _scan(self, restrict):
[  567s]         """
[  567s]         Should scan another token and add it to the list, self.tokens,
[  567s]         and add the restriction to self.restrictions
[  567s]         """
[  567s]         # Keep looking for a token, ignoring any in self.ignore
[  567s]         if DEBUG:
[  567s]             print()
[  567s]             print("Being asked to match with restriction:", repr(restrict))
[  567s]         token = None
[  567s]         while True:
[  567s]             best_pat = None
[  567s]             # Search the patterns for a match, with earlier
[  567s]             # tokens in the list having preference
[  567s]             best_pat_len = 0
[  567s]             for tok, regex in self.patterns:
[  567s]                 if DEBUG:
[  567s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  567s]                 # First check to see if we're restricting to this token
[  567s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  567s]                     if DEBUG:
[  567s]                         print("\tSkipping %r!" % (tok,))
[  567s]                     continue
[  567s]                 m = regex.match(self.input, self.pos)
[  567s]                 if m:
[  567s]                     # We got a match
[  567s]                     best_pat = tok
[  567s]                     best_pat_len = len(m.group(0))
[  567s]                     if DEBUG:
[  567s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  567s]                     break
[  567s]     
[  567s]             # If we didn't find anything, raise an error
[  567s]             if best_pat is None:
[  567s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  567s] E               scss.errors.SassSyntaxError: Syntax error: Found 'image-url(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  567s] 
[  567s] scss/grammar/scanner.py:236: SassSyntaxError
[  567s] ______________________ scss/tests/files/bugs/append.scss _______________________
[  567s] 
[  567s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append.scss>
[  567s] 
[  567s]     def runtest(self):
[  567s]         scss_file = Path(str(self.fspath))
[  567s]         css_file = scss_file.with_suffix('.css')
[  567s]     
[  567s]         with css_file.open('rb') as fh:
[  567s]             # Output is Unicode, so decode this here
[  567s]             expected = fh.read().decode('utf8')
[  567s]     
[  567s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  567s]     
[  567s]         search_path = []
[  567s]         include = scss_file.parent / 'include'
[  567s]         if include.exists():
[  567s]             search_path.append(include)
[  567s]         search_path.append(scss_file.parent)
[  567s]     
[  567s]         try:
[  567s] >           actual = compile_file(
[  567s]                 scss_file,
[  567s]                 output_style='expanded',
[  567s]                 search_path=search_path,
[  567s]                 extensions=[
[  567s]                     CoreExtension,
[  567s]                     ExtraExtension,
[  567s]                     FontsExtension,
[  567s]                     CompassExtension,
[  567s]                 ],
[  567s]             )
[  567s] 
[  567s] conftest.py:127: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append.scss')
[  567s] compiler_class = <class 'scss.compiler.Compiler'>
[  567s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  567s] compiler = <scss.compiler.Compiler object at 0x4004666090>
[  567s] 
[  567s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  567s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  567s]         a string of CSS.
[  567s]     
[  567s]         Keyword arguments are passed along to the underlying `Compiler`.
[  567s]     
[  567s]         Note that the search path is set to the file's containing directory by
[  567s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  567s]     
[  567s]         :param filename: Path to the file to compile.
[  567s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  567s]         """
[  567s]         filename = Path(filename)
[  567s]         if 'search_path' not in kwargs:
[  567s]             kwargs['search_path'] = [filename.parent.resolve()]
[  567s]     
[  567s]         compiler = compiler_class(**kwargs)
[  567s] >       return compiler.compile(filename)
[  567s] 
[  567s] scss/compiler.py:237: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compiler object at 0x4004666090>
[  567s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append.scss'),)
[  567s] compilation = <scss.compiler.Compilation object at 0x40046661d0>
[  567s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append.scss')
[  567s] source = <SourceFile PosixPath('append.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  567s] 
[  567s]     def compile(self, *filenames):
[  567s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  567s]         # get something out besides just the output, you have to copy this
[  567s]         # method.  that sucks.
[  567s]         # TODO i think the right thing is to get all the constructors out of
[  567s]         # SourceFile, since it's really the compiler that knows the import
[  567s]         # paths and should be consulted about this.  reconsider all this (but
[  567s]         # preserve it for now, SIGH) once importers are a thing
[  567s]         compilation = self.make_compilation()
[  567s]         for filename in filenames:
[  567s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  567s]             # instead Compilation should have methods for add_string etc. that
[  567s]             # can call normalize_path.
[  567s]             # TODO it's not possible to inject custom files into the
[  567s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  567s]             # imports.  do we want the former?  is the latter better suited to
[  567s]             # an extension?
[  567s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  567s]             compilation.add_source(source)
[  567s] >       return self.call_and_catch_errors(compilation.run)
[  567s] 
[  567s] scss/compiler.py:203: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compiler object at 0x4004666090>
[  567s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40046661d0>>
[  567s] args = (), kwargs = {}
[  567s] 
[  567s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  567s]         """Call the given function with the given arguments.  If it succeeds,
[  567s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  567s]         and `live_errors` is turned on, return CSS containing a traceback and
[  567s]         error message.
[  567s]         """
[  567s]         try:
[  567s] >           return f(*args, **kwargs)
[  567s] 
[  567s] scss/compiler.py:176: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compilation object at 0x40046661d0>
[  567s] 
[  567s]     def run(self):
[  567s]         # Any @import will add the source file to self.sources and infect this
[  567s]         # list, so make a quick copy to insulate against that
[  567s]         # TODO maybe @import should just not do that?
[  567s]         for source_file in list(self.sources):
[  567s]             rule = SassRule(
[  567s]                 source_file=source_file,
[  567s]                 lineno=1,
[  567s]     
[  567s]                 unparsed_contents=source_file.contents,
[  567s]                 namespace=self.root_namespace,
[  567s]             )
[  567s]             self.rules.append(rule)
[  567s] >           self.manage_children(rule, scope=None)
[  567s] 
[  567s] scss/compiler.py:296: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compilation object at 0x40046661d0>
[  567s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  567s] 
[  567s]     def manage_children(self, rule, scope):
[  567s]         try:
[  567s] >           self._manage_children_impl(rule, scope)
[  567s] 
[  567s] scss/compiler.py:349: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compilation object at 0x40046661d0>
[  567s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  567s] 
[  567s]     def _manage_children_impl(self, rule, scope):
[  567s]         calculator = self._make_calculator(rule.namespace)
[  567s]     
[  567s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  567s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  567s]     
[  567s]             ####################################################################
[  567s]             # At (@) blocks
[  567s]             if block.is_atrule:
[  567s]                 # TODO particularly wild idea: allow extensions to handle
[  567s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  567s]                 # core?  even move the core stuff into the core extension?
[  567s]                 code = block.directive
[  567s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  567s]                 try:
[  567s]                     method = getattr(self, code)
[  567s]                 except AttributeError:
[  567s]                     if block.unparsed_contents is None:
[  567s]                         rule.properties.append((block.prop, None))
[  567s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  567s]                         self._nest_at_rules(rule, scope, block)
[  567s]                 else:
[  567s]                     method(calculator, rule, scope, block)
[  567s]     
[  567s]             ####################################################################
[  567s]             # Properties
[  567s]             elif block.unparsed_contents is None:
[  567s] >               self._get_properties(rule, scope, block)
[  567s] 
[  567s] scss/compiler.py:383: 
[  567s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  567s] 
[  567s] self = <scss.compiler.Compilation object at 0x40046661d0>
[  567s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  567s] block = <scss.rule.UnparsedBlock object at 0x4004666550>
[  567s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004665ad0>
[  568s] expression = 'append((), 1)', divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004665ad0>
[  568s] expr = 'append((), 1)', divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004665ad0>
[  568s] expr = 'append((), 1)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004667310>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'append((),' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/bugs/argspec-named-arguments.scss ______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004ad19d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004ad19d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments.scss')
[  568s] source = <SourceFile PosixPath('argspec-named-arguments.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004ad19d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004ad0c50>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004ad1710>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004ad0c50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004a1d910>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a1fa90>
[  568s] expression = 'calculate($foo: 3)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a1fa90>
[  568s] expr = 'calculate($foo: 3)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a1fa90>
[  568s] expr = 'calculate($foo: 3)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a1c490>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'calculate(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _____________ scss/tests/files/bugs/argspec-slurpy-arguments.scss ______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40049b6150>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40049b6150>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments.scss')
[  568s] source = <SourceFile PosixPath('argspec-slurpy-arguments.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40049b6150>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40049b49d0>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40049b5ad0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.shadows'>,)>,)>, 1 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.shadows'>,)>,)>, 1 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049b49d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.shadows'>,)>,)>, 1 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004997d10>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4003d99d90>
[  568s] expression = 'reduce(1em, 2em, 3em, 4em)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4003d99d90>
[  568s] expr = 'reduce(1em, 2em, 3em, 4em)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4003d99d90>
[  568s] expr = 'reduce(1em, 2em, 3em, 4em)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40049b4950>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'reduce(1em' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ____________________ scss/tests/files/bugs/at-rules-1.scss _____________________
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s] >                   method = getattr(self, code)
[  568s] E                   AttributeError: 'Compilation' object has no attribute '_at_-moz-keyframes'
[  568s] 
[  568s] scss/compiler.py:371: AttributeError
[  568s] 
[  568s] During handling of the above exception, another exception occurred:
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40048503d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40048503d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004850350>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1.scss')
[  568s] source = <SourceFile PosixPath('at-rules-1.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40048503d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004850350>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >                       self._nest_at_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:376: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004850050>
[  568s] 
[  568s]     def _nest_at_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements @-blocks
[  568s]         """
[  568s]         # TODO handle @charset, probably?
[  568s]         # Interpolate the current block
[  568s]         # TODO this seems like it should be done in the block header.  and more
[  568s]         # generally?
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         if block.header.argument:
[  568s]             # TODO is this correct?  do ALL at-rules ALWAYS allow both vars and
[  568s]             # interpolation?
[  568s]             node = calculator.parse_vars_and_interpolations(
[  568s]                 block.header.argument)
[  568s]             block.header.argument = node.evaluate(calculator).render()
[  568s]     
[  568s]         # TODO merge into RuleAncestry
[  568s]         new_ancestry = list(rule.ancestry.headers)
[  568s]         if block.directive == '@media' and new_ancestry:
[  568s]             for i, header in reversed(list(enumerate(new_ancestry))):
[  568s]                 if header.is_selector:
[  568s]                     continue
[  568s]                 elif header.directive == '@media':
[  568s]                     new_ancestry[i] = BlockAtRuleHeader(
[  568s]                         '@media',
[  568s]                         "%s and %s" % (header.argument, block.argument))
[  568s]                     break
[  568s]                 else:
[  568s]                     new_ancestry.insert(i, block.header)
[  568s]             else:
[  568s]                 new_ancestry.insert(0, block.header)
[  568s]         else:
[  568s]             new_ancestry.append(block.header)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             #extends_selectors
[  568s]             ancestry=RuleAncestry(new_ancestry),
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1161: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004850cd0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>, <BlockSelectorHeader (<Selector: 'from'>,)>)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>, <BlockSelectorHeader (<Selector: 'from'>,)>)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004850350>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@-moz-keyframes' 'spinnerRotate,\n@-webkit-keyframes spinnerRotate,\n@keyframes spinnerRotate'>, <BlockSelectorHeader (<Selector: 'from'>,)>)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004851fd0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004851b90>
[  568s] expression = 'rotate(0deg)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004851b90>
[  568s] expr = 'rotate(0deg)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004851b90>
[  568s] expr = 'rotate(0deg)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004851390>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'rotate(0de' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ___________ scss/tests/files/bugs/at-rules-compressed-semicolon.scss ___________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x400455ae10>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400455ae10>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon.scss')
[  568s] source = <SourceFile PosixPath('at-rules-compressed-semicolon.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400455ae10>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004558f10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry ()>, 1 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry ()>, 1 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry ()>, 1 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400455b610>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004558f10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004559150>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400455add0>, expression = 'c'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400455add0>, expr = 'c'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400455add0>, expr = 'c'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400455a490>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'c' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/bugs/at-rules-interpolation.scss _______________
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s] >                   method = getattr(self, code)
[  568s] E                   AttributeError: 'Compilation' object has no attribute '_at_media'
[  568s] 
[  568s] scss/compiler.py:371: AttributeError
[  568s] 
[  568s] During handling of the above exception, another exception occurred:
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4003da7950>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4003da7950>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation.scss')
[  568s] source = <SourceFile PosixPath('at-rules-interpolation.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4003da7950>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004951a90>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >                       self._nest_at_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:376: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40049518d0>
[  568s] 
[  568s]     def _nest_at_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements @-blocks
[  568s]         """
[  568s]         # TODO handle @charset, probably?
[  568s]         # Interpolate the current block
[  568s]         # TODO this seems like it should be done in the block header.  and more
[  568s]         # generally?
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         if block.header.argument:
[  568s]             # TODO is this correct?  do ALL at-rules ALWAYS allow both vars and
[  568s]             # interpolation?
[  568s]             node = calculator.parse_vars_and_interpolations(
[  568s]                 block.header.argument)
[  568s]             block.header.argument = node.evaluate(calculator).render()
[  568s]     
[  568s]         # TODO merge into RuleAncestry
[  568s]         new_ancestry = list(rule.ancestry.headers)
[  568s]         if block.directive == '@media' and new_ancestry:
[  568s]             for i, header in reversed(list(enumerate(new_ancestry))):
[  568s]                 if header.is_selector:
[  568s]                     continue
[  568s]                 elif header.directive == '@media':
[  568s]                     new_ancestry[i] = BlockAtRuleHeader(
[  568s]                         '@media',
[  568s]                         "%s and %s" % (header.argument, block.argument))
[  568s]                     break
[  568s]                 else:
[  568s]                     new_ancestry.insert(i, block.header)
[  568s]             else:
[  568s]                 new_ancestry.insert(0, block.header)
[  568s]         else:
[  568s]             new_ancestry.append(block.header)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             #extends_selectors
[  568s]             ancestry=RuleAncestry(new_ancestry),
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1161: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40049502d0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>, <BlockSelectorHeader (<Selector: 'div'>,)>)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>, <BlockSelectorHeader (<Selector: 'div'>,)>)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004951a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' '(max-width: 900px)'>, <BlockSelectorHeader (<Selector: 'div'>,)>)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400476e190>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400476ef50>, expression = 'red'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400476ef50>, expr = 'red'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400476ef50>, expr = 'red'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400476e710>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _____________________ scss/tests/files/bugs/base64url.scss _____________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004b49d50>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b49d50>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url.scss')
[  568s] source = <SourceFile PosixPath('base64url.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b49d50>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b48e50>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b48c10>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.logo'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.logo'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b48e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.logo'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40046c1dd0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046c2910>
[  568s] expression = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC)'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046c2910>
[  568s] expr = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC)'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046c2910>
[  568s] expr = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046c13d0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'url(data:i' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/colors-preserve-names.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004682e90>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004682e90>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names.scss')
[  568s] source = <SourceFile PosixPath('colors-preserve-names.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004682e90>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004682e50>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004680150>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'table'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'table'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004682e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'table'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004b13390>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b11e90>, expression = 'black'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b11e90>, expr = 'black'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b11e90>, expr = 'black'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b11a10>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'black' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/extend-child-selector.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004916710>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004916710>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector.scss')
[  568s] source = <SourceFile PosixPath('extend-child-selector.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004916710>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004916e50>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004916cd0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.child'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.child'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004916e50>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.child'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004916890>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004915950>
[  568s] expression = 'yellow', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004915950>, expr = 'yellow'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004915950>, expr = 'yellow'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004917050>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'yellow' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ___________ scss/tests/files/bugs/extend-common-prefix-complex.scss ____________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004677690>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004677690>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004675690>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex.scss')
[  568s] source = <SourceFile PosixPath('extend-common-prefix-complex.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004677690>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004675690>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004676710>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#one #two #three a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#one #two #three a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675690>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#one #two #three a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40047b4690>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047b5390>, expression = 'value'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047b5390>, expr = 'value'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047b5390>, expr = 'value'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047b4550>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'value' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/extend-selector-order.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004709010>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004709010>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order.scss')
[  568s] source = <SourceFile PosixPath('extend-selector-order.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004709010>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004709a90>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40047098d0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004b18210>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills > li'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills > li'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004709a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.nav-pills > li'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004b1a7d0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b18110>, expression = 'left'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b18110>, expr = 'left'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b18110>, expr = 'left'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b1b950>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'left' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ________________ scss/tests/files/bugs/if-with-parentheses.scss ________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004663890>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004663890>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses.scss')
[  568s] source = <SourceFile PosixPath('if-with-parentheses.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004663890>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004660b10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004ae2ad0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004660b10>
[  568s] calculator = <scss.calculator.Calculator object at 0x4004ae3950>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ae2f90>
[  568s] 
[  568s]     def _at_if(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @if and @else if
[  568s]         """
[  568s]         # "@if" indicates whether any kind of `if` since the last `@else` has
[  568s]         # succeeded, in which case `@else if` should be skipped
[  568s]         if block.directive != '@if':
[  568s]             if '@if' not in rule.options:
[  568s]                 raise SyntaxError("@else with no @if (%s)" % (rule.file_and_line,))
[  568s]             if rule.options['@if']:
[  568s]                 # Last @if succeeded; stop here
[  568s]                 return
[  568s]     
[  568s] >       condition = calculator.calculate(block.argument)
[  568s] 
[  568s] scss/compiler.py:886: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004ae3950>
[  568s] expression = '(true)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004ae3950>, expr = '(true)'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004ae3950>, expr = '(true)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ae2910>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(': Found 'true)' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/interpolation-timing.scss ________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004674c90>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004674c90>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004675350>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing.scss')
[  568s] source = <SourceFile PosixPath('interpolation-timing.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004674c90>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004675350>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400488aa50>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004675350>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004889310>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004888a50>, expression = 'value'
[  568s] divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004888a50>, expr = 'value'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004888a50>, expr = 'value'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400488a5d0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'value' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _________________ scss/tests/files/bugs/names-equivalence.scss _________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x400475dc10>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400475dc10>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence.scss')
[  568s] source = <SourceFile PosixPath('names-equivalence.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400475dc10>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a62d10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004a61990>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a62d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400485cb90>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400485fa10>
[  568s] expression = 'add-numbers(5em)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400485fa10>
[  568s] expr = 'add-numbers(5em)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400485fa10>
[  568s] expr = 'add-numbers(5em)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400485f710>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'add-number' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/trailing-combinators.scss ________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40045a5b10>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40045a5b10>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators.scss')
[  568s] source = <SourceFile PosixPath('trailing-combinators.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40045a5b10>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40045a6510>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40045a7110>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40048f7010>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~ p'>, <Selector: 'div ~ blockquote'>)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~ p'>, <Selector: 'div ~ blockquote'>)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045a6510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div ~ p'>, <Selector: 'div ~ blockquote'>)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40048f61d0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40048f5b10>, expression = 'blue'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40048f5b10>, expr = 'blue'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40048f5b10>, expr = 'blue'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40048f6e90>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/bugs/unit-float-precision.scss ________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40046e93d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046e93d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision.scss')
[  568s] source = <SourceFile PosixPath('unit-float-precision.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046e93d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40046e8d10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400463ef10>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046e8d10>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400463ef50>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463fc50>
[  568s] expression = 'floor(742px - 40px)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463fc50>
[  568s] expr = 'floor(742px - 40px)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463fc50>
[  568s] expr = 'floor(742px - 40px)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463f890>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'floor(742p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ____________ scss/tests/files/bugs/variables-font-face-default.scss ____________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...utput_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004550c50>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004550c50>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004551b50>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default.scss')
[  568s] source = <SourceFile PosixPath('variables-font-face-default.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004550c50>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004551b50>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004551b50>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004551b50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004551b50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004551b50>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400482f550>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400482e550>
[  568s] expression = '"Helvetica Neue", Arial, Helvetica, sans-serif', divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400482e550>
[  568s] expr = '"Helvetica Neue", Arial, Helvetica, sans-serif', divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400482e550>
[  568s] expr = '"Helvetica Neue", Arial, Helvetica, sans-serif', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def expr_lst(self):
[  568s]         expr_slst = self.expr_slst()
[  568s]         v = [expr_slst]
[  568s]         while self._peek(self.expr_lst_rsts) == '","':
[  568s]             self._scan('","')
[  568s] >           expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400482de10>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  DOUBLE_QUOTE  =  '"'
[  568s]   (@1)  DOUBLE_STRING_GUTS  =  'Helvetica Neue'
[  568s]   (@15)  DOUBLE_QUOTE  =  '"'
[  568s]   (@16)  ","  =  ','
[  568s] i = 4
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  DOUBLE_QUOTE  =  '"'
[  568s]   (@1)  DOUBLE_STRING_GUTS  =  'Helvetica Neue'
[  568s]   (@15)  DOUBLE_QUOTE  =  '"'
[  568s]   (@16)  ","  =  ','
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '"Helvetica Neue", ': Found 'Arial, Hel' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _________________ scss/tests/files/compass/current-color.scss __________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...ut_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004b2bad0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b2bad0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color.scss')
[  568s] source = <SourceFile PosixPath('current-color.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b2bad0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b28450>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004ac7a50>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b28450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004595750>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004595610>
[  568s] expression = 'linear-gradient(to top, transparent, currentColor)'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004595610>
[  568s] expr = 'linear-gradient(to top, transparent, currentColor)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004595610>
[  568s] expr = 'linear-gradient(to top, transparent, currentColor)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045976d0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'linear-gra' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ___________________ scss/tests/files/compass/gradients.scss ____________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...ut_style': 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004aee010>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004aee010>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients.scss')
[  568s] source = <SourceFile PosixPath('gradients.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004aee010>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004aed050>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004aef910>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bg-shortcut-linear-gradient'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bg-shortcut-linear-gradient'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004aed050>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bg-shortcut-linear-gradient'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004aecc10>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004aefb10>
[  568s] expression = '#fff linear-gradient(top left, #ddd, #aaa)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004aefb10>
[  568s] expr = '#fff linear-gradient(top left, #ddd, #aaa)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004aefb10>
[  568s] expr = '#fff linear-gradient(top left, #ddd, #aaa)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] 
[  568s]     def m_expr(self):
[  568s]         u_expr = self.u_expr()
[  568s]         v = u_expr
[  568s] >       while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  568s] 
[  568s] scss/grammar/expression.py:292: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004aedf50>
[  568s] types = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  COLOR  =  '#fff', i = 1
[  568s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  COLOR  =  '#fff'
[  568s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '#fff ': Found 'linear-gra' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _________________ scss/tests/files/general/000-smoketest.scss __________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40045c2f90>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40045c2f90>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest.scss')
[  568s] source = <SourceFile PosixPath('000-smoketest.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40045c2f90>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40045c3110>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] calculator = <scss.calculator.Calculator object at 0x40045c0450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400484ef10>
[  568s] 
[  568s]     def _at_import(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @import
[  568s]         Load and import mixins and functions and rules
[  568s]         """
[  568s]         # TODO it would be neat to opt into warning that you're using
[  568s]         # values/functions from a file you didn't explicitly import
[  568s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  568s]         # to be @imported into a nested block
[  568s]         # TODO i'm not sure we disallow them nested in the first place
[  568s]         # TODO @import is disallowed within mixins, control directives
[  568s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  568s]         # lot of our directives
[  568s]     
[  568s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  568s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  568s]         # -- in a string it's literal!)
[  568s]     
[  568s]         sass_paths = calculator.evaluate_expression(block.argument)
[  568s]         css_imports = []
[  568s]     
[  568s]         for sass_path in sass_paths:
[  568s]             # These are the rules for when an @import is interpreted as a CSS
[  568s]             # import:
[  568s]             if (
[  568s]                     # If it's a url()
[  568s]                     isinstance(sass_path, Url) or
[  568s]                     # If it's not a string (including `"foo" screen`, a List)
[  568s]                     not isinstance(sass_path, String) or
[  568s]                     # If the filename begins with an http protocol
[  568s]                     sass_path.value.startswith(('http://', 'https://')) or
[  568s]                     # If the filename ends with .css
[  568s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  568s]                 css_imports.append(sass_path.render(compress=False))
[  568s]                 continue
[  568s]     
[  568s]             # Should be left with a plain String
[  568s]             name = sass_path.value
[  568s]     
[  568s]             source = None
[  568s]             for extension in self.compiler.extensions:
[  568s]                 source = extension.handle_import(name, self, rule)
[  568s]                 if source:
[  568s]                     break
[  568s]             else:
[  568s]                 # Didn't find anything!
[  568s]                 raise SassImportError(name, self.compiler, rule=rule)
[  568s]     
[  568s]             source = self.add_source(source)
[  568s]     
[  568s]             if rule.namespace.has_import(source):
[  568s]                 # If already imported in this scope, skip
[  568s]                 # TODO this might not be right -- consider if you @import a
[  568s]                 # file at top level, then @import it inside a selector block!
[  568s]                 continue
[  568s]     
[  568s]             _rule = SassRule(
[  568s]                 source_file=source,
[  568s]                 lineno=block.lineno,
[  568s]                 unparsed_contents=source.contents,
[  568s]     
[  568s]                 # rule
[  568s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  568s]                 options=rule.options,
[  568s]                 properties=rule.properties,
[  568s]                 extends_selectors=rule.extends_selectors,
[  568s]                 ancestry=rule.ancestry,
[  568s]                 namespace=rule.namespace,
[  568s]             )
[  568s]             rule.namespace.add_import(source, rule)
[  568s] >           self.manage_children(_rule, scope)
[  568s] 
[  568s] scss/compiler.py:861: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004661fd0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40045c3110>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004663d50>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049509d0>, expression = 'gold'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049509d0>, expr = 'gold'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049509d0>, expr = 'gold'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004951cd0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'gold' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/general/each-destructuring-2.scss ______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004b2a650>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b2a650>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2.scss')
[  568s] source = <SourceFile PosixPath('each-destructuring-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b2a650>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b2b3d0>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x400463da10>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b2b3d0>
[  568s] calculator = <scss.calculator.Calculator object at 0x400463e290>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004364390>
[  568s] 
[  568s]     def _at_each(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @each
[  568s]         """
[  568s]         varstring, _, valuestring = block.argument.partition(' in ')
[  568s] >       values = calculator.calculate(valuestring)
[  568s] 
[  568s] scss/compiler.py:960: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463e290>
[  568s] expression = '(foo: 1px, bar: 2px, baz: 3px)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463e290>
[  568s] expr = '(foo: 1px, bar: 2px, baz: 3px)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400463e290>
[  568s] expr = '(foo: 1px, bar: 2px, baz: 3px)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400463ff10>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(': Found 'foo: 1px, ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/general/each-destructuring-3.scss ______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004b12dd0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b12dd0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004b12c10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3.scss')
[  568s] source = <SourceFile PosixPath('each-destructuring-3.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b12dd0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b12c10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b12c10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b12c10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b12c10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b12c10>
[  568s] calculator = <scss.calculator.Calculator object at 0x4004b105d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b117d0>
[  568s] 
[  568s]     def _at_each(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @each
[  568s]         """
[  568s]         varstring, _, valuestring = block.argument.partition(' in ')
[  568s] >       values = calculator.calculate(valuestring)
[  568s] 
[  568s] scss/compiler.py:960: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b105d0>
[  568s] expression = '(puma, black, default),\n(sea-slug, blue, pointer),\n(egret, white, move)'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b105d0>
[  568s] expr = '(puma, black, default),\n(sea-slug, blue, pointer),\n(egret, white, move)'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b105d0>
[  568s] expr = '(puma, black, default),\n(sea-slug, blue, pointer),\n(egret, white, move)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b12550>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(': Found 'puma, blac' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/general/each-destructuring.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004897390>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004897390>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004896d10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring.scss')
[  568s] source = <SourceFile PosixPath('each-destructuring.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004897390>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004896d10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004896d10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004896d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004896d10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004896d10>
[  568s] calculator = <scss.calculator.Calculator object at 0x4004a41350>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004a41d50>
[  568s] 
[  568s]     def _at_each(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @each
[  568s]         """
[  568s]         varstring, _, valuestring = block.argument.partition(' in ')
[  568s] >       values = calculator.calculate(valuestring)
[  568s] 
[  568s] scss/compiler.py:960: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a41350>
[  568s] expression = '(h1: 2em, h2: 1.5em, h3: 1.2em)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a41350>
[  568s] expr = '(h1: 2em, h2: 1.5em, h3: 1.2em)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004a41350>
[  568s] expr = '(h1: 2em, h2: 1.5em, h3: 1.2em)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004a410d0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(': Found 'h1: 2em, h' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/general/empty-list-included.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004a34710>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004a34710>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004a35c10>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included.scss')
[  568s] source = <SourceFile PosixPath('empty-list-included.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004a34710>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a35c10>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a35c10>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a35c10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a35c10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004a35c10>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b5add0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b58550>
[  568s] expression = 'pass-through(p)', divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b58550>
[  568s] expr = 'pass-through(p)', divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b58550>
[  568s] expr = 'pass-through(p)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b5ac90>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'pass-throu' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _____________ scss/tests/files/general/global-variable-exists.scss _____________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004b11110>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b11110>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists.scss')
[  568s] source = <SourceFile PosixPath('global-variable-exists.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004b11110>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b10250>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] calculator = <scss.calculator.Calculator object at 0x4004b10dd0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b12710>
[  568s] 
[  568s]     def _at_include(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @include, for @mixins
[  568s]         """
[  568s]         caller_namespace = rule.namespace
[  568s]         caller_calculator = self._make_calculator(caller_namespace)
[  568s]         funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  568s]     
[  568s]         # Render the passed arguments, using the caller's namespace
[  568s]         args, kwargs = caller_argspec.evaluate_call_args(caller_calculator)
[  568s]     
[  568s]         argc = len(args) + len(kwargs)
[  568s]         try:
[  568s]             mixin = caller_namespace.mixin(funct, argc)
[  568s]         except KeyError:
[  568s]             try:
[  568s]                 # TODO maybe? don't do this, once '...' works
[  568s]                 # Fallback to single parameter:
[  568s]                 mixin = caller_namespace.mixin(funct, 1)
[  568s]             except KeyError:
[  568s]                 log.error("Mixin not found: %s:%d (%s)", funct, argc, rule.file_and_line, extra={'stack': True})
[  568s]                 return
[  568s]             else:
[  568s]                 args = [List(args, use_comma=True)]
[  568s]                 # TODO what happens to kwargs?
[  568s]     
[  568s]         source_file = mixin[0]
[  568s]         lineno = mixin[1]
[  568s]         m_codestr = mixin[2]
[  568s]         pristine_callee_namespace = mixin[3]
[  568s]         callee_argspec = mixin[4]
[  568s]         if caller_argspec.inject and callee_argspec.inject:
[  568s]             # DEVIATION: Pass the ENTIRE local namespace to the mixin (yikes)
[  568s]             callee_namespace = Namespace.derive_from(
[  568s]                 caller_namespace,
[  568s]                 pristine_callee_namespace)
[  568s]         else:
[  568s]             callee_namespace = pristine_callee_namespace.derive()
[  568s]     
[  568s]         self._populate_namespace_from_call(
[  568s]             "Mixin {0}".format(funct),
[  568s]             callee_namespace, mixin, args, kwargs)
[  568s]     
[  568s]         _rule = SassRule(
[  568s]             # These must be file and line in which the @include occurs
[  568s]             source_file=rule.source_file,
[  568s]             lineno=rule.lineno,
[  568s]     
[  568s]             # These must be file and line in which the @mixin was defined
[  568s]             from_source_file=source_file,
[  568s]             from_lineno=lineno,
[  568s]     
[  568s]             unparsed_contents=m_codestr,
[  568s]             namespace=callee_namespace,
[  568s]     
[  568s]             # rule
[  568s]             import_key=rule.import_key,
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options,
[  568s]             properties=rule.properties,
[  568s]             extends_selectors=rule.extends_selectors,
[  568s]             ancestry=rule.ancestry,
[  568s]             nested=rule.nested,
[  568s]         )
[  568s]     
[  568s]         _rule.options['@content'] = block.unparsed_contents
[  568s] >       self.manage_children(_rule, scope)
[  568s] 
[  568s] scss/compiler.py:778: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b12b90>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'blockquote'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'blockquote'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004b10250>
[  568s] calculator = <scss.calculator.Calculator object at 0x400457e1d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'blockquote'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400457ec90>
[  568s] 
[  568s]     def _at_if(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @if and @else if
[  568s]         """
[  568s]         # "@if" indicates whether any kind of `if` since the last `@else` has
[  568s]         # succeeded, in which case `@else if` should be skipped
[  568s]         if block.directive != '@if':
[  568s]             if '@if' not in rule.options:
[  568s]                 raise SyntaxError("@else with no @if (%s)" % (rule.file_and_line,))
[  568s]             if rule.options['@if']:
[  568s]                 # Last @if succeeded; stop here
[  568s]                 return
[  568s]     
[  568s] >       condition = calculator.calculate(block.argument)
[  568s] 
[  568s] scss/compiler.py:886: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400457e1d0>
[  568s] expression = 'global-variable-exists(blockquote-color)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400457e1d0>
[  568s] expr = 'global-variable-exists(blockquote-color)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x400457e1d0>
[  568s] expr = 'global-variable-exists(blockquote-color)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x400457d5d0>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'global-var' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ____________________ scss/tests/files/general/if-lazy.scss _____________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40047d44d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40047d44d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy.scss')
[  568s] source = <SourceFile PosixPath('if-lazy.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40047d44d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40047d7450>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40047d7e10>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40047d7450>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40047d7410>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047d67d0>
[  568s] expression = 'if(false, $bogus, red)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047d67d0>
[  568s] expr = 'if(false, $bogus, red)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40047d67d0>
[  568s] expr = 'if(false, $bogus, red)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40047d6f10>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'if(false, ' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/general/interpolation-acid.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40049f2a10>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40049f2a10>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40049f3990>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid.scss')
[  568s] source = <SourceFile PosixPath('interpolation-acid.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40049f2a10>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40049f3990>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049f3990>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049f3990>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049f3990>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40049f3990>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40049f3710>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c93490>, expression = 'foo'
[  568s] divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c93490>, expr = 'foo'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c93490>, expr = 'foo'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c93410>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'foo' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ____________ scss/tests/files/general/interpolation-mixin-name.scss ____________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40046a9050>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046a9050>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name.scss')
[  568s] source = <SourceFile PosixPath('interpolation-mixin-name.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046a9050>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40046a97d0>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40046aa910>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] calculator = <scss.calculator.Calculator object at 0x40046aa510>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4003da0990>
[  568s] 
[  568s]     def _at_include(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @include, for @mixins
[  568s]         """
[  568s]         caller_namespace = rule.namespace
[  568s]         caller_calculator = self._make_calculator(caller_namespace)
[  568s]         funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  568s]     
[  568s]         # Render the passed arguments, using the caller's namespace
[  568s]         args, kwargs = caller_argspec.evaluate_call_args(caller_calculator)
[  568s]     
[  568s]         argc = len(args) + len(kwargs)
[  568s]         try:
[  568s]             mixin = caller_namespace.mixin(funct, argc)
[  568s]         except KeyError:
[  568s]             try:
[  568s]                 # TODO maybe? don't do this, once '...' works
[  568s]                 # Fallback to single parameter:
[  568s]                 mixin = caller_namespace.mixin(funct, 1)
[  568s]             except KeyError:
[  568s]                 log.error("Mixin not found: %s:%d (%s)", funct, argc, rule.file_and_line, extra={'stack': True})
[  568s]                 return
[  568s]             else:
[  568s]                 args = [List(args, use_comma=True)]
[  568s]                 # TODO what happens to kwargs?
[  568s]     
[  568s]         source_file = mixin[0]
[  568s]         lineno = mixin[1]
[  568s]         m_codestr = mixin[2]
[  568s]         pristine_callee_namespace = mixin[3]
[  568s]         callee_argspec = mixin[4]
[  568s]         if caller_argspec.inject and callee_argspec.inject:
[  568s]             # DEVIATION: Pass the ENTIRE local namespace to the mixin (yikes)
[  568s]             callee_namespace = Namespace.derive_from(
[  568s]                 caller_namespace,
[  568s]                 pristine_callee_namespace)
[  568s]         else:
[  568s]             callee_namespace = pristine_callee_namespace.derive()
[  568s]     
[  568s]         self._populate_namespace_from_call(
[  568s]             "Mixin {0}".format(funct),
[  568s]             callee_namespace, mixin, args, kwargs)
[  568s]     
[  568s]         _rule = SassRule(
[  568s]             # These must be file and line in which the @include occurs
[  568s]             source_file=rule.source_file,
[  568s]             lineno=rule.lineno,
[  568s]     
[  568s]             # These must be file and line in which the @mixin was defined
[  568s]             from_source_file=source_file,
[  568s]             from_lineno=lineno,
[  568s]     
[  568s]             unparsed_contents=m_codestr,
[  568s]             namespace=callee_namespace,
[  568s]     
[  568s]             # rule
[  568s]             import_key=rule.import_key,
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options,
[  568s]             properties=rule.properties,
[  568s]             extends_selectors=rule.extends_selectors,
[  568s]             ancestry=rule.ancestry,
[  568s]             nested=rule.nested,
[  568s]         )
[  568s]     
[  568s]         _rule.options['@content'] = block.unparsed_contents
[  568s] >       self.manage_children(_rule, scope)
[  568s] 
[  568s] scss/compiler.py:778: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40045c09d0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40045a4c50>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2 li'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2 li'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046a97d0>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p ul.l2 li'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40045a7c90>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40045a7e50>, expression = 'red'
[  568s] divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40045a7e50>, expr = 'red'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40045a7e50>, expr = 'red'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40045a7710>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/general/maps-complex-keys.scss ________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x400484da90>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400484da90>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x400484c790>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys.scss')
[  568s] source = <SourceFile PosixPath('maps-complex-keys.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400484da90>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400484c790>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400484c790>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400484c790>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400484c790>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400484c790>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004b2a950>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b2ae50>
[  568s] expression = '(\ncontainer: auto,\nmath: static fluid,\noutput: isolate float,\ncontainer-position: left center right,\nflow: ltr r...nest,\nclear: break nobreak,\ndebug image: show hide show-columns show-baseline,\ndebug output: background overlay,\n)'
[  568s] divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b2ae50>
[  568s] expr = '(\ncontainer: auto,\nmath: static fluid,\noutput: isolate float,\ncontainer-position: left center right,\nflow: ltr r...nest,\nclear: break nobreak,\ndebug image: show hide show-columns show-baseline,\ndebug output: background overlay,\n)'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004b2ae50>
[  568s] expr = '(\ncontainer: auto,\nmath: static fluid,\noutput: isolate float,\ncontainer-position: left center right,\nflow: ltr r...nest,\nclear: break nobreak,\ndebug image: show hide show-columns show-baseline,\ndebug output: background overlay,\n)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004ac6b10>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(\n': Found 'container:' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _______________ scss/tests/files/general/maps-example-lists.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x400492e4d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400492e4d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x400492d550>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists.scss')
[  568s] source = <SourceFile PosixPath('maps-example-lists.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x400492e4d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400492d550>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400492d550>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400492d550>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400492d550>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x400492d550>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004a36b90>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046e8390>
[  568s] expression = '(\nmist (\nheader #DCFAC0,\ntext   #00968B,\nborder #85C79C\n),\nspring (\nheader #F4FAC7,\ntext   #C2454E,\nborder #FFB158\n)\n\n)'
[  568s] divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046e8390>
[  568s] expr = '(\nmist (\nheader #DCFAC0,\ntext   #00968B,\nborder #85C79C\n),\nspring (\nheader #F4FAC7,\ntext   #C2454E,\nborder #FFB158\n)\n\n)'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40046e8390>
[  568s] expr = '(\nmist (\nheader #DCFAC0,\ntext   #00968B,\nborder #85C79C\n),\nspring (\nheader #F4FAC7,\ntext   #C2454E,\nborder #FFB158\n)\n\n)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x40046ea890>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(\n': Found 'mist (\nhea' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] __________________ scss/tests/files/general/maps-example.scss __________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004c94810>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004c94810>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004c949d0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example.scss')
[  568s] source = <SourceFile PosixPath('maps-example.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004c94810>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c949d0>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c949d0>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c949d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c949d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c949d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004c956d0>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c954d0>
[  568s] expression = '(\nmist: (\nheader: #DCFAC0,\ntext:   #00968B,\nborder: #85C79C\n),\nspring: (\nheader: #F4FAC7,\ntext:   #C2454E,\nborder: #FFB158\n),\n\n)'
[  568s] divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c954d0>
[  568s] expr = '(\nmist: (\nheader: #DCFAC0,\ntext:   #00968B,\nborder: #85C79C\n),\nspring: (\nheader: #F4FAC7,\ntext:   #C2454E,\nborder: #FFB158\n),\n\n)'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c954d0>
[  568s] expr = '(\nmist: (\nheader: #DCFAC0,\ntext:   #00968B,\nborder: #85C79C\n),\nspring: (\nheader: #F4FAC7,\ntext:   #C2454E,\nborder: #FFB158\n),\n\n)'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s] >           _token_ = self._peek(self.atom_rsts)
[  568s] 
[  568s] scss/grammar/expression.py:326: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c95590>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '(', i = 1
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(\n': Found 'mist: (\nhe' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ______________ scss/tests/files/general/names-loop-variable.scss _______________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x40046df550>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046df550>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x40046df210>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable.scss')
[  568s] source = <SourceFile PosixPath('names-loop-variable.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x40046df550>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40046df210>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x40049f1cd0>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s] >                   method(calculator, rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:378: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x40046df210>
[  568s] calculator = <scss.calculator.Calculator object at 0x40049f1710>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40049f1f90>
[  568s] 
[  568s]     def _at_each(self, calculator, rule, scope, block):
[  568s]         """
[  568s]         Implements @each
[  568s]         """
[  568s]         varstring, _, valuestring = block.argument.partition(' in ')
[  568s] >       values = calculator.calculate(valuestring)
[  568s] 
[  568s] scss/compiler.py:960: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049f1710>
[  568s] expression = 'red, blue', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049f1710>, expr = 'red, blue'
[  568s] divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x40049f1710>, expr = 'red, blue'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004b64350>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red, blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] __________________ scss/tests/files/general/null-values.scss ___________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004c949d0>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004c949d0>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values.scss')
[  568s] source = <SourceFile PosixPath('null-values.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004c949d0>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c94a90>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s]                 self._get_properties(rule, scope, block)
[  568s]     
[  568s]             # Nested properties
[  568s]             elif block.is_scope:
[  568s]                 if block.header.unscoped_value:
[  568s]                     # Possibly deal with default unscoped value
[  568s]                     self._get_properties(rule, scope, block)
[  568s]     
[  568s]                 rule.unparsed_contents = block.unparsed_contents
[  568s]                 subscope = (scope or '') + block.header.scope + '-'
[  568s]                 self.manage_children(rule, subscope)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Nested rules
[  568s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s] >               self._nest_rules(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:398: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004c95890>
[  568s] 
[  568s]     def _nest_rules(self, rule, scope, block):
[  568s]         """
[  568s]         Implements Nested CSS rules
[  568s]         """
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         raw_selectors = calculator.do_glob_math(block.prop)
[  568s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  568s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  568s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  568s]         if c_parents:
[  568s]             warn_deprecated(
[  568s]                 rule,
[  568s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  568s]                 "Use 'a { @extend b; }' instead."
[  568s]             )
[  568s]     
[  568s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  568s]     
[  568s]         rule.descendants += 1
[  568s]         new_rule = SassRule(
[  568s]             source_file=rule.source_file,
[  568s]             import_key=rule.import_key,
[  568s]             lineno=block.lineno,
[  568s]             num_header_lines=block.header.num_lines,
[  568s]             unparsed_contents=block.unparsed_contents,
[  568s]     
[  568s]             legacy_compiler_options=rule.legacy_compiler_options,
[  568s]             options=rule.options.copy(),
[  568s]             #properties
[  568s]             extends_selectors=c_parents,
[  568s]             ancestry=new_ancestry,
[  568s]     
[  568s]             namespace=rule.namespace.derive(),
[  568s]             nested=rule.nested + 1,
[  568s]         )
[  568s]         self.rules.append(new_rule)
[  568s]         rule.namespace.use_import(rule.source_file)
[  568s] >       self.manage_children(new_rule, scope)
[  568s] 
[  568s] scss/compiler.py:1203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004c94a90>
[  568s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  568s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c95210>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s]                 value = calculator.calculate(raw_value, divide=True)
[  568s]                 rule.namespace.set_variable(
[  568s]                     _prop, value, local_only=not is_global)
[  568s]         else:
[  568s]             # Regular property destined for output
[  568s]             _prop = calculator.apply_vars(_prop)
[  568s]             if raw_value is None:
[  568s]                 value = None
[  568s]             else:
[  568s] >               value = calculator.calculate(raw_value)
[  568s] 
[  568s] scss/compiler.py:1090: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c951d0>
[  568s] expression = '(1, null, 2, null, 3)', divide = False
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c951d0>
[  568s] expr = '(1, null, 2, null, 3)', divide = False
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004c951d0>
[  568s] expr = '(1, null, 2, null, 3)', target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def not_expr(self):
[  568s]         _token_ = self._peek(self.argspec_item_chks)
[  568s]         if _token_ != 'NOT':
[  568s] >           comparison = self.comparison()
[  568s] 
[  568s] scss/grammar/expression.py:236: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def comparison(self):
[  568s] >       a_expr = self.a_expr()
[  568s] 
[  568s] scss/grammar/expression.py:244: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def a_expr(self):
[  568s] >       m_expr = self.m_expr()
[  568s] 
[  568s] scss/grammar/expression.py:275: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def m_expr(self):
[  568s] >       u_expr = self.u_expr()
[  568s] 
[  568s] scss/grammar/expression.py:290: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def u_expr(self):
[  568s]         _token_ = self._peek(self.u_expr_rsts)
[  568s]         if _token_ == 'SIGN':
[  568s]             SIGN = self._scan('SIGN')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.neg, u_expr)
[  568s]         elif _token_ == 'ADD':
[  568s]             ADD = self._scan('ADD')
[  568s]             u_expr = self.u_expr()
[  568s]             return UnaryOp(operator.pos, u_expr)
[  568s]         else:  # in self.u_expr_chks
[  568s] >           atom = self.atom()
[  568s] 
[  568s] scss/grammar/expression.py:319: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def atom(self):
[  568s]         _token_ = self._peek(self.u_expr_chks)
[  568s]         if _token_ == 'LPAR':
[  568s]             LPAR = self._scan('LPAR')
[  568s]             _token_ = self._peek(self.atom_rsts)
[  568s]             if _token_ == 'RPAR':
[  568s]                 v = ListLiteral([], comma=False)
[  568s]             else:  # in self.argspec_item_chks
[  568s] >               expr_map_or_list = self.expr_map_or_list()
[  568s] 
[  568s] scss/grammar/expression.py:330: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def expr_map_or_list(self):
[  568s]         expr_slst = self.expr_slst()
[  568s]         first = expr_slst
[  568s]         _token_ = self._peek(self.expr_map_or_list_rsts)
[  568s]         if _token_ == '":"':
[  568s]             self._scan('":"')
[  568s]             expr_slst = self.expr_slst()
[  568s]             pairs = [(first, expr_slst)]
[  568s]             while self._peek(self.expr_map_or_list_rsts_) == '","':
[  568s]                 self._scan('","')
[  568s]                 map_item = None, None
[  568s]                 if self._peek(self.expr_map_or_list_rsts__) not in self.expr_map_or_list_rsts_:
[  568s]                     map_item = self.map_item()
[  568s]                 pairs.append(map_item)
[  568s]             return MapLiteral(pairs)
[  568s]         else:  # in self.expr_map_or_list_rsts_
[  568s]             items = [first]; use_list = False
[  568s]             while self._peek(self.expr_map_or_list_rsts_) == '","':
[  568s]                 self._scan('","')
[  568s]                 use_list = True
[  568s] >               expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:187: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004c94050>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s]   (@1)  NUM  =  '1'
[  568s]   (@2)  ","  =  ',', i = 3
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s]   (@0)  LPAR  =  '('
[  568s]   (@1)  NUM  =  '1'
[  568s]   (@2)  ","  =  ','
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error after '(1, ': Found 'null, 2, n' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] ________________ scss/tests/files/general/scoping-mixin-2.scss _________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004cafb10>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004cafb10>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004cad3d0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2.scss')
[  568s] source = <SourceFile PosixPath('scoping-mixin-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004cafb10>
[  568s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cad3d0>>
[  568s] args = (), kwargs = {}
[  568s] 
[  568s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  568s]         """Call the given function with the given arguments.  If it succeeds,
[  568s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  568s]         and `live_errors` is turned on, return CSS containing a traceback and
[  568s]         error message.
[  568s]         """
[  568s]         try:
[  568s] >           return f(*args, **kwargs)
[  568s] 
[  568s] scss/compiler.py:176: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004cad3d0>
[  568s] 
[  568s]     def run(self):
[  568s]         # Any @import will add the source file to self.sources and infect this
[  568s]         # list, so make a quick copy to insulate against that
[  568s]         # TODO maybe @import should just not do that?
[  568s]         for source_file in list(self.sources):
[  568s]             rule = SassRule(
[  568s]                 source_file=source_file,
[  568s]                 lineno=1,
[  568s]     
[  568s]                 unparsed_contents=source_file.contents,
[  568s]                 namespace=self.root_namespace,
[  568s]             )
[  568s]             self.rules.append(rule)
[  568s] >           self.manage_children(rule, scope=None)
[  568s] 
[  568s] scss/compiler.py:296: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004cad3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def manage_children(self, rule, scope):
[  568s]         try:
[  568s] >           self._manage_children_impl(rule, scope)
[  568s] 
[  568s] scss/compiler.py:349: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004cad3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] 
[  568s]     def _manage_children_impl(self, rule, scope):
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]     
[  568s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  568s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  568s]     
[  568s]             ####################################################################
[  568s]             # At (@) blocks
[  568s]             if block.is_atrule:
[  568s]                 # TODO particularly wild idea: allow extensions to handle
[  568s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  568s]                 # core?  even move the core stuff into the core extension?
[  568s]                 code = block.directive
[  568s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  568s]                 try:
[  568s]                     method = getattr(self, code)
[  568s]                 except AttributeError:
[  568s]                     if block.unparsed_contents is None:
[  568s]                         rule.properties.append((block.prop, None))
[  568s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  568s]                         self._nest_at_rules(rule, scope, block)
[  568s]                 else:
[  568s]                     method(calculator, rule, scope, block)
[  568s]     
[  568s]             ####################################################################
[  568s]             # Properties
[  568s]             elif block.unparsed_contents is None:
[  568s] >               self._get_properties(rule, scope, block)
[  568s] 
[  568s] scss/compiler.py:383: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compilation object at 0x4004cad3d0>
[  568s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  568s] block = <scss.rule.UnparsedBlock object at 0x4004cacf10>
[  568s] 
[  568s]     def _get_properties(self, rule, scope, block):
[  568s]         """
[  568s]         Implements properties and variables extraction and assignment
[  568s]         """
[  568s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  568s]         if raw_value is not None:
[  568s]             raw_value = raw_value.strip()
[  568s]     
[  568s]         try:
[  568s]             is_var = (block.prop[len(prop)] == '=')
[  568s]         except IndexError:
[  568s]             is_var = False
[  568s]         if is_var:
[  568s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  568s]         calculator = self._make_calculator(rule.namespace)
[  568s]         prop = prop.strip()
[  568s]         prop = calculator.do_glob_math(prop)
[  568s]         if not prop:
[  568s]             return
[  568s]     
[  568s]         _prop = (scope or '') + prop
[  568s]         if is_var or prop.startswith('$') and raw_value is not None:
[  568s]             # Pop off any flags: !default, !global
[  568s]             is_default = False
[  568s]             is_global = True  # eventually sass will default this to false
[  568s]             while True:
[  568s]                 splits = raw_value.rsplit(None, 1)
[  568s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  568s]                     break
[  568s]     
[  568s]                 raw_value, flag = splits
[  568s]                 if flag == '!default':
[  568s]                     is_default = True
[  568s]                 elif flag == '!global':
[  568s]                     is_global = True
[  568s]                 else:
[  568s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  568s]     
[  568s]             # Variable assignment
[  568s]             _prop = normalize_var(_prop)
[  568s]             try:
[  568s]                 existing_value = rule.namespace.variable(_prop)
[  568s]             except KeyError:
[  568s]                 existing_value = None
[  568s]     
[  568s]             is_defined = existing_value is not None and not existing_value.is_null
[  568s]             if is_default and is_defined:
[  568s]                 pass
[  568s]             else:
[  568s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  568s]                     log.warn("Constant %r redefined", prop)
[  568s]     
[  568s]                 # Variable assignment is an expression, so it always performs
[  568s]                 # real division
[  568s] >               value = calculator.calculate(raw_value, divide=True)
[  568s] 
[  568s] scss/compiler.py:1081: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004cac490>
[  568s] expression = 'original', divide = True
[  568s] 
[  568s]     def calculate(self, expression, divide=False):
[  568s] >       result = self.evaluate_expression(expression, divide=divide)
[  568s] 
[  568s] scss/calculator.py:116: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004cac490>, expr = 'original'
[  568s] divide = True
[  568s] 
[  568s]     def evaluate_expression(self, expr, divide=False):
[  568s]         try:
[  568s] >           ast = self.parse_expression(expr)
[  568s] 
[  568s] scss/calculator.py:134: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.calculator.Calculator object at 0x4004cac490>, expr = 'original'
[  568s] target = 'goal'
[  568s] 
[  568s]     def parse_expression(self, expr, target='goal'):
[  568s]         if isinstance(expr, six.text_type):
[  568s]             # OK
[  568s]             pass
[  568s]         elif isinstance(expr, six.binary_type):
[  568s]             # Dubious
[  568s]             warn(FutureWarning(
[  568s]                 "parse_expression was passed binary data {0!r} "
[  568s]                 "-- this will no longer be supported in pyScss 2.0"
[  568s]                 .format(expr)
[  568s]             ))
[  568s]             # Don't guess an encoding; you reap what you sow
[  568s]             expr = six.text_type(expr)
[  568s]         else:
[  568s]             raise TypeError("Expected string, got %r" % (expr,))
[  568s]     
[  568s]         key = (target, expr)
[  568s]         if key in self.ast_cache:
[  568s]             return self.ast_cache[key]
[  568s]     
[  568s]         try:
[  568s]             parser = SassExpression(SassExpressionScanner(expr))
[  568s] >           ast = getattr(parser, target)()
[  568s] 
[  568s] scss/calculator.py:167: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def goal(self):
[  568s] >       expr_lst = self.expr_lst()
[  568s] 
[  568s] scss/grammar/expression.py:110: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def expr_lst(self):
[  568s] >       expr_slst = self.expr_slst()
[  568s] 
[  568s] scss/grammar/expression.py:199: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def expr_slst(self):
[  568s] >       or_expr = self.or_expr()
[  568s] 
[  568s] scss/grammar/expression.py:208: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def or_expr(self):
[  568s] >       and_expr = self.and_expr()
[  568s] 
[  568s] scss/grammar/expression.py:216: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def and_expr(self):
[  568s] >       not_expr = self.not_expr()
[  568s] 
[  568s] scss/grammar/expression.py:225: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] 
[  568s]     def not_expr(self):
[  568s] >       _token_ = self._peek(self.argspec_item_chks)
[  568s] 
[  568s] scss/grammar/expression.py:234: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.grammar.expression.SassExpression object at 0x4004cae610>
[  568s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _peek(self, types):
[  568s]         """
[  568s]         Returns the token type for lookahead; if there are any args
[  568s]         then the list of args is the set of token types to allow
[  568s]         """
[  568s] >       tok = self._scanner.token(self._pos, types)
[  568s] 
[  568s] scss/grammar/scanner.py:141: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = , i = 0
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def token(self, i, restrict=None):
[  568s]         """
[  568s]         Get the i'th token, and if i is one past the end, then scan
[  568s]         for another token; restrict is a list of tokens that
[  568s]         are allowed, or 0 for any token.
[  568s]         """
[  568s]         tokens_len = len(self.tokens)
[  568s]         if i == tokens_len:  # We are at the end, get the next...
[  568s] >           tokens_len += self._scan(restrict)
[  568s] 
[  568s] scss/grammar/scanner.py:270: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = 
[  568s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  568s] 
[  568s]     def _scan(self, restrict):
[  568s]         """
[  568s]         Should scan another token and add it to the list, self.tokens,
[  568s]         and add the restriction to self.restrictions
[  568s]         """
[  568s]         # Keep looking for a token, ignoring any in self.ignore
[  568s]         if DEBUG:
[  568s]             print()
[  568s]             print("Being asked to match with restriction:", repr(restrict))
[  568s]         token = None
[  568s]         while True:
[  568s]             best_pat = None
[  568s]             # Search the patterns for a match, with earlier
[  568s]             # tokens in the list having preference
[  568s]             best_pat_len = 0
[  568s]             for tok, regex in self.patterns:
[  568s]                 if DEBUG:
[  568s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  568s]                 # First check to see if we're restricting to this token
[  568s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  568s]                     if DEBUG:
[  568s]                         print("\tSkipping %r!" % (tok,))
[  568s]                     continue
[  568s]                 m = regex.match(self.input, self.pos)
[  568s]                 if m:
[  568s]                     # We got a match
[  568s]                     best_pat = tok
[  568s]                     best_pat_len = len(m.group(0))
[  568s]                     if DEBUG:
[  568s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  568s]                     break
[  568s]     
[  568s]             # If we didn't find anything, raise an error
[  568s]             if best_pat is None:
[  568s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  568s] E               scss.errors.SassSyntaxError: Syntax error: Found 'original' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  568s] 
[  568s] scss/grammar/scanner.py:236: SassSyntaxError
[  568s] _________________ scss/tests/files/general/scoping-mixin.scss __________________
[  568s] 
[  568s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss>
[  568s] 
[  568s]     def runtest(self):
[  568s]         scss_file = Path(str(self.fspath))
[  568s]         css_file = scss_file.with_suffix('.css')
[  568s]     
[  568s]         with css_file.open('rb') as fh:
[  568s]             # Output is Unicode, so decode this here
[  568s]             expected = fh.read().decode('utf8')
[  568s]     
[  568s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  568s]     
[  568s]         search_path = []
[  568s]         include = scss_file.parent / 'include'
[  568s]         if include.exists():
[  568s]             search_path.append(include)
[  568s]         search_path.append(scss_file.parent)
[  568s]     
[  568s]         try:
[  568s] >           actual = compile_file(
[  568s]                 scss_file,
[  568s]                 output_style='expanded',
[  568s]                 search_path=search_path,
[  568s]                 extensions=[
[  568s]                     CoreExtension,
[  568s]                     ExtraExtension,
[  568s]                     FontsExtension,
[  568s]                     CompassExtension,
[  568s]                 ],
[  568s]             )
[  568s] 
[  568s] conftest.py:127: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss')
[  568s] compiler_class = <class 'scss.compiler.Compiler'>
[  568s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  568s] compiler = <scss.compiler.Compiler object at 0x4004875310>
[  568s] 
[  568s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  568s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  568s]         a string of CSS.
[  568s]     
[  568s]         Keyword arguments are passed along to the underlying `Compiler`.
[  568s]     
[  568s]         Note that the search path is set to the file's containing directory by
[  568s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  568s]     
[  568s]         :param filename: Path to the file to compile.
[  568s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  568s]         """
[  568s]         filename = Path(filename)
[  568s]         if 'search_path' not in kwargs:
[  568s]             kwargs['search_path'] = [filename.parent.resolve()]
[  568s]     
[  568s]         compiler = compiler_class(**kwargs)
[  568s] >       return compiler.compile(filename)
[  568s] 
[  568s] scss/compiler.py:237: 
[  568s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  568s] 
[  568s] self = <scss.compiler.Compiler object at 0x4004875310>
[  568s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss'),)
[  568s] compilation = <scss.compiler.Compilation object at 0x4004876ed0>
[  568s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss')
[  568s] source = <SourceFile PosixPath('scoping-mixin.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  568s] 
[  568s]     def compile(self, *filenames):
[  568s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  568s]         # get something out besides just the output, you have to copy this
[  568s]         # method.  that sucks.
[  568s]         # TODO i think the right thing is to get all the constructors out of
[  568s]         # SourceFile, since it's really the compiler that knows the import
[  568s]         # paths and should be consulted about this.  reconsider all this (but
[  568s]         # preserve it for now, SIGH) once importers are a thing
[  568s]         compilation = self.make_compilation()
[  568s]         for filename in filenames:
[  568s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  568s]             # instead Compilation should have methods for add_string etc. that
[  568s]             # can call normalize_path.
[  568s]             # TODO it's not possible to inject custom files into the
[  568s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  568s]             # imports.  do we want the former?  is the latter better suited to
[  568s]             # an extension?
[  568s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  568s]             compilation.add_source(source)
[  568s] >       return self.call_and_catch_errors(compilation.run)
[  568s] 
[  568s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004875310>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004876ed0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004876ed0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004876ed0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004876ed0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004876ed0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004877790>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004876a90>, expression = 'blue'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004876a90>, expr = 'blue'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004876a90>, expr = 'blue'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004877750>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ________________ scss/tests/files/general/scoping-nested-2.scss ________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004cade50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004cade50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2.scss')
[  569s] source = <SourceFile PosixPath('scoping-nested-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004cade50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cacdd0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004920410>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cacdd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004922d10>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004920790>, expression = 'black'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004920790>, expr = 'black'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004920790>, expr = 'black'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40049219d0>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'black' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/general/scoping-nested.scss _________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004cc8bd0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004cc8bd0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004cc9890>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested.scss')
[  569s] source = <SourceFile PosixPath('scoping-nested.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004cc8bd0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cc9890>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cc9890>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cc9890>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cc9890>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cc9890>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004ccaa90>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004cc8490>, expression = 'black'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004cc8490>, expr = 'black'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004cc8490>, expr = 'black'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb750>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'black' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ______________ scss/tests/files/general/slurpy-keyword-args.scss _______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....0/scss/tests/files/general/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004c57610>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c57610>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args.scss')
[  569s] source = <SourceFile PosixPath('slurpy-keyword-args.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c57610>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c55750>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c56a90>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004c56950>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c57890>
[  569s] 
[  569s]     def _at_include(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @include, for @mixins
[  569s]         """
[  569s]         caller_namespace = rule.namespace
[  569s]         caller_calculator = self._make_calculator(caller_namespace)
[  569s] >       funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  569s] 
[  569s] scss/compiler.py:718: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c55750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004c55c90>
[  569s] argument = 'accepts-basically-anything(red, blue, $left: 5px, $right: 10px)'
[  569s] 
[  569s]     def _get_funct_def(self, rule, calculator, argument):
[  569s]         funct, lpar, argstr = argument.partition('(')
[  569s]         funct = calculator.do_glob_math(funct)
[  569s]         funct = normalize_var(funct.strip())
[  569s]         argstr = argstr.strip()
[  569s]     
[  569s]         # Parse arguments with the argspec rule
[  569s]         if lpar:
[  569s]             if not argstr.endswith(')'):
[  569s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  569s]             argstr = argstr[:-1].strip()
[  569s]         else:
[  569s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  569s]             argstr = ''
[  569s]     
[  569s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  569s] 
[  569s] scss/compiler.py:559: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c55c90>
[  569s] expr = 'red, blue, $left: 5px, $right: 10px', target = 'goal_argspec'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c56750>
[  569s] 
[  569s]     def goal_argspec(self):
[  569s] >       argspec = self.argspec()
[  569s] 
[  569s] scss/grammar/expression.py:115: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c56750>
[  569s] 
[  569s]     def argspec(self):
[  569s] >       _token_ = self._peek(self.argspec_rsts)
[  569s] 
[  569s] scss/grammar/expression.py:120: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c56750>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red, blue,' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ______________________ scss/tests/files/kronuz/args.scss _______________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004874c50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004874c50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004877cd0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args.scss')
[  569s] source = <SourceFile PosixPath('args.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004874c50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004877cd0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004877cd0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004877cd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004877cd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004877cd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004876ad0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004875a90>, expression = 'true'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004875a90>, expr = 'true'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004875a90>, expr = 'true'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004875d50>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'true' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ________________ scss/tests/files/kronuz/functions-context.scss ________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004a9b550>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a9b550>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context.scss')
[  569s] source = <SourceFile PosixPath('functions-context.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a9b550>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a9ab50>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c47b10>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#sidebar'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#sidebar'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a9ab50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#sidebar'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c46f90>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c456d0>
[  569s] expression = 'grid-width(5)', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c456d0>
[  569s] expr = 'grid-width(5)', divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c456d0>
[  569s] expr = 'grid-width(5)', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c46690>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'grid-width' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] __________________ scss/tests/files/kronuz/image-colors.scss ___________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004ccb3d0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ccb3d0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors.scss')
[  569s] source = <SourceFile PosixPath('image-colors.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ccb3d0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004ccbc10>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004cca2d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.mod'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.mod'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ccbc10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.mod'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004cc9ad0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ccb4d0>
[  569s] expression = 'inline-image("squares/ten-by-ten.png", $src-color: #c4c4c4, $dst-color: green)'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ccb4d0>
[  569s] expr = 'inline-image("squares/ten-by-ten.png", $src-color: #c4c4c4, $dst-color: green)'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ccb4d0>
[  569s] expr = 'inline-image("squares/ten-by-ten.png", $src-color: #c4c4c4, $dst-color: green)'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ccb6d0>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'inline-ima' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/imports-unused.scss __________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004bb5010>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004bb5010>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss')
[  569s] source = <SourceFile PosixPath('imports-unused.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004bb5010>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c5ad90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c58390>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004c5b490>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c59e90>
[  569s] 
[  569s]     def _at_import(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @import
[  569s]         Load and import mixins and functions and rules
[  569s]         """
[  569s]         # TODO it would be neat to opt into warning that you're using
[  569s]         # values/functions from a file you didn't explicitly import
[  569s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  569s]         # to be @imported into a nested block
[  569s]         # TODO i'm not sure we disallow them nested in the first place
[  569s]         # TODO @import is disallowed within mixins, control directives
[  569s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  569s]         # lot of our directives
[  569s]     
[  569s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  569s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  569s]         # -- in a string it's literal!)
[  569s]     
[  569s]         sass_paths = calculator.evaluate_expression(block.argument)
[  569s]         css_imports = []
[  569s]     
[  569s]         for sass_path in sass_paths:
[  569s]             # These are the rules for when an @import is interpreted as a CSS
[  569s]             # import:
[  569s]             if (
[  569s]                     # If it's a url()
[  569s]                     isinstance(sass_path, Url) or
[  569s]                     # If it's not a string (including `"foo" screen`, a List)
[  569s]                     not isinstance(sass_path, String) or
[  569s]                     # If the filename begins with an http protocol
[  569s]                     sass_path.value.startswith(('http://', 'https://')) or
[  569s]                     # If the filename ends with .css
[  569s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  569s]                 css_imports.append(sass_path.render(compress=False))
[  569s]                 continue
[  569s]     
[  569s]             # Should be left with a plain String
[  569s]             name = sass_path.value
[  569s]     
[  569s]             source = None
[  569s]             for extension in self.compiler.extensions:
[  569s]                 source = extension.handle_import(name, self, rule)
[  569s]                 if source:
[  569s]                     break
[  569s]             else:
[  569s]                 # Didn't find anything!
[  569s]                 raise SassImportError(name, self.compiler, rule=rule)
[  569s]     
[  569s]             source = self.add_source(source)
[  569s]     
[  569s]             if rule.namespace.has_import(source):
[  569s]                 # If already imported in this scope, skip
[  569s]                 # TODO this might not be right -- consider if you @import a
[  569s]                 # file at top level, then @import it inside a selector block!
[  569s]                 continue
[  569s]     
[  569s]             _rule = SassRule(
[  569s]                 source_file=source,
[  569s]                 lineno=block.lineno,
[  569s]                 unparsed_contents=source.contents,
[  569s]     
[  569s]                 # rule
[  569s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  569s]                 options=rule.options,
[  569s]                 properties=rule.properties,
[  569s]                 extends_selectors=rule.extends_selectors,
[  569s]                 ancestry=rule.ancestry,
[  569s]                 namespace=rule.namespace,
[  569s]             )
[  569s]             rule.namespace.add_import(source, rule)
[  569s] >           self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:861: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c59b90>
[  569s] 
[  569s]     def _at_import(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @import
[  569s]         Load and import mixins and functions and rules
[  569s]         """
[  569s]         # TODO it would be neat to opt into warning that you're using
[  569s]         # values/functions from a file you didn't explicitly import
[  569s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  569s]         # to be @imported into a nested block
[  569s]         # TODO i'm not sure we disallow them nested in the first place
[  569s]         # TODO @import is disallowed within mixins, control directives
[  569s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  569s]         # lot of our directives
[  569s]     
[  569s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  569s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  569s]         # -- in a string it's literal!)
[  569s]     
[  569s]         sass_paths = calculator.evaluate_expression(block.argument)
[  569s]         css_imports = []
[  569s]     
[  569s]         for sass_path in sass_paths:
[  569s]             # These are the rules for when an @import is interpreted as a CSS
[  569s]             # import:
[  569s]             if (
[  569s]                     # If it's a url()
[  569s]                     isinstance(sass_path, Url) or
[  569s]                     # If it's not a string (including `"foo" screen`, a List)
[  569s]                     not isinstance(sass_path, String) or
[  569s]                     # If the filename begins with an http protocol
[  569s]                     sass_path.value.startswith(('http://', 'https://')) or
[  569s]                     # If the filename ends with .css
[  569s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  569s]                 css_imports.append(sass_path.render(compress=False))
[  569s]                 continue
[  569s]     
[  569s]             # Should be left with a plain String
[  569s]             name = sass_path.value
[  569s]     
[  569s]             source = None
[  569s]             for extension in self.compiler.extensions:
[  569s]                 source = extension.handle_import(name, self, rule)
[  569s]                 if source:
[  569s]                     break
[  569s]             else:
[  569s]                 # Didn't find anything!
[  569s]                 raise SassImportError(name, self.compiler, rule=rule)
[  569s]     
[  569s]             source = self.add_source(source)
[  569s]     
[  569s]             if rule.namespace.has_import(source):
[  569s]                 # If already imported in this scope, skip
[  569s]                 # TODO this might not be right -- consider if you @import a
[  569s]                 # file at top level, then @import it inside a selector block!
[  569s]                 continue
[  569s]     
[  569s]             _rule = SassRule(
[  569s]                 source_file=source,
[  569s]                 lineno=block.lineno,
[  569s]                 unparsed_contents=source.contents,
[  569s]     
[  569s]                 # rule
[  569s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  569s]                 options=rule.options,
[  569s]                 properties=rule.properties,
[  569s]                 extends_selectors=rule.extends_selectors,
[  569s]                 ancestry=rule.ancestry,
[  569s]                 namespace=rule.namespace,
[  569s]             )
[  569s]             rule.namespace.add_import(source, rule)
[  569s] >           self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:861: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5ad90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#test'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c5b510>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c5b090>, expression = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c5b090>, expr = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c5b090>, expr = 'red'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c5be90>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/linear-gradient.scss _________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004c97a50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c97a50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient.scss')
[  569s] source = <SourceFile PosixPath('linear-gradient.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c97a50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c95b50>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c94190>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c95b50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c95550>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c96850>
[  569s] expression = 'linear-gradient(top,  #4d4d4d 0%,#3f3f3f 50%,#333333 50%,#252525 100%)'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c96850>
[  569s] expr = 'linear-gradient(top,  #4d4d4d 0%,#3f3f3f 50%,#333333 50%,#252525 100%)'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c96850>
[  569s] expr = 'linear-gradient(top,  #4d4d4d 0%,#3f3f3f 50%,#333333 50%,#252525 100%)'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c95f90>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'linear-gra' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _______________ scss/tests/files/kronuz/lists-circular-nth.scss ________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004c5aad0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c5aad0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth.scss')
[  569s] source = <SourceFile PosixPath('lists-circular-nth.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c5aad0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c5a750>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c58d50>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c5a750>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c58310>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c583d0>
[  569s] expression = 'nth($list, 1)', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c583d0>
[  569s] expr = 'nth($list, 1)', divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c583d0>
[  569s] expr = 'nth($list, 1)', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4003fdd310>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'nth($list,' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] __________________ scss/tests/files/kronuz/mixin-varargs.scss __________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004dc6a10>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004dc6a10>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs.scss')
[  569s] source = <SourceFile PosixPath('mixin-varargs.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004dc6a10>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004dc6c90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004dc7f10>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004dc7590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004dc75d0>
[  569s] 
[  569s]     def _at_include(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @include, for @mixins
[  569s]         """
[  569s]         caller_namespace = rule.namespace
[  569s]         caller_calculator = self._make_calculator(caller_namespace)
[  569s] >       funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  569s] 
[  569s] scss/compiler.py:718: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004dc6c90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004dc7e10>
[  569s] argument = 'varargs(\n$color: pink,\n$background: blue,\n$border: 1px solid magenta,\n$width: 2px\n)'
[  569s] 
[  569s]     def _get_funct_def(self, rule, calculator, argument):
[  569s]         funct, lpar, argstr = argument.partition('(')
[  569s]         funct = calculator.do_glob_math(funct)
[  569s]         funct = normalize_var(funct.strip())
[  569s]         argstr = argstr.strip()
[  569s]     
[  569s]         # Parse arguments with the argspec rule
[  569s]         if lpar:
[  569s]             if not argstr.endswith(')'):
[  569s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  569s]             argstr = argstr[:-1].strip()
[  569s]         else:
[  569s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  569s]             argstr = ''
[  569s]     
[  569s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  569s] 
[  569s] scss/compiler.py:559: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004dc7e10>
[  569s] expr = '$color: pink,\n$background: blue,\n$border: 1px solid magenta,\n$width: 2px'
[  569s] target = 'goal_argspec'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def goal_argspec(self):
[  569s] >       argspec = self.argspec()
[  569s] 
[  569s] scss/grammar/expression.py:115: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def argspec(self):
[  569s]         _token_ = self._peek(self.argspec_rsts)
[  569s]         if _token_ not in self.argspec_chks:
[  569s]             if self._peek(self.argspec_rsts_) not in self.argspec_chks_:
[  569s] >               argspec_items = self.argspec_items()
[  569s] 
[  569s] scss/grammar/expression.py:123: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def argspec_items(self):
[  569s]         slurpy = None
[  569s] >       argspec_item = self.argspec_item()
[  569s] 
[  569s] scss/grammar/expression.py:137: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def argspec_item(self):
[  569s]         _token_ = self._peek(self.argspec_items_chks)
[  569s]         if _token_ == 'KWVAR':
[  569s]             KWVAR = self._scan('KWVAR')
[  569s]             self._scan('":"')
[  569s] >           expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:161: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dc7fd0>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  KWVAR  =  '$color'
[  569s]   (@6)  ":"  =  ':', i = 2
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  KWVAR  =  '$color'
[  569s]   (@6)  ":"  =  ':'
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error after '$color: ': Found 'pink,\n$bac' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/mixins-context.scss __________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004625210>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004625210>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context.scss')
[  569s] source = <SourceFile PosixPath('mixins-context.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004625210>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004b59150>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004b5a190>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004b58550>
[  569s] 
[  569s]     def _at_import(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @import
[  569s]         Load and import mixins and functions and rules
[  569s]         """
[  569s]         # TODO it would be neat to opt into warning that you're using
[  569s]         # values/functions from a file you didn't explicitly import
[  569s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  569s]         # to be @imported into a nested block
[  569s]         # TODO i'm not sure we disallow them nested in the first place
[  569s]         # TODO @import is disallowed within mixins, control directives
[  569s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  569s]         # lot of our directives
[  569s]     
[  569s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  569s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  569s]         # -- in a string it's literal!)
[  569s]     
[  569s]         sass_paths = calculator.evaluate_expression(block.argument)
[  569s]         css_imports = []
[  569s]     
[  569s]         for sass_path in sass_paths:
[  569s]             # These are the rules for when an @import is interpreted as a CSS
[  569s]             # import:
[  569s]             if (
[  569s]                     # If it's a url()
[  569s]                     isinstance(sass_path, Url) or
[  569s]                     # If it's not a string (including `"foo" screen`, a List)
[  569s]                     not isinstance(sass_path, String) or
[  569s]                     # If the filename begins with an http protocol
[  569s]                     sass_path.value.startswith(('http://', 'https://')) or
[  569s]                     # If the filename ends with .css
[  569s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  569s]                 css_imports.append(sass_path.render(compress=False))
[  569s]                 continue
[  569s]     
[  569s]             # Should be left with a plain String
[  569s]             name = sass_path.value
[  569s]     
[  569s]             source = None
[  569s]             for extension in self.compiler.extensions:
[  569s]                 source = extension.handle_import(name, self, rule)
[  569s]                 if source:
[  569s]                     break
[  569s]             else:
[  569s]                 # Didn't find anything!
[  569s]                 raise SassImportError(name, self.compiler, rule=rule)
[  569s]     
[  569s]             source = self.add_source(source)
[  569s]     
[  569s]             if rule.namespace.has_import(source):
[  569s]                 # If already imported in this scope, skip
[  569s]                 # TODO this might not be right -- consider if you @import a
[  569s]                 # file at top level, then @import it inside a selector block!
[  569s]                 continue
[  569s]     
[  569s]             _rule = SassRule(
[  569s]                 source_file=source,
[  569s]                 lineno=block.lineno,
[  569s]                 unparsed_contents=source.contents,
[  569s]     
[  569s]                 # rule
[  569s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  569s]                 options=rule.options,
[  569s]                 properties=rule.properties,
[  569s]                 extends_selectors=rule.extends_selectors,
[  569s]                 ancestry=rule.ancestry,
[  569s]                 namespace=rule.namespace,
[  569s]             )
[  569s]             rule.namespace.add_import(source, rule)
[  569s] >           self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:861: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004b59150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004b5b390>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004b59850>, expression = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004b59850>, expr = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004b59850>, expr = 'red'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004b5b2d0>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ___________________ scss/tests/files/kronuz/order-test.scss ____________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004a1d6d0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a1d6d0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004a1c8d0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test.scss')
[  569s] source = <SourceFile PosixPath('order-test.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a1d6d0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a1c8d0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1c8d0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1c8d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1c8d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1c8d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d27150>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d26a90>, expression = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d26a90>, expr = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d26a90>, expr = 'red'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d27650>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/reversed-range.scss __________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40047b64d0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047b64d0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d55b90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range.scss')
[  569s] source = <SourceFile PosixPath('reversed-range.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047b64d0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d55b90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d55b90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d55b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d55b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d55b90>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004d57650>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d54750>
[  569s] 
[  569s]     def _at_each(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @each
[  569s]         """
[  569s]         varstring, _, valuestring = block.argument.partition(' in ')
[  569s] >       values = calculator.calculate(valuestring)
[  569s] 
[  569s] scss/compiler.py:960: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d57650>
[  569s] expression = 'range(5, 1)', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d57650>, expr = 'range(5, 1)'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d57650>, expr = 'range(5, 1)'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d54790>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'range(5, 1' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ___________________ scss/tests/files/kronuz/rgba-colors.scss ___________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40047e6750>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047e6750>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors.scss')
[  569s] source = <SourceFile PosixPath('rgba-colors.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047e6750>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40047e6fd0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40047f6a10>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047e6fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400477e890>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477d490>
[  569s] expression = 'rgba(black, 60%)', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477d490>
[  569s] expr = 'rgba(black, 60%)', divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477d490>
[  569s] expr = 'rgba(black, 60%)', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477d950>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'rgba(black' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ______________ scss/tests/files/kronuz/scope-loop-variables.scss _______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40047e7910>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047e7910>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables.scss')
[  569s] source = <SourceFile PosixPath('scope-loop-variables.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047e7910>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d7d910>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d7d650>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d7d910>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004d7f510>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d7e110>
[  569s] 
[  569s]     def _at_each(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @each
[  569s]         """
[  569s]         varstring, _, valuestring = block.argument.partition(' in ')
[  569s] >       values = calculator.calculate(valuestring)
[  569s] 
[  569s] scss/compiler.py:960: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d7f510>
[  569s] expression = 'red blue', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d7f510>, expr = 'red blue'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d7f510>, expr = 'red blue'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d7ce50>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/scoping-control.scss _________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40048f7190>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40048f7190>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control.scss')
[  569s] source = <SourceFile PosixPath('scoping-control.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40048f7190>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40048f5b10>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c3e590>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40048f5b10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c3ee90>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c3fb50>, expression = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c3fb50>, expr = 'red'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c3fb50>, expr = 'red'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c3e190>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ______________ scss/tests/files/kronuz/selectors-append-nest.scss ______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40045b1a10>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40045b1a10>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40045b3410>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest.scss')
[  569s] source = <SourceFile PosixPath('selectors-append-nest.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40045b1a10>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40045b3410>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40045b3410>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40045b3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40045b3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40045b3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40045b0a90>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40045b2110>
[  569s] expression = "append(nest('&, &:hover', 'li:hover'), unquote($_current))"
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40045b2110>
[  569s] expr = "append(nest('&, &:hover', 'li:hover'), unquote($_current))"
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40045b2110>
[  569s] expr = "append(nest('&, &:hover', 'li:hover'), unquote($_current))"
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40045b3850>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'append(nes' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________________ scss/tests/files/kronuz/selectors-nest.scss __________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40046aab50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40046aab50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest.scss')
[  569s] source = <SourceFile PosixPath('selectors-nest.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40046aab50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40046ab0d0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40046aa710>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>, <Selector: 'div'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>, <Selector: 'div'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40046ab0d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>, <Selector: 'div'>)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400477e2d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s] >       raw_selectors = calculator.do_glob_math(block.prop)
[  569s] 
[  569s] scss/compiler.py:1171: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477de90>
[  569s] cont = "#{nest('&:hover, &.hover', 'a')}"
[  569s] 
[  569s]     def do_glob_math(self, cont):
[  569s]         """Performs #{}-interpolation.  The result is always treated as a fixed
[  569s]         syntactic unit and will not be re-evaluated.
[  569s]         """
[  569s]         # TODO that's a lie!  this should be in the parser for most cases.
[  569s]         if not isinstance(cont, six.string_types):
[  569s]             warn(FutureWarning(
[  569s]                 "do_glob_math was passed a non-string {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(cont)
[  569s]             ))
[  569s]             cont = six.text_type(cont)
[  569s]         if '#{' not in cont:
[  569s]             return cont
[  569s] >       cont = _expr_glob_re.sub(self._pound_substitute, cont)
[  569s] 
[  569s] scss/calculator.py:67: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477de90>
[  569s] result = <re.Match object; span=(0, 32), match="#{nest('&:hover, &.hover', 'a')}">
[  569s] 
[  569s]     def _pound_substitute(self, result):
[  569s]         expr = result.group(1)
[  569s] >       value = self.evaluate_expression(expr)
[  569s] 
[  569s] scss/calculator.py:44: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477de90>
[  569s] expr = "nest('&:hover, &.hover', 'a')", divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400477de90>
[  569s] expr = "nest('&:hover, &.hover', 'a')", target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400477f8d0>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found "nest('&:ho" but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ________________ scss/tests/files/kronuz/selectors-special.scss ________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40047f8b10>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047f8b10>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special.scss')
[  569s] source = <SourceFile PosixPath('selectors-special.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40047f8b10>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40047f9150>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40045b0750>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40047f9750>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection'>, <Selector: '.pane :root'>, <Selector: ...Selector: '.pane input:checked'>, <Selector: '.pane input:disabled'>, <Selector: '.pane input:not(.ex)'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection'>, <Selector: '.pane :root'>, <Selector: ...Selector: '.pane input:checked'>, <Selector: '.pane input:disabled'>, <Selector: '.pane input:not(.ex)'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection'>, <Selector: '.pane :root'>, <Selector: ...Selector: '.pane input:checked'>, <Selector: '.pane input:disabled'>, <Selector: '.pane input:not(.ex)'>)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d545d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection.colored'>, <Selector: '.pane :root.colore...hecked.colored'>, <Selector: '.pane input:disabled.colored'>, <Selector: '.pane input:not(.ex).colored'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection.colored'>, <Selector: '.pane :root.colore...hecked.colored'>, <Selector: '.pane input:disabled.colored'>, <Selector: '.pane input:not(.ex).colored'>)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047f9150>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.pane ::selection.colored'>, <Selector: '.pane :root.colore...hecked.colored'>, <Selector: '.pane input:disabled.colored'>, <Selector: '.pane input:not(.ex).colored'>)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d70350>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d73610>, expression = 'green'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d73610>, expr = 'green'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d73610>, expr = 'green'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d71f10>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'green' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ___________________ scss/tests/files/kronuz/sprite-map.scss ____________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x400477ee90>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x400477ee90>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40047a3410>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map.scss')
[  569s] source = <SourceFile PosixPath('sprite-map.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x400477ee90>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40047a3410>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047a3410>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047a3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047a3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40047a3410>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40047a2e50>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40047a2a90>
[  569s] expression = 'sprite-map("squares/*.png", $cache-buster: false)', divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40047a2a90>
[  569s] expr = 'sprite-map("squares/*.png", $cache-buster: false)', divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40047a2a90>
[  569s] expr = 'sprite-map("squares/*.png", $cache-buster: false)', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40047a1c50>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'sprite-map' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] __________________ scss/tests/files/kronuz/style-nested.scss ___________________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc....4.0/scss/tests/files/kronuz/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004eb6310>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004eb6310>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested.scss')
[  569s] source = <SourceFile PosixPath('style-nested.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004eb6310>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004eb6d10>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004eb63d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004eb7450>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div.important'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div.important'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb6d10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div.important'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004eb7290>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eb75d0>
[  569s] expression = 'orange', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eb75d0>, expr = 'orange'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eb75d0>, expr = 'orange'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5690>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'orange' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _____________ scss/tests/files/original-doctests/000-general.scss ______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x40049b4ed0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40049b4ed0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general.scss')
[  569s] source = <SourceFile PosixPath('000-general.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x40049b4ed0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40049b7b90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c55410>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c55b50>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p span'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p span'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x40049b7b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'p span'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c54d10>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c571d0>, expression = 'blue'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c571d0>, expr = 'blue'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004c571d0>, expr = 'blue'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004c55190>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/001-variables.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004a25910>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a25910>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss')
[  569s] source = <SourceFile PosixPath('001-variables.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a25910>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a25210>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004a27910>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40049f1690>
[  569s] 
[  569s]     def _at_variables(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @variables and @vars
[  569s]         """
[  569s]         warn_deprecated(
[  569s]             rule,
[  569s]             "@variables and @vars are deprecated.  "
[  569s]             "Just assign variables at top-level.")
[  569s]         _rule = rule.copy()
[  569s]         _rule.unparsed_contents = block.unparsed_contents
[  569s]         _rule.namespace = rule.namespace
[  569s]         _rule.properties = []
[  569s] >       self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1023: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a25210>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x40049f1cd0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40046f62d0>
[  569s] expression = "unquote('../img/tmpl1/png')", divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40046f62d0>
[  569s] expr = "unquote('../img/tmpl1/png')", divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x40046f62d0>
[  569s] expr = "unquote('../img/tmpl1/png')", target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x40046f7b10>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found "unquote('." but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _________ scss/tests/files/original-doctests/002-nesting-children.scss _________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x400482f5d0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x400482f5d0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss')
[  569s] source = <SourceFile PosixPath('002-nesting-children.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x400482f5d0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400482eb90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004a86dd0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ecaa10>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x400482eb90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004eca210>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eca7d0>, expression = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eca7d0>, expr = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004eca7d0>, expr = 'block'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ec9710>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'block' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ________ scss/tests/files/original-doctests/003-nesting-children-2.scss ________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004a24b90>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a24b90>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss')
[  569s] source = <SourceFile PosixPath('003-nesting-children-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a24b90>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a24fd0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004efdfd0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004efeed0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a24fd0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004efe2d0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004efca90>, expression = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004efca90>, expr = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004efca90>, expr = 'block'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004efd850>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'block' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ________ scss/tests/files/original-doctests/004-nesting-children-3.scss ________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004d41310>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d41310>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss')
[  569s] source = <SourceFile PosixPath('004-nesting-children-3.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d41310>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d40590>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d41a90>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40047b4f50>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d40590>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.selector a'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ec8950>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ec8a90>, expression = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ec8a90>, expr = 'block'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004ec8a90>, expr = 'block'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004ecb390>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'block' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/007-extends-3.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004eb5a50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004eb5a50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss')
[  569s] source = <SourceFile PosixPath('007-extends-3.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004eb5a50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004eb7a10>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004eb6e50>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d490d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass a'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004eb7a10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicClass a'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d4b850>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d4b550>, expression = 'none'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d4b550>, expr = 'none'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d4b550>, expr = 'none'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d49510>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'none' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/008-extends-4.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004d6ec90>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d6ec90>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss')
[  569s] source = <SourceFile PosixPath('008-extends-4.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d6ec90>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d6df10>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d6da50>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d6cad0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d6df10>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d6c110>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d6e510>
[  569s] expression = '1px solid #000000', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d6e510>
[  569s] expr = '1px solid #000000', divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004d6e510>
[  569s] expr = '1px solid #000000', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def not_expr(self):
[  569s]         _token_ = self._peek(self.argspec_item_chks)
[  569s]         if _token_ != 'NOT':
[  569s] >           comparison = self.comparison()
[  569s] 
[  569s] scss/grammar/expression.py:236: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def comparison(self):
[  569s] >       a_expr = self.a_expr()
[  569s] 
[  569s] scss/grammar/expression.py:244: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def a_expr(self):
[  569s] >       m_expr = self.m_expr()
[  569s] 
[  569s] scss/grammar/expression.py:275: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] 
[  569s]     def m_expr(self):
[  569s]         u_expr = self.u_expr()
[  569s]         v = u_expr
[  569s] >       while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  569s] 
[  569s] scss/grammar/expression.py:292: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004d6df90>
[  569s] types = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  NUM  =  '1'
[  569s]   (@1)  UNITS  =  'px', i = 2
[  569s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  NUM  =  '1'
[  569s]   (@1)  UNITS  =  'px'
[  569s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error after '1px ': Found 'solid #000' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/009-extends-5.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004d0d210>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d0d210>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss')
[  569s] source = <SourceFile PosixPath('009-extends-5.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d0d210>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d0e2d0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d0f790>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400474e410>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d0e2d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.basicList li'>,)>,)>, 1 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400474e3d0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400474ced0>
[  569s] expression = '1px solid #000000', divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400474ced0>
[  569s] expr = '1px solid #000000', divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x400474ced0>
[  569s] expr = '1px solid #000000', target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def not_expr(self):
[  569s]         _token_ = self._peek(self.argspec_item_chks)
[  569s]         if _token_ != 'NOT':
[  569s] >           comparison = self.comparison()
[  569s] 
[  569s] scss/grammar/expression.py:236: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def comparison(self):
[  569s] >       a_expr = self.a_expr()
[  569s] 
[  569s] scss/grammar/expression.py:244: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def a_expr(self):
[  569s] >       m_expr = self.m_expr()
[  569s] 
[  569s] scss/grammar/expression.py:275: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] 
[  569s]     def m_expr(self):
[  569s]         u_expr = self.u_expr()
[  569s]         v = u_expr
[  569s] >       while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  569s] 
[  569s] scss/grammar/expression.py:292: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x400474f1d0>
[  569s] types = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  NUM  =  '1'
[  569s]   (@1)  UNITS  =  'px', i = 2
[  569s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s]   (@0)  NUM  =  '1'
[  569s]   (@1)  UNITS  =  'px'
[  569s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error after '1px ': Found 'solid #000' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _____________ scss/tests/files/original-doctests/013-nesting.scss ______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004d3f250>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d3f250>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss')
[  569s] source = <SourceFile PosixPath('013-nesting.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d3f250>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d3ca90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d3e090>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar'>,)>,)>, 2 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar'>,)>,)>, 2 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar'>,)>,)>, 2 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e10ed0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar ul'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar ul'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3ca90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar ul'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e12a90>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e12c90>, expression = 'none'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e12c90>, expr = 'none'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e12c90>, expr = 'none'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e10190>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'none' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/014-nesting-2.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004def690>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004def690>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss')
[  569s] source = <SourceFile PosixPath('014-nesting-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004def690>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004ded4d0>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004decc10>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.fakeshadow'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.fakeshadow'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s] >               self.manage_children(rule, subscope)
[  569s] 
[  569s] scss/compiler.py:393: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.fakeshadow'>,)>,)>, 0 props>
[  569s] scope = 'border-'
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.fakeshadow'>,)>,)>, 0 props>
[  569s] scope = 'border-'
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ded4d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.fakeshadow'>,)>,)>, 0 props>
[  569s] scope = 'border-', block = <scss.rule.UnparsedBlock object at 0x4004ded9d0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s]                 value = calculator.calculate(raw_value, divide=True)
[  569s]                 rule.namespace.set_variable(
[  569s]                     _prop, value, local_only=not is_global)
[  569s]         else:
[  569s]             # Regular property destined for output
[  569s]             _prop = calculator.apply_vars(_prop)
[  569s]             if raw_value is None:
[  569s]                 value = None
[  569s]             else:
[  569s] >               value = calculator.calculate(raw_value)
[  569s] 
[  569s] scss/compiler.py:1090: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004dec950>, expression = 'solid'
[  569s] divide = False
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004dec950>, expr = 'solid'
[  569s] divide = False
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004dec950>, expr = 'solid'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004dece50>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'solid' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ____________ scss/tests/files/original-doctests/016-variables.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004d3fb10>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d3fb10>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004d3fe90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss')
[  569s] source = <SourceFile PosixPath('016-variables.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004d3fb10>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d3fe90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3fe90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3fe90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3fe90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004d3fe90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004680d50>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004682e90>, expression = 'solid'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004682e90>, expr = 'solid'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004682e90>, expr = 'solid'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004683750>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'solid' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] __________ scss/tests/files/original-doctests/017-interpolation.scss ___________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004a1fed0>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a1fed0>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004a1e390>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss')
[  569s] source = <SourceFile PosixPath('017-interpolation.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004a1fed0>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a1e390>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1e390>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1e390>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1e390>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004a1e390>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004fb0fd0>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004fb08d0>, expression = 'top'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004fb08d0>, expr = 'top'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004fb08d0>, expr = 'top'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004fb0850>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'top' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] ______________ scss/tests/files/original-doctests/018-mixins.scss ______________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004ceeb50>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ceeb50>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss')
[  569s] source = <SourceFile PosixPath('018-mixins.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ceeb50>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cefe50>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004d3ddd0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] calculator = <scss.calculator.Calculator object at 0x40048757d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004877150>
[  569s] 
[  569s]     def _at_include(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @include, for @mixins
[  569s]         """
[  569s]         caller_namespace = rule.namespace
[  569s]         caller_calculator = self._make_calculator(caller_namespace)
[  569s]         funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  569s]     
[  569s]         # Render the passed arguments, using the caller's namespace
[  569s]         args, kwargs = caller_argspec.evaluate_call_args(caller_calculator)
[  569s]     
[  569s]         argc = len(args) + len(kwargs)
[  569s]         try:
[  569s]             mixin = caller_namespace.mixin(funct, argc)
[  569s]         except KeyError:
[  569s]             try:
[  569s]                 # TODO maybe? don't do this, once '...' works
[  569s]                 # Fallback to single parameter:
[  569s]                 mixin = caller_namespace.mixin(funct, 1)
[  569s]             except KeyError:
[  569s]                 log.error("Mixin not found: %s:%d (%s)", funct, argc, rule.file_and_line, extra={'stack': True})
[  569s]                 return
[  569s]             else:
[  569s]                 args = [List(args, use_comma=True)]
[  569s]                 # TODO what happens to kwargs?
[  569s]     
[  569s]         source_file = mixin[0]
[  569s]         lineno = mixin[1]
[  569s]         m_codestr = mixin[2]
[  569s]         pristine_callee_namespace = mixin[3]
[  569s]         callee_argspec = mixin[4]
[  569s]         if caller_argspec.inject and callee_argspec.inject:
[  569s]             # DEVIATION: Pass the ENTIRE local namespace to the mixin (yikes)
[  569s]             callee_namespace = Namespace.derive_from(
[  569s]                 caller_namespace,
[  569s]                 pristine_callee_namespace)
[  569s]         else:
[  569s]             callee_namespace = pristine_callee_namespace.derive()
[  569s]     
[  569s]         self._populate_namespace_from_call(
[  569s]             "Mixin {0}".format(funct),
[  569s]             callee_namespace, mixin, args, kwargs)
[  569s]     
[  569s]         _rule = SassRule(
[  569s]             # These must be file and line in which the @include occurs
[  569s]             source_file=rule.source_file,
[  569s]             lineno=rule.lineno,
[  569s]     
[  569s]             # These must be file and line in which the @mixin was defined
[  569s]             from_source_file=source_file,
[  569s]             from_lineno=lineno,
[  569s]     
[  569s]             unparsed_contents=m_codestr,
[  569s]             namespace=callee_namespace,
[  569s]     
[  569s]             # rule
[  569s]             import_key=rule.import_key,
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options,
[  569s]             properties=rule.properties,
[  569s]             extends_selectors=rule.extends_selectors,
[  569s]             ancestry=rule.ancestry,
[  569s]             nested=rule.nested,
[  569s]         )
[  569s]     
[  569s]         _rule.options['@content'] = block.unparsed_contents
[  569s] >       self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:778: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s] >               self._get_properties(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:383: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004cefe50>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e13710>
[  569s] 
[  569s]     def _get_properties(self, rule, scope, block):
[  569s]         """
[  569s]         Implements properties and variables extraction and assignment
[  569s]         """
[  569s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  569s]         if raw_value is not None:
[  569s]             raw_value = raw_value.strip()
[  569s]     
[  569s]         try:
[  569s]             is_var = (block.prop[len(prop)] == '=')
[  569s]         except IndexError:
[  569s]             is_var = False
[  569s]         if is_var:
[  569s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         prop = prop.strip()
[  569s]         prop = calculator.do_glob_math(prop)
[  569s]         if not prop:
[  569s]             return
[  569s]     
[  569s]         _prop = (scope or '') + prop
[  569s]         if is_var or prop.startswith('$') and raw_value is not None:
[  569s]             # Pop off any flags: !default, !global
[  569s]             is_default = False
[  569s]             is_global = True  # eventually sass will default this to false
[  569s]             while True:
[  569s]                 splits = raw_value.rsplit(None, 1)
[  569s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  569s]                     break
[  569s]     
[  569s]                 raw_value, flag = splits
[  569s]                 if flag == '!default':
[  569s]                     is_default = True
[  569s]                 elif flag == '!global':
[  569s]                     is_global = True
[  569s]                 else:
[  569s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  569s]     
[  569s]             # Variable assignment
[  569s]             _prop = normalize_var(_prop)
[  569s]             try:
[  569s]                 existing_value = rule.namespace.variable(_prop)
[  569s]             except KeyError:
[  569s]                 existing_value = None
[  569s]     
[  569s]             is_defined = existing_value is not None and not existing_value.is_null
[  569s]             if is_default and is_defined:
[  569s]                 pass
[  569s]             else:
[  569s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  569s]                     log.warn("Constant %r redefined", prop)
[  569s]     
[  569s]                 # Variable assignment is an expression, so it always performs
[  569s]                 # real division
[  569s] >               value = calculator.calculate(raw_value, divide=True)
[  569s] 
[  569s] scss/compiler.py:1081: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e11ed0>, expression = 'top'
[  569s] divide = True
[  569s] 
[  569s]     def calculate(self, expression, divide=False):
[  569s] >       result = self.evaluate_expression(expression, divide=divide)
[  569s] 
[  569s] scss/calculator.py:116: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e11ed0>, expr = 'top'
[  569s] divide = True
[  569s] 
[  569s]     def evaluate_expression(self, expr, divide=False):
[  569s]         try:
[  569s] >           ast = self.parse_expression(expr)
[  569s] 
[  569s] scss/calculator.py:134: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e11ed0>, expr = 'top'
[  569s] target = 'goal'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def goal(self):
[  569s] >       expr_lst = self.expr_lst()
[  569s] 
[  569s] scss/grammar/expression.py:110: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def expr_lst(self):
[  569s] >       expr_slst = self.expr_slst()
[  569s] 
[  569s] scss/grammar/expression.py:199: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def expr_slst(self):
[  569s] >       or_expr = self.or_expr()
[  569s] 
[  569s] scss/grammar/expression.py:208: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def or_expr(self):
[  569s] >       and_expr = self.and_expr()
[  569s] 
[  569s] scss/grammar/expression.py:216: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def and_expr(self):
[  569s] >       not_expr = self.not_expr()
[  569s] 
[  569s] scss/grammar/expression.py:225: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] 
[  569s]     def not_expr(self):
[  569s] >       _token_ = self._peek(self.argspec_item_chks)
[  569s] 
[  569s] scss/grammar/expression.py:234: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e12050>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'top' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _____________ scss/tests/files/original-doctests/019-mixins-2.scss _____________
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004c59e90>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c59e90>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss')
[  569s] source = <SourceFile PosixPath('019-mixins-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004c59e90>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c59b90>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004c581d0>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             extends_selectors=c_parents,
[  569s]             ancestry=new_ancestry,
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004e597d0>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e5b710>
[  569s] 
[  569s]     def _at_include(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @include, for @mixins
[  569s]         """
[  569s]         caller_namespace = rule.namespace
[  569s]         caller_calculator = self._make_calculator(caller_namespace)
[  569s] >       funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  569s] 
[  569s] scss/compiler.py:718: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004c59b90>
[  569s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#navbar li'>,)>,)>, 0 props>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004e59f90>
[  569s] argument = 'rounded(top)'
[  569s] 
[  569s]     def _get_funct_def(self, rule, calculator, argument):
[  569s]         funct, lpar, argstr = argument.partition('(')
[  569s]         funct = calculator.do_glob_math(funct)
[  569s]         funct = normalize_var(funct.strip())
[  569s]         argstr = argstr.strip()
[  569s]     
[  569s]         # Parse arguments with the argspec rule
[  569s]         if lpar:
[  569s]             if not argstr.endswith(')'):
[  569s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  569s]             argstr = argstr[:-1].strip()
[  569s]         else:
[  569s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  569s]             argstr = ''
[  569s]     
[  569s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  569s] 
[  569s] scss/compiler.py:559: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.calculator.Calculator object at 0x4004e59f90>, expr = 'top'
[  569s] target = 'goal_argspec'
[  569s] 
[  569s]     def parse_expression(self, expr, target='goal'):
[  569s]         if isinstance(expr, six.text_type):
[  569s]             # OK
[  569s]             pass
[  569s]         elif isinstance(expr, six.binary_type):
[  569s]             # Dubious
[  569s]             warn(FutureWarning(
[  569s]                 "parse_expression was passed binary data {0!r} "
[  569s]                 "-- this will no longer be supported in pyScss 2.0"
[  569s]                 .format(expr)
[  569s]             ))
[  569s]             # Don't guess an encoding; you reap what you sow
[  569s]             expr = six.text_type(expr)
[  569s]         else:
[  569s]             raise TypeError("Expected string, got %r" % (expr,))
[  569s]     
[  569s]         key = (target, expr)
[  569s]         if key in self.ast_cache:
[  569s]             return self.ast_cache[key]
[  569s]     
[  569s]         try:
[  569s]             parser = SassExpression(SassExpressionScanner(expr))
[  569s] >           ast = getattr(parser, target)()
[  569s] 
[  569s] scss/calculator.py:167: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e5ac90>
[  569s] 
[  569s]     def goal_argspec(self):
[  569s] >       argspec = self.argspec()
[  569s] 
[  569s] scss/grammar/expression.py:115: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e5ac90>
[  569s] 
[  569s]     def argspec(self):
[  569s] >       _token_ = self._peek(self.argspec_rsts)
[  569s] 
[  569s] scss/grammar/expression.py:120: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.grammar.expression.SassExpression object at 0x4004e5ac90>
[  569s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def _peek(self, types):
[  569s]         """
[  569s]         Returns the token type for lookahead; if there are any args
[  569s]         then the list of args is the set of token types to allow
[  569s]         """
[  569s] >       tok = self._scanner.token(self._pos, types)
[  569s] 
[  569s] scss/grammar/scanner.py:141: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = , i = 0
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def token(self, i, restrict=None):
[  569s]         """
[  569s]         Get the i'th token, and if i is one past the end, then scan
[  569s]         for another token; restrict is a list of tokens that
[  569s]         are allowed, or 0 for any token.
[  569s]         """
[  569s]         tokens_len = len(self.tokens)
[  569s]         if i == tokens_len:  # We are at the end, get the next...
[  569s] >           tokens_len += self._scan(restrict)
[  569s] 
[  569s] scss/grammar/scanner.py:270: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = 
[  569s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  569s] 
[  569s]     def _scan(self, restrict):
[  569s]         """
[  569s]         Should scan another token and add it to the list, self.tokens,
[  569s]         and add the restriction to self.restrictions
[  569s]         """
[  569s]         # Keep looking for a token, ignoring any in self.ignore
[  569s]         if DEBUG:
[  569s]             print()
[  569s]             print("Being asked to match with restriction:", repr(restrict))
[  569s]         token = None
[  569s]         while True:
[  569s]             best_pat = None
[  569s]             # Search the patterns for a match, with earlier
[  569s]             # tokens in the list having preference
[  569s]             best_pat_len = 0
[  569s]             for tok, regex in self.patterns:
[  569s]                 if DEBUG:
[  569s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  569s]                 # First check to see if we're restricting to this token
[  569s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  569s]                     if DEBUG:
[  569s]                         print("\tSkipping %r!" % (tok,))
[  569s]                     continue
[  569s]                 m = regex.match(self.input, self.pos)
[  569s]                 if m:
[  569s]                     # We got a match
[  569s]                     best_pat = tok
[  569s]                     best_pat_len = len(m.group(0))
[  569s]                     if DEBUG:
[  569s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  569s]                     break
[  569s]     
[  569s]             # If we didn't find anything, raise an error
[  569s]             if best_pat is None:
[  569s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  569s] E               scss.errors.SassSyntaxError: Syntax error: Found 'top' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  569s] 
[  569s] scss/grammar/scanner.py:236: SassSyntaxError
[  569s] _____________ scss/tests/files/original-doctests/020-mixins-3.scss _____________
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s] >                   method = getattr(self, code)
[  569s] E                   AttributeError: 'Compilation' object has no attribute '_at_media'
[  569s] 
[  569s] scss/compiler.py:371: AttributeError
[  569s] 
[  569s] During handling of the above exception, another exception occurred:
[  569s] 
[  569s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss>
[  569s] 
[  569s]     def runtest(self):
[  569s]         scss_file = Path(str(self.fspath))
[  569s]         css_file = scss_file.with_suffix('.css')
[  569s]     
[  569s]         with css_file.open('rb') as fh:
[  569s]             # Output is Unicode, so decode this here
[  569s]             expected = fh.read().decode('utf8')
[  569s]     
[  569s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  569s]     
[  569s]         search_path = []
[  569s]         include = scss_file.parent / 'include'
[  569s]         if include.exists():
[  569s]             search_path.append(include)
[  569s]         search_path.append(scss_file.parent)
[  569s]     
[  569s]         try:
[  569s] >           actual = compile_file(
[  569s]                 scss_file,
[  569s]                 output_style='expanded',
[  569s]                 search_path=search_path,
[  569s]                 extensions=[
[  569s]                     CoreExtension,
[  569s]                     ExtraExtension,
[  569s]                     FontsExtension,
[  569s]                     CompassExtension,
[  569s]                 ],
[  569s]             )
[  569s] 
[  569s] conftest.py:127: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss')
[  569s] compiler_class = <class 'scss.compiler.Compiler'>
[  569s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  569s] compiler = <scss.compiler.Compiler object at 0x4004ea8c90>
[  569s] 
[  569s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  569s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  569s]         a string of CSS.
[  569s]     
[  569s]         Keyword arguments are passed along to the underlying `Compiler`.
[  569s]     
[  569s]         Note that the search path is set to the file's containing directory by
[  569s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  569s]     
[  569s]         :param filename: Path to the file to compile.
[  569s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  569s]         """
[  569s]         filename = Path(filename)
[  569s]         if 'search_path' not in kwargs:
[  569s]             kwargs['search_path'] = [filename.parent.resolve()]
[  569s]     
[  569s]         compiler = compiler_class(**kwargs)
[  569s] >       return compiler.compile(filename)
[  569s] 
[  569s] scss/compiler.py:237: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ea8c90>
[  569s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss'),)
[  569s] compilation = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss')
[  569s] source = <SourceFile PosixPath('020-mixins-3.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  569s] 
[  569s]     def compile(self, *filenames):
[  569s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  569s]         # get something out besides just the output, you have to copy this
[  569s]         # method.  that sucks.
[  569s]         # TODO i think the right thing is to get all the constructors out of
[  569s]         # SourceFile, since it's really the compiler that knows the import
[  569s]         # paths and should be consulted about this.  reconsider all this (but
[  569s]         # preserve it for now, SIGH) once importers are a thing
[  569s]         compilation = self.make_compilation()
[  569s]         for filename in filenames:
[  569s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  569s]             # instead Compilation should have methods for add_string etc. that
[  569s]             # can call normalize_path.
[  569s]             # TODO it's not possible to inject custom files into the
[  569s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  569s]             # imports.  do we want the former?  is the latter better suited to
[  569s]             # an extension?
[  569s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  569s]             compilation.add_source(source)
[  569s] >       return self.call_and_catch_errors(compilation.run)
[  569s] 
[  569s] scss/compiler.py:203: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compiler object at 0x4004ea8c90>
[  569s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004ea9490>>
[  569s] args = (), kwargs = {}
[  569s] 
[  569s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  569s]         """Call the given function with the given arguments.  If it succeeds,
[  569s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  569s]         and `live_errors` is turned on, return CSS containing a traceback and
[  569s]         error message.
[  569s]         """
[  569s]         try:
[  569s] >           return f(*args, **kwargs)
[  569s] 
[  569s] scss/compiler.py:176: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] 
[  569s]     def run(self):
[  569s]         # Any @import will add the source file to self.sources and infect this
[  569s]         # list, so make a quick copy to insulate against that
[  569s]         # TODO maybe @import should just not do that?
[  569s]         for source_file in list(self.sources):
[  569s]             rule = SassRule(
[  569s]                 source_file=source_file,
[  569s]                 lineno=1,
[  569s]     
[  569s]                 unparsed_contents=source_file.contents,
[  569s]                 namespace=self.root_namespace,
[  569s]             )
[  569s]             self.rules.append(rule)
[  569s] >           self.manage_children(rule, scope=None)
[  569s] 
[  569s] scss/compiler.py:296: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004eaa890>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004eaa2d0>
[  569s] 
[  569s]     def _at_include(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @include, for @mixins
[  569s]         """
[  569s]         caller_namespace = rule.namespace
[  569s]         caller_calculator = self._make_calculator(caller_namespace)
[  569s]         funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  569s]     
[  569s]         # Render the passed arguments, using the caller's namespace
[  569s]         args, kwargs = caller_argspec.evaluate_call_args(caller_calculator)
[  569s]     
[  569s]         argc = len(args) + len(kwargs)
[  569s]         try:
[  569s]             mixin = caller_namespace.mixin(funct, argc)
[  569s]         except KeyError:
[  569s]             try:
[  569s]                 # TODO maybe? don't do this, once '...' works
[  569s]                 # Fallback to single parameter:
[  569s]                 mixin = caller_namespace.mixin(funct, 1)
[  569s]             except KeyError:
[  569s]                 log.error("Mixin not found: %s:%d (%s)", funct, argc, rule.file_and_line, extra={'stack': True})
[  569s]                 return
[  569s]             else:
[  569s]                 args = [List(args, use_comma=True)]
[  569s]                 # TODO what happens to kwargs?
[  569s]     
[  569s]         source_file = mixin[0]
[  569s]         lineno = mixin[1]
[  569s]         m_codestr = mixin[2]
[  569s]         pristine_callee_namespace = mixin[3]
[  569s]         callee_argspec = mixin[4]
[  569s]         if caller_argspec.inject and callee_argspec.inject:
[  569s]             # DEVIATION: Pass the ENTIRE local namespace to the mixin (yikes)
[  569s]             callee_namespace = Namespace.derive_from(
[  569s]                 caller_namespace,
[  569s]                 pristine_callee_namespace)
[  569s]         else:
[  569s]             callee_namespace = pristine_callee_namespace.derive()
[  569s]     
[  569s]         self._populate_namespace_from_call(
[  569s]             "Mixin {0}".format(funct),
[  569s]             callee_namespace, mixin, args, kwargs)
[  569s]     
[  569s]         _rule = SassRule(
[  569s]             # These must be file and line in which the @include occurs
[  569s]             source_file=rule.source_file,
[  569s]             lineno=rule.lineno,
[  569s]     
[  569s]             # These must be file and line in which the @mixin was defined
[  569s]             from_source_file=source_file,
[  569s]             from_lineno=lineno,
[  569s]     
[  569s]             unparsed_contents=m_codestr,
[  569s]             namespace=callee_namespace,
[  569s]     
[  569s]             # rule
[  569s]             import_key=rule.import_key,
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options,
[  569s]             properties=rule.properties,
[  569s]             extends_selectors=rule.extends_selectors,
[  569s]             ancestry=rule.ancestry,
[  569s]             nested=rule.nested,
[  569s]         )
[  569s]     
[  569s]         _rule.options['@content'] = block.unparsed_contents
[  569s] >       self.manage_children(_rule, scope)
[  569s] 
[  569s] scss/compiler.py:778: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >                       self._nest_at_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:376: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  569s] block = <scss.rule.UnparsedBlock object at 0x4004ea8110>
[  569s] 
[  569s]     def _nest_at_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements @-blocks
[  569s]         """
[  569s]         # TODO handle @charset, probably?
[  569s]         # Interpolate the current block
[  569s]         # TODO this seems like it should be done in the block header.  and more
[  569s]         # generally?
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         if block.header.argument:
[  569s]             # TODO is this correct?  do ALL at-rules ALWAYS allow both vars and
[  569s]             # interpolation?
[  569s]             node = calculator.parse_vars_and_interpolations(
[  569s]                 block.header.argument)
[  569s]             block.header.argument = node.evaluate(calculator).render()
[  569s]     
[  569s]         # TODO merge into RuleAncestry
[  569s]         new_ancestry = list(rule.ancestry.headers)
[  569s]         if block.directive == '@media' and new_ancestry:
[  569s]             for i, header in reversed(list(enumerate(new_ancestry))):
[  569s]                 if header.is_selector:
[  569s]                     continue
[  569s]                 elif header.directive == '@media':
[  569s]                     new_ancestry[i] = BlockAtRuleHeader(
[  569s]                         '@media',
[  569s]                         "%s and %s" % (header.argument, block.argument))
[  569s]                     break
[  569s]                 else:
[  569s]                     new_ancestry.insert(i, block.header)
[  569s]             else:
[  569s]                 new_ancestry.insert(0, block.header)
[  569s]         else:
[  569s]             new_ancestry.append(block.header)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  569s]             source_file=rule.source_file,
[  569s]             import_key=rule.import_key,
[  569s]             lineno=block.lineno,
[  569s]             num_header_lines=block.header.num_lines,
[  569s]             unparsed_contents=block.unparsed_contents,
[  569s]     
[  569s]             legacy_compiler_options=rule.legacy_compiler_options,
[  569s]             options=rule.options.copy(),
[  569s]             #properties
[  569s]             #extends_selectors
[  569s]             ancestry=RuleAncestry(new_ancestry),
[  569s]     
[  569s]             namespace=rule.namespace.derive(),
[  569s]             nested=rule.nested + 1,
[  569s]         )
[  569s]         self.rules.append(new_rule)
[  569s]         rule.namespace.use_import(rule.source_file)
[  569s] >       self.manage_children(new_rule, scope)
[  569s] 
[  569s] scss/compiler.py:1161: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s] >                   method(calculator, rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:378: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] calculator = <scss.calculator.Calculator object at 0x4004ea8990>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ea9210>
[  569s] 
[  569s]     def _at_content(self, calculator, rule, scope, block):
[  569s]         """
[  569s]         Implements @content
[  569s]         """
[  569s]         if '@content' not in rule.options:
[  569s]             log.error("Content string not found for @content (%s)", rule.file_and_line)
[  569s]         rule.unparsed_contents = rule.options.pop('@content', '')
[  569s] >       self.manage_children(rule, scope)
[  569s] 
[  569s] scss/compiler.py:788: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def manage_children(self, rule, scope):
[  569s]         try:
[  569s] >           self._manage_children_impl(rule, scope)
[  569s] 
[  569s] scss/compiler.py:349: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None
[  569s] 
[  569s]     def _manage_children_impl(self, rule, scope):
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]     
[  569s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  569s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  569s]     
[  569s]             ####################################################################
[  569s]             # At (@) blocks
[  569s]             if block.is_atrule:
[  569s]                 # TODO particularly wild idea: allow extensions to handle
[  569s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  569s]                 # core?  even move the core stuff into the core extension?
[  569s]                 code = block.directive
[  569s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  569s]                 try:
[  569s]                     method = getattr(self, code)
[  569s]                 except AttributeError:
[  569s]                     if block.unparsed_contents is None:
[  569s]                         rule.properties.append((block.prop, None))
[  569s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s]                         self._nest_at_rules(rule, scope, block)
[  569s]                 else:
[  569s]                     method(calculator, rule, scope, block)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Properties
[  569s]             elif block.unparsed_contents is None:
[  569s]                 self._get_properties(rule, scope, block)
[  569s]     
[  569s]             # Nested properties
[  569s]             elif block.is_scope:
[  569s]                 if block.header.unscoped_value:
[  569s]                     # Possibly deal with default unscoped value
[  569s]                     self._get_properties(rule, scope, block)
[  569s]     
[  569s]                 rule.unparsed_contents = block.unparsed_contents
[  569s]                 subscope = (scope or '') + block.header.scope + '-'
[  569s]                 self.manage_children(rule, subscope)
[  569s]     
[  569s]             ####################################################################
[  569s]             # Nested rules
[  569s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  569s] >               self._nest_rules(rule, scope, block)
[  569s] 
[  569s] scss/compiler.py:398: 
[  569s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  569s] 
[  569s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  569s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>,)>, 0 props>
[  569s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ea8590>
[  569s] 
[  569s]     def _nest_rules(self, rule, scope, block):
[  569s]         """
[  569s]         Implements Nested CSS rules
[  569s]         """
[  569s]         calculator = self._make_calculator(rule.namespace)
[  569s]         raw_selectors = calculator.do_glob_math(block.prop)
[  569s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  569s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  569s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  569s]         if c_parents:
[  569s]             warn_deprecated(
[  569s]                 rule,
[  569s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  569s]                 "Use 'a { @extend b; }' instead."
[  569s]             )
[  569s]     
[  569s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  569s]     
[  569s]         rule.descendants += 1
[  569s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  570s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>, <BlockSelectorHeader (<Selector: 'body'>,)>)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  570s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>, <BlockSelectorHeader (<Selector: 'body'>,)>)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ea9490>
[  570s] rule = <SassRule <RuleAncestry (<BlockAtRuleHeader '@media' 'only screen and (max-width: 480px)'>, <BlockSelectorHeader (<Selector: 'body'>,)>)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004eabb90>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eaab50>, expression = 'red'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eaab50>, expr = 'red'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eaab50>, expr = 'red'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea9ed0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/021-extend.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004595a50>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004595a50>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004595210>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss')
[  570s] source = <SourceFile PosixPath('021-extend.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004595a50>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004595210>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004594050>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.error.intrusion'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.error.intrusion'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004595210>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.error.intrusion'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e58a90>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e59d90>
[  570s] expression = 'url("/image/hacked.png")', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e59d90>
[  570s] expr = 'url("/image/hacked.png")', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e59d90>
[  570s] expr = 'url("/image/hacked.png")', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e5bc50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'url("/imag' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________ scss/tests/files/original-doctests/023-extend-multiple-2.scss _________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004e10550>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004e10550>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss')
[  570s] source = <SourceFile PosixPath('023-extend-multiple-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004e10550>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004e12710>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f7c710>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bad'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bad'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e12710>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.bad'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004f7ce10>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7e710>
[  570s] expression = 'red !important', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7e710>
[  570s] expr = 'red !important', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7e710>
[  570s] expr = 'red !important', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red !impor' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________ scss/tests/files/original-doctests/024-extend-placeholder.scss ________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400485f990>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400485f990>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss')
[  570s] source = <SourceFile PosixPath('024-extend-placeholder.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400485f990>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400485dd90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004eb7ad0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#context a%extreme'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#context a%extreme'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400485dd90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#context a%extreme'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004eb6b10>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eb6590>, expression = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eb6590>, expr = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004eb6590>, expr = 'blue'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004eb5b50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _____________ scss/tests/files/original-doctests/026-forum-2.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004efe650>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004efe650>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss')
[  570s] source = <SourceFile PosixPath('026-forum-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004efe650>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004efdfd0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004f7d8d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f7fe50>
[  570s] 
[  570s]     def _at_variables(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @variables and @vars
[  570s]         """
[  570s]         warn_deprecated(
[  570s]             rule,
[  570s]             "@variables and @vars are deprecated.  "
[  570s]             "Just assign variables at top-level.")
[  570s]         _rule = rule.copy()
[  570s]         _rule.unparsed_contents = block.unparsed_contents
[  570s]         _rule.namespace = rule.namespace
[  570s]         _rule.properties = []
[  570s] >       self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1023: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004efdfd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f7e290>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s] >               value = calculator.calculate(raw_value, divide=True)
[  570s] 
[  570s] scss/compiler.py:1081: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7f250>
[  570s] expression = 'unquote("*html")', divide = True
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7f250>
[  570s] expr = 'unquote("*html")', divide = True
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f7f250>
[  570s] expr = 'unquote("*html")', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f7db50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'unquote("*' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/028-errors.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004f527d0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f527d0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss')
[  570s] source = <SourceFile PosixPath('028-errors.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f527d0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004f50590>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f50090>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.some-selector'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.some-selector'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f50590>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.some-selector'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e7da50>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e7fcd0>, expression = 'prop'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e7fcd0>, expr = 'prop'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e7fcd0>, expr = 'prop'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e7f4d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'prop' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _____________ scss/tests/files/original-doctests/029-errors-2.scss _____________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400483f850>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400483f850>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss')
[  570s] source = <SourceFile PosixPath('029-errors-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400483f850>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400483ee90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400483d090>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004dd0490>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400483ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.noticeBox'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004dd14d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004dd0050>, expression = 'red'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004dd0050>, expr = 'red'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004dd0050>, expr = 'red'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004dd1210>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'red' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _______________ scss/tests/files/original-doctests/031-test.scss _______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004d33390>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d33390>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss')
[  570s] source = <SourceFile PosixPath('031-test.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d33390>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d33b90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d31350>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d33b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d497d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d4b2d0>
[  570s] expression = 'percent-width(12, 80)', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d4b2d0>
[  570s] expr = 'percent-width(12, 80)', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d4b2d0>
[  570s] expr = 'percent-width(12, 80)', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d49c10>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'percent-wi' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/032-test-2.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004fd3dd0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fd3dd0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss')
[  570s] source = <SourceFile PosixPath('032-test-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fd3dd0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004fd3d10>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004fd2fd0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fd3d10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004fd0110>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s] >               value = calculator.calculate(raw_value, divide=True)
[  570s] 
[  570s] scss/compiler.py:1081: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fd2610>
[  570s] expression = 'rgba(0.872536*255, 0.48481984*255, 0.375464*255, 1)'
[  570s] divide = True
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fd2610>
[  570s] expr = 'rgba(0.872536*255, 0.48481984*255, 0.375464*255, 1)', divide = True
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fd2610>
[  570s] expr = 'rgba(0.872536*255, 0.48481984*255, 0.375464*255, 1)', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fd3cd0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'rgba(0.872' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/033-test-3.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004d49510>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d49510>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss')
[  570s] source = <SourceFile PosixPath('033-test-3.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d49510>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d4b550>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40045f1610>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.functions'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.functions'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d4b550>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.functions'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40045f2910>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40045f2410>
[  570s] expression = 'opacify(rgba(0, 0, 0, 0.5), 0.1)', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40045f2410>
[  570s] expr = 'opacify(rgba(0, 0, 0, 0.5), 0.1)', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40045f2410>
[  570s] expr = 'opacify(rgba(0, 0, 0, 0.5), 0.1)', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40045f11d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'opacify(rg' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/034-test-4.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004db8b10>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004db8b10>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss')
[  570s] source = <SourceFile PosixPath('034-test-4.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004db8b10>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004dba690>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004dbb5d0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.coloredClass'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.coloredClass'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004dba690>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.coloredClass'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004db9950>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s] >               value = calculator.calculate(raw_value, divide=True)
[  570s] 
[  570s] scss/compiler.py:1081: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004db9490>, expression = 'green'
[  570s] divide = True
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004db9490>, expr = 'green'
[  570s] divide = True
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004db9490>, expr = 'green'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004db91d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'green' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/035-test-5.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004f12c10>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f12c10>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss')
[  570s] source = <SourceFile PosixPath('035-test-5.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f12c10>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004f13e50>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40050047d0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>, <Selector: 'button'>)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>, <Selector: 'button'>)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f13e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>, <Selector: 'button'>)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4005005490>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050043d0>, expression = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050043d0>, expr = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050043d0>, expr = 'blue'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005004110>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/036-test-6.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400457fe90>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400457fe90>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400457e110>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss')
[  570s] source = <SourceFile PosixPath('036-test-6.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400457fe90>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400457e110>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400509da90>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a:hover'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a:hover'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400457e110>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a:hover'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400509d9d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c550>
[  570s] expression = 'underline', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c550>, expr = 'underline'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c550>, expr = 'underline'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509e990>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'underline' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/037-test-7.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400474c790>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400474c790>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss')
[  570s] source = <SourceFile PosixPath('037-test-7.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400474c790>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400474ca10>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400474fe90>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400474ca10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004c580d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c588d0>, expression = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c588d0>, expr = 'blue'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c588d0>, expr = 'blue'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004efd610>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/original-doctests/038-test-8.scss ______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004d7f7d0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d7f7d0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004d7c050>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss')
[  570s] source = <SourceFile PosixPath('038-test-8.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d7f7d0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d7c050>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c050>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c050>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d7d710>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d7c910>
[  570s] 
[  570s]     def _at_each(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @each
[  570s]         """
[  570s]         varstring, _, valuestring = block.argument.partition(' in ')
[  570s] >       values = calculator.calculate(valuestring)
[  570s] 
[  570s] scss/compiler.py:960: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d7d710>
[  570s] expression = 'puma, sea-slug, egret, salamander', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d7d710>
[  570s] expr = 'puma, sea-slug, egret, salamander', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d7d710>
[  570s] expr = 'puma, sea-slug, egret, salamander', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7e5d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'puma, sea-' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ___________ scss/tests/files/original-doctests/039-hover-extend.scss ___________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004fc7990>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fc7990>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend.scss')
[  570s] source = <SourceFile PosixPath('039-hover-extend.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fc7990>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004fc73d0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004fc5650>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.comment a.user:hover'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.comment a.user:hover'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fc73d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.comment a.user:hover'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004fc4a50>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fc7190>, expression = 'bold'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fc7190>, expr = 'bold'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004fc7190>, expr = 'bold'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004fc7e10>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'bold' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _____ scss/tests/files/original-doctests/040-complex-sequence-extend.scss ______
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc... 'expanded', 'search_path': [PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004cbed90>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004cbed90>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend.scss')
[  570s] source = <SourceFile PosixPath('040-complex-sequence-extend.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004cbed90>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cbcd50>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40050d0d10>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#admin .tabbar a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#admin .tabbar a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbcd50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#admin .tabbar a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40050d22d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050d2ad0>, expression = 'bold'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050d2ad0>, expr = 'bold'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x40050d2ad0>, expr = 'bold'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x40050d2290>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'bold' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _________________ scss/tests/files/regressions/args-vars.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004c97fd0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004c97fd0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars.scss')
[  570s] source = <SourceFile PosixPath('args-vars.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004c97fd0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c96690>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d63890>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d61c90>
[  570s] 
[  570s]     def _at_function(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @mixin and @function
[  570s]         """
[  570s]         if not block.argument:
[  570s]             raise SyntaxError("%s requires a function name (%s)" % (block.directive, rule.file_and_line))
[  570s]     
[  570s] >       funct, argspec_node = self._get_funct_def(rule, calculator, block.argument)
[  570s] 
[  570s] scss/compiler.py:631: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004c96690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d63890>
[  570s] argument = 'col($color, $background: $color, $border: null)'
[  570s] 
[  570s]     def _get_funct_def(self, rule, calculator, argument):
[  570s]         funct, lpar, argstr = argument.partition('(')
[  570s]         funct = calculator.do_glob_math(funct)
[  570s]         funct = normalize_var(funct.strip())
[  570s]         argstr = argstr.strip()
[  570s]     
[  570s]         # Parse arguments with the argspec rule
[  570s]         if lpar:
[  570s]             if not argstr.endswith(')'):
[  570s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  570s]             argstr = argstr[:-1].strip()
[  570s]         else:
[  570s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  570s]             argstr = ''
[  570s]     
[  570s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  570s] 
[  570s] scss/compiler.py:559: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d63890>
[  570s] expr = '$color, $background: $color, $border: null', target = 'goal_argspec'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def goal_argspec(self):
[  570s] >       argspec = self.argspec()
[  570s] 
[  570s] scss/grammar/expression.py:115: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def argspec(self):
[  570s]         _token_ = self._peek(self.argspec_rsts)
[  570s]         if _token_ not in self.argspec_chks:
[  570s]             if self._peek(self.argspec_rsts_) not in self.argspec_chks_:
[  570s] >               argspec_items = self.argspec_items()
[  570s] 
[  570s] scss/grammar/expression.py:123: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def argspec_items(self):
[  570s]         slurpy = None
[  570s]         argspec_item = self.argspec_item()
[  570s]         args = [argspec_item]
[  570s]         if self._peek(self.argspec_items_rsts) == '","':
[  570s]             self._scan('","')
[  570s]             if self._peek(self.argspec_items_rsts_) not in self.argspec_chks_:
[  570s]                 _token_ = self._peek(self.argspec_items_rsts__)
[  570s]                 if _token_ == 'SLURPYVAR':
[  570s]                     SLURPYVAR = self._scan('SLURPYVAR')
[  570s]                     DOTDOTDOT = self._scan('DOTDOTDOT')
[  570s]                     slurpy = SLURPYVAR
[  570s]                 elif _token_ == 'DOTDOTDOT':
[  570s]                     DOTDOTDOT = self._scan('DOTDOTDOT')
[  570s]                     slurpy = all
[  570s]                 else:  # in self.argspec_items_chks
[  570s] >                   argspec_items = self.argspec_items()
[  570s] 
[  570s] scss/grammar/expression.py:151: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def argspec_items(self):
[  570s]         slurpy = None
[  570s]         argspec_item = self.argspec_item()
[  570s]         args = [argspec_item]
[  570s]         if self._peek(self.argspec_items_rsts) == '","':
[  570s]             self._scan('","')
[  570s]             if self._peek(self.argspec_items_rsts_) not in self.argspec_chks_:
[  570s]                 _token_ = self._peek(self.argspec_items_rsts__)
[  570s]                 if _token_ == 'SLURPYVAR':
[  570s]                     SLURPYVAR = self._scan('SLURPYVAR')
[  570s]                     DOTDOTDOT = self._scan('DOTDOTDOT')
[  570s]                     slurpy = SLURPYVAR
[  570s]                 elif _token_ == 'DOTDOTDOT':
[  570s]                     DOTDOTDOT = self._scan('DOTDOTDOT')
[  570s]                     slurpy = all
[  570s]                 else:  # in self.argspec_items_chks
[  570s] >                   argspec_items = self.argspec_items()
[  570s] 
[  570s] scss/grammar/expression.py:151: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def argspec_items(self):
[  570s]         slurpy = None
[  570s] >       argspec_item = self.argspec_item()
[  570s] 
[  570s] scss/grammar/expression.py:137: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def argspec_item(self):
[  570s]         _token_ = self._peek(self.argspec_items_chks)
[  570s]         if _token_ == 'KWVAR':
[  570s]             KWVAR = self._scan('KWVAR')
[  570s]             self._scan('":"')
[  570s] >           expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:161: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d62810>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  VAR  =  '$color'
[  570s]   (@6)  ","  =  ','
[  570s]   (@8)  KWVAR  =  '$background'
[  570s]   (@19)  ":"  =  ':'
[  570s]   (@21)  VAR  =  '$color'
[  570s]   (@27)  ","  =  ','
[  570s]   (@29)  KWVAR  =  '$border'
[  570s]   (@36)  ":"  =  ':'
[  570s] i = 8
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  VAR  =  '$color'
[  570s]   (@6)  ","  =  ','
[  570s]   (@8)  KWVAR  =  '$background'
[  570s]   (@19)  ":"  =  ':'
[  570s]   (@21)  VAR  =  '$color'
[  570s]   (@27)  ","  =  ','
[  570s]   (@29)  KWVAR  =  '$border'
[  570s]   (@36)  ":"  =  ':'
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error after 'd: $color, $border: ': Found 'null' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _________ scss/tests/files/regressions/argspec-default-arguments.scss __________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004d7d1d0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d7d1d0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments.scss')
[  570s] source = <SourceFile PosixPath('argspec-default-arguments.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004d7d1d0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004d7c250>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d7d690>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d7d4d0>
[  570s] 
[  570s]     def _at_function(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @mixin and @function
[  570s]         """
[  570s]         if not block.argument:
[  570s]             raise SyntaxError("%s requires a function name (%s)" % (block.directive, rule.file_and_line))
[  570s]     
[  570s] >       funct, argspec_node = self._get_funct_def(rule, calculator, block.argument)
[  570s] 
[  570s] scss/compiler.py:631: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004d7c250>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d7d690>
[  570s] argument = 'color-me($color: white)'
[  570s] 
[  570s]     def _get_funct_def(self, rule, calculator, argument):
[  570s]         funct, lpar, argstr = argument.partition('(')
[  570s]         funct = calculator.do_glob_math(funct)
[  570s]         funct = normalize_var(funct.strip())
[  570s]         argstr = argstr.strip()
[  570s]     
[  570s]         # Parse arguments with the argspec rule
[  570s]         if lpar:
[  570s]             if not argstr.endswith(')'):
[  570s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  570s]             argstr = argstr[:-1].strip()
[  570s]         else:
[  570s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  570s]             argstr = ''
[  570s]     
[  570s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  570s] 
[  570s] scss/compiler.py:559: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004d7d690>
[  570s] expr = '$color: white', target = 'goal_argspec'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def goal_argspec(self):
[  570s] >       argspec = self.argspec()
[  570s] 
[  570s] scss/grammar/expression.py:115: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def argspec(self):
[  570s]         _token_ = self._peek(self.argspec_rsts)
[  570s]         if _token_ not in self.argspec_chks:
[  570s]             if self._peek(self.argspec_rsts_) not in self.argspec_chks_:
[  570s] >               argspec_items = self.argspec_items()
[  570s] 
[  570s] scss/grammar/expression.py:123: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def argspec_items(self):
[  570s]         slurpy = None
[  570s] >       argspec_item = self.argspec_item()
[  570s] 
[  570s] scss/grammar/expression.py:137: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def argspec_item(self):
[  570s]         _token_ = self._peek(self.argspec_items_chks)
[  570s]         if _token_ == 'KWVAR':
[  570s]             KWVAR = self._scan('KWVAR')
[  570s]             self._scan('":"')
[  570s] >           expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:161: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004d7f650>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  KWVAR  =  '$color'
[  570s]   (@6)  ":"  =  ':', i = 2
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  KWVAR  =  '$color'
[  570s]   (@6)  ":"  =  ':'
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error after '$color: ': Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ____________ scss/tests/files/regressions/argspec-no-arguments.scss ____________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004cbcb10>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004cbcb10>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments.scss')
[  570s] source = <SourceFile PosixPath('argspec-no-arguments.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004cbcb10>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cbe850>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f28c50>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cbe850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004f2abd0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f2b210>
[  570s] expression = 'get-a-number()', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f2b210>
[  570s] expr = 'get-a-number()', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f2b210>
[  570s] expr = 'get-a-number()', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f2bb10>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'get-a-numb' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ___________ scss/tests/files/regressions/argspec-trailing-comma.scss ___________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004921910>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004921910>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma.scss')
[  570s] source = <SourceFile PosixPath('argspec-trailing-comma.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004921910>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40049237d0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004ff3350>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40049237d0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'div'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ff2250>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ff2a90>
[  570s] expression = 'no-op(100px)', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ff2a90>
[  570s] expr = 'no-op(100px)', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ff2a90>
[  570s] expr = 'no-op(100px)', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ff0310>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'no-op(100p' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ______________ scss/tests/files/regressions/interpolation-2.scss _______________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4005033750>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005033750>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss')
[  570s] source = <SourceFile PosixPath('interpolation-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005033750>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4005030b90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005032290>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] calculator = <scss.calculator.Calculator object at 0x4005030a10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4005031d50>
[  570s] 
[  570s]     def _at_each(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @each
[  570s]         """
[  570s]         varstring, _, valuestring = block.argument.partition(' in ')
[  570s]         values = calculator.calculate(valuestring)
[  570s]         if not values:
[  570s]             return
[  570s]     
[  570s]         varlist = [
[  570s]             normalize_var(calculator.do_glob_math(var.strip()))
[  570s]             # TODO use list parsing here
[  570s]             for var in varstring.split(",")
[  570s]         ]
[  570s]     
[  570s]         # `@each $foo, in $bar` unpacks, but `@each $foo in $bar` does not!
[  570s]         unpack = len(varlist) > 1
[  570s]         if not varlist[-1]:
[  570s]             varlist.pop()
[  570s]     
[  570s]         inner_rule = rule.copy()
[  570s]         inner_rule.unparsed_contents = block.unparsed_contents
[  570s]         if not self.should_scope_loop_in_rule(inner_rule):
[  570s]             # DEVIATION: Allow not creating a new namespace
[  570s]             inner_rule.namespace = rule.namespace
[  570s]     
[  570s]         for v in List.from_maybe(values):
[  570s]             if unpack:
[  570s]                 v = List.from_maybe(v)
[  570s]                 for i, var in enumerate(varlist):
[  570s]                     if i >= len(v):
[  570s]                         value = Null()
[  570s]                     else:
[  570s]                         value = v[i]
[  570s]                     inner_rule.namespace.set_variable(var, value)
[  570s]             else:
[  570s]                 inner_rule.namespace.set_variable(varlist[0], v)
[  570s] >           self.manage_children(inner_rule, scope)
[  570s] 
[  570s] scss/compiler.py:992: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d60d50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d60ed0>
[  570s] 
[  570s]     def _at_each(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @each
[  570s]         """
[  570s]         varstring, _, valuestring = block.argument.partition(' in ')
[  570s]         values = calculator.calculate(valuestring)
[  570s]         if not values:
[  570s]             return
[  570s]     
[  570s]         varlist = [
[  570s]             normalize_var(calculator.do_glob_math(var.strip()))
[  570s]             # TODO use list parsing here
[  570s]             for var in varstring.split(",")
[  570s]         ]
[  570s]     
[  570s]         # `@each $foo, in $bar` unpacks, but `@each $foo in $bar` does not!
[  570s]         unpack = len(varlist) > 1
[  570s]         if not varlist[-1]:
[  570s]             varlist.pop()
[  570s]     
[  570s]         inner_rule = rule.copy()
[  570s]         inner_rule.unparsed_contents = block.unparsed_contents
[  570s]         if not self.should_scope_loop_in_rule(inner_rule):
[  570s]             # DEVIATION: Allow not creating a new namespace
[  570s]             inner_rule.namespace = rule.namespace
[  570s]     
[  570s]         for v in List.from_maybe(values):
[  570s]             if unpack:
[  570s]                 v = List.from_maybe(v)
[  570s]                 for i, var in enumerate(varlist):
[  570s]                     if i >= len(v):
[  570s]                         value = Null()
[  570s]                     else:
[  570s]                         value = v[i]
[  570s]                     inner_rule.namespace.set_variable(var, value)
[  570s]             else:
[  570s]                 inner_rule.namespace.set_variable(varlist[0], v)
[  570s] >           self.manage_children(inner_rule, scope)
[  570s] 
[  570s] scss/compiler.py:992: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d62310>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d61b50>
[  570s] 
[  570s]     def _at_each(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @each
[  570s]         """
[  570s]         varstring, _, valuestring = block.argument.partition(' in ')
[  570s]         values = calculator.calculate(valuestring)
[  570s]         if not values:
[  570s]             return
[  570s]     
[  570s]         varlist = [
[  570s]             normalize_var(calculator.do_glob_math(var.strip()))
[  570s]             # TODO use list parsing here
[  570s]             for var in varstring.split(",")
[  570s]         ]
[  570s]     
[  570s]         # `@each $foo, in $bar` unpacks, but `@each $foo in $bar` does not!
[  570s]         unpack = len(varlist) > 1
[  570s]         if not varlist[-1]:
[  570s]             varlist.pop()
[  570s]     
[  570s]         inner_rule = rule.copy()
[  570s]         inner_rule.unparsed_contents = block.unparsed_contents
[  570s]         if not self.should_scope_loop_in_rule(inner_rule):
[  570s]             # DEVIATION: Allow not creating a new namespace
[  570s]             inner_rule.namespace = rule.namespace
[  570s]     
[  570s]         for v in List.from_maybe(values):
[  570s]             if unpack:
[  570s]                 v = List.from_maybe(v)
[  570s]                 for i, var in enumerate(varlist):
[  570s]                     if i >= len(v):
[  570s]                         value = Null()
[  570s]                     else:
[  570s]                         value = v[i]
[  570s]                     inner_rule.namespace.set_variable(var, value)
[  570s]             else:
[  570s]                 inner_rule.namespace.set_variable(varlist[0], v)
[  570s] >           self.manage_children(inner_rule, scope)
[  570s] 
[  570s] scss/compiler.py:992: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005030b90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d62ad0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c96090>
[  570s] expression = 'X#{$a}#{$b}#{$c}', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c96090>
[  570s] expr = 'X#{$a}#{$b}#{$c}', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004c96090>
[  570s] expr = 'X#{$a}#{$b}#{$c}', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004c96550>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'X#{$a}#{$b' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _______________ scss/tests/files/regressions/interpolation.scss ________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400509eb90>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400509eb90>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss')
[  570s] source = <SourceFile PosixPath('interpolation.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400509eb90>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400509ff10>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400509c910>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 3 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 3 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400509ff10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 3 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400509f450>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c710>
[  570s] expression = '#{$a}#{$b}#{$x}#{$c}', divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c710>
[  570s] expr = '#{$a}#{$b}#{$x}#{$c}', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400509c710>
[  570s] expr = '#{$a}#{$b}#{$x}#{$c}', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def not_expr(self):
[  570s]         _token_ = self._peek(self.argspec_item_chks)
[  570s]         if _token_ != 'NOT':
[  570s] >           comparison = self.comparison()
[  570s] 
[  570s] scss/grammar/expression.py:236: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def comparison(self):
[  570s] >       a_expr = self.a_expr()
[  570s] 
[  570s] scss/grammar/expression.py:244: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def a_expr(self):
[  570s] >       m_expr = self.m_expr()
[  570s] 
[  570s] scss/grammar/expression.py:275: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def m_expr(self):
[  570s] >       u_expr = self.u_expr()
[  570s] 
[  570s] scss/grammar/expression.py:290: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def u_expr(self):
[  570s]         _token_ = self._peek(self.u_expr_rsts)
[  570s]         if _token_ == 'SIGN':
[  570s]             SIGN = self._scan('SIGN')
[  570s]             u_expr = self.u_expr()
[  570s]             return UnaryOp(operator.neg, u_expr)
[  570s]         elif _token_ == 'ADD':
[  570s]             ADD = self._scan('ADD')
[  570s]             u_expr = self.u_expr()
[  570s]             return UnaryOp(operator.pos, u_expr)
[  570s]         else:  # in self.u_expr_chks
[  570s] >           atom = self.atom()
[  570s] 
[  570s] scss/grammar/expression.py:319: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def atom(self):
[  570s]         _token_ = self._peek(self.u_expr_chks)
[  570s]         if _token_ == 'LPAR':
[  570s]             LPAR = self._scan('LPAR')
[  570s]             _token_ = self._peek(self.atom_rsts)
[  570s]             if _token_ == 'RPAR':
[  570s]                 v = ListLiteral([], comma=False)
[  570s]             else:  # in self.argspec_item_chks
[  570s]                 expr_map_or_list = self.expr_map_or_list()
[  570s]                 v = expr_map_or_list
[  570s]             RPAR = self._scan('RPAR')
[  570s]             return Parentheses(v)
[  570s]         elif _token_ == 'URL_FUNCTION':
[  570s]             URL_FUNCTION = self._scan('URL_FUNCTION')
[  570s]             LPAR = self._scan('LPAR')
[  570s]             interpolated_url = self.interpolated_url()
[  570s]             RPAR = self._scan('RPAR')
[  570s]             return interpolated_url
[  570s]         elif _token_ == 'ALPHA_FUNCTION':
[  570s]             ALPHA_FUNCTION = self._scan('ALPHA_FUNCTION')
[  570s]             LPAR = self._scan('LPAR')
[  570s]             _token_ = self._peek(self.atom_rsts_)
[  570s]             if _token_ == 'OPACITY':
[  570s]                 OPACITY = self._scan('OPACITY')
[  570s]                 self._scan('"="')
[  570s]                 atom = self.atom()
[  570s]                 RPAR = self._scan('RPAR')
[  570s]                 return AlphaFunctionLiteral(atom)
[  570s]             else:  # in self.atom_chks
[  570s]                 argspec = self.argspec()
[  570s]                 RPAR = self._scan('RPAR')
[  570s]                 return CallOp("alpha", argspec)
[  570s]         elif _token_ == 'IF_FUNCTION':
[  570s]             IF_FUNCTION = self._scan('IF_FUNCTION')
[  570s]             LPAR = self._scan('LPAR')
[  570s]             expr_lst = self.expr_lst()
[  570s]             RPAR = self._scan('RPAR')
[  570s]             return TernaryOp(expr_lst)
[  570s]         elif _token_ == 'LITERAL_FUNCTION':
[  570s]             LITERAL_FUNCTION = self._scan('LITERAL_FUNCTION')
[  570s]             LPAR = self._scan('LPAR')
[  570s]             interpolated_function = self.interpolated_function()
[  570s]             RPAR = self._scan('RPAR')
[  570s]             return Interpolation.maybe(interpolated_function, type=Function, function_name=LITERAL_FUNCTION)
[  570s]         elif _token_ == 'FNCT':
[  570s]             FNCT = self._scan('FNCT')
[  570s]             LPAR = self._scan('LPAR')
[  570s]             argspec = self.argspec()
[  570s]             RPAR = self._scan('RPAR')
[  570s]             return CallOp(FNCT, argspec)
[  570s]         elif _token_ == 'BANG_IMPORTANT':
[  570s]             BANG_IMPORTANT = self._scan('BANG_IMPORTANT')
[  570s]             return Literal(String.unquoted("!important", literal=True))
[  570s]         elif _token_ in self.atom_chks_:
[  570s] >           interpolated_bareword = self.interpolated_bareword()
[  570s] 
[  570s] scss/grammar/expression.py:376: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def interpolated_bareword(self):
[  570s]         _token_ = self._peek(self.atom_chks_)
[  570s]         if _token_ == 'BAREWORD':
[  570s]             BAREWORD = self._scan('BAREWORD')
[  570s]             parts = [BAREWORD]
[  570s]             if self._peek(self.interpolated_bareword_rsts) == 'SPACE':
[  570s]                 SPACE = self._scan('SPACE')
[  570s]                 return parts
[  570s]         else:  # == 'INTERP_START'
[  570s] >           interpolation = self.interpolation()
[  570s] 
[  570s] scss/grammar/expression.py:473: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def interpolation(self):
[  570s]         INTERP_START = self._scan('INTERP_START')
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:396: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def not_expr(self):
[  570s]         _token_ = self._peek(self.argspec_item_chks)
[  570s]         if _token_ != 'NOT':
[  570s] >           comparison = self.comparison()
[  570s] 
[  570s] scss/grammar/expression.py:236: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def comparison(self):
[  570s] >       a_expr = self.a_expr()
[  570s] 
[  570s] scss/grammar/expression.py:244: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def a_expr(self):
[  570s] >       m_expr = self.m_expr()
[  570s] 
[  570s] scss/grammar/expression.py:275: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] 
[  570s]     def m_expr(self):
[  570s]         u_expr = self.u_expr()
[  570s]         v = u_expr
[  570s] >       while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  570s] 
[  570s] scss/grammar/expression.py:292: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400509da10>
[  570s] types = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  INTERP_START  =  '#{'
[  570s]   (@2)  VAR  =  '$a', i = 2
[  570s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s]   (@0)  INTERP_START  =  '#{'
[  570s]   (@2)  VAR  =  '$a'
[  570s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error after '#{$a': Found '}#{$b}#{$x' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] __________________ scss/tests/files/regressions/issue-10.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004ccb110>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004ccb110>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss')
[  570s] source = <SourceFile PosixPath('issue-10.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004ccb110>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004cca950>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005106a10>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.yellow'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.yellow'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004cca950>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '.yellow'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40051065d0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005105e90>, expression = 'yelow'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005105e90>, expr = 'yelow'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005105e90>, expr = 'yelow'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106610>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'yelow' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _________________ scss/tests/files/regressions/issue-110.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004f882d0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f882d0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004f888d0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss')
[  570s] source = <SourceFile PosixPath('issue-110.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004f882d0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004f888d0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f888d0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f888d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f888d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004f888d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004f8ae50>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s] >               value = calculator.calculate(raw_value, divide=True)
[  570s] 
[  570s] scss/compiler.py:1081: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f89990>, expression = 'blue'
[  570s] divide = True
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f89990>, expr = 'blue'
[  570s] divide = True
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004f89990>, expr = 'blue'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004f89050>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'blue' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] __________________ scss/tests/files/regressions/issue-2.scss ___________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4005171550>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005171550>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x40051725d0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss')
[  570s] source = <SourceFile PosixPath('issue-2.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005171550>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40051725d0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40051725d0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40051725d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40051725d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40051725d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40045c0450>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s] >       raw_selectors = calculator.do_glob_math(block.prop)
[  570s] 
[  570s] scss/compiler.py:1171: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005173b10>
[  570s] cont = '#{enumerate(".pull", 1, 24)}'
[  570s] 
[  570s]     def do_glob_math(self, cont):
[  570s]         """Performs #{}-interpolation.  The result is always treated as a fixed
[  570s]         syntactic unit and will not be re-evaluated.
[  570s]         """
[  570s]         # TODO that's a lie!  this should be in the parser for most cases.
[  570s]         if not isinstance(cont, six.string_types):
[  570s]             warn(FutureWarning(
[  570s]                 "do_glob_math was passed a non-string {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(cont)
[  570s]             ))
[  570s]             cont = six.text_type(cont)
[  570s]         if '#{' not in cont:
[  570s]             return cont
[  570s] >       cont = _expr_glob_re.sub(self._pound_substitute, cont)
[  570s] 
[  570s] scss/calculator.py:67: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005173b10>
[  570s] result = <re.Match object; span=(0, 28), match='#{enumerate(".pull", 1, 24)}'>
[  570s] 
[  570s]     def _pound_substitute(self, result):
[  570s]         expr = result.group(1)
[  570s] >       value = self.evaluate_expression(expr)
[  570s] 
[  570s] scss/calculator.py:44: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005173b10>
[  570s] expr = 'enumerate(".pull", 1, 24)', divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005173b10>
[  570s] expr = 'enumerate(".pull", 1, 24)', target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005172a50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'enumerate(' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] __________________ scss/tests/files/regressions/issue-21.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4005007d50>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005007d50>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss')
[  570s] source = <SourceFile PosixPath('issue-21.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4005007d50>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4005007e50>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005005850>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h2'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h2'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4005007e50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h2'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400517d890>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517db90>, expression = 'green'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517db90>, expr = 'green'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517db90>, expr = 'green'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517d6d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'green' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] _________________ scss/tests/files/regressions/issue-258.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004e8d650>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004e8d650>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258.scss')
[  570s] source = <SourceFile PosixPath('issue-258.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004e8d650>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004e8d050>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] calculator = <scss.calculator.Calculator object at 0x4005077090>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40050777d0>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005075fd0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#A'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#A'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] calculator = <scss.calculator.Calculator object at 0x4005077a10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#A'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x40050742d0>
[  570s] 
[  570s]     def _at_include(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @include, for @mixins
[  570s]         """
[  570s]         caller_namespace = rule.namespace
[  570s]         caller_calculator = self._make_calculator(caller_namespace)
[  570s] >       funct, caller_argspec = self._get_funct_def(rule, caller_calculator, block.argument)
[  570s] 
[  570s] scss/compiler.py:718: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8d050>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: '#A'>,)>,)>, 0 props>
[  570s] calculator = <scss.calculator.Calculator object at 0x4005075690>
[  570s] argument = 'min-screen(anything)'
[  570s] 
[  570s]     def _get_funct_def(self, rule, calculator, argument):
[  570s]         funct, lpar, argstr = argument.partition('(')
[  570s]         funct = calculator.do_glob_math(funct)
[  570s]         funct = normalize_var(funct.strip())
[  570s]         argstr = argstr.strip()
[  570s]     
[  570s]         # Parse arguments with the argspec rule
[  570s]         if lpar:
[  570s]             if not argstr.endswith(')'):
[  570s]                 raise SyntaxError("Expected ')', found end of line for %s (%s)" % (funct, rule.file_and_line))
[  570s]             argstr = argstr[:-1].strip()
[  570s]         else:
[  570s]             # Whoops, no parens at all.  That's like calling with no arguments.
[  570s]             argstr = ''
[  570s]     
[  570s] >       argspec_node = calculator.parse_expression(argstr, target='goal_argspec')
[  570s] 
[  570s] scss/compiler.py:559: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005075690>, expr = 'anything'
[  570s] target = 'goal_argspec'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005075f50>
[  570s] 
[  570s]     def goal_argspec(self):
[  570s] >       argspec = self.argspec()
[  570s] 
[  570s] scss/grammar/expression.py:115: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005075f50>
[  570s] 
[  570s]     def argspec(self):
[  570s] >       _token_ = self._peek(self.argspec_rsts)
[  570s] 
[  570s] scss/grammar/expression.py:120: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005075f50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOTDOTDOT', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'anything' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOTDOTDOT, DOUBLE_QUOTE, END, FNCT, IF_FUNCTION, INTERP_START, KWVAR, LITERAL_FUNCTION, LPAR, NOT, NUM, RPAR, SIGN, SINGLE_QUOTE, SLURPYVAR, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-a.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x40046c1bd0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x40046c1bd0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a.scss')
[  570s] source = <SourceFile PosixPath('issue-334-a.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x40046c1bd0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004e8cb90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004d6e710>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d6e610>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004d6e290>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004e8cb90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400517e150>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517e690>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517e690>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400517e690>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400517c510>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-b.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004eb4250>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004eb4250>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b.scss')
[  570s] source = <SourceFile PosixPath('issue-334-b.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004eb4250>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004eb4a50>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004eb7c50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004eb79d0>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004e6ba50>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004eb4a50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004e6a610>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e69f10>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e69f10>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004e69f10>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004e68cd0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-c.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400519d1d0>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400519d1d0>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c.scss')
[  570s] source = <SourceFile PosixPath('issue-334-c.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400519d1d0>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400519dc50>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] calculator = <scss.calculator.Calculator object at 0x400519f390>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400519ed90>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400519d990>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519dc50>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400519c090>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519dfd0>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519dfd0>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519dfd0>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519e310>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-d.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004b18c50>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004b18c50>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d.scss')
[  570s] source = <SourceFile PosixPath('issue-334-d.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004b18c50>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x40045f3b10>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] calculator = <scss.calculator.Calculator object at 0x4005105b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005104550>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4005106650>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x40045f3b10>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4005105c10>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005107250>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005107250>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4005107250>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4005106390>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-e.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400489d310>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400489d310>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400489d850>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e.scss')
[  570s] source = <SourceFile PosixPath('issue-334-e.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400489d310>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400489d850>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] calculator = <scss.calculator.Calculator object at 0x400489f1d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400489e9d0>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x400480e390>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400489d850>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400480cad0>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400480fe50>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400480fe50>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400480fe50>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400480f050>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-f.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004ca0150>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004ca0150>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f.scss')
[  570s] source = <SourceFile PosixPath('issue-334-f.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004ca0150>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004ca1cd0>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004ca30d0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004ca1450>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004ca38d0>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004ca1cd0>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004ca3150>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ca0d10>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ca0d10>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ca0d10>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ca1ad0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-g.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004fb0e10>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fb0e10>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g.scss')
[  570s] source = <SourceFile PosixPath('issue-334-g.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004fb0e10>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004fb0410>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] calculator = <scss.calculator.Calculator object at 0x4004fb3810>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004fb30d0>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x4004920410>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004fb0410>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400455ad90>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519ea90>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519ea90>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x400519ea90>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x400519c7d0>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] ________________ scss/tests/files/regressions/issue-334-h.scss _________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x4004a6fb10>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004a6fb10>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h.scss')
[  570s] source = <SourceFile PosixPath('issue-334-h.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x4004a6fb10>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004a6ee90>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s] >                   method(calculator, rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:378: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] calculator = <scss.calculator.Calculator object at 0x40047abf50>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40047aa210>
[  570s] 
[  570s]     def _at_import(self, calculator, rule, scope, block):
[  570s]         """
[  570s]         Implements @import
[  570s]         Load and import mixins and functions and rules
[  570s]         """
[  570s]         # TODO it would be neat to opt into warning that you're using
[  570s]         # values/functions from a file you didn't explicitly import
[  570s]         # TODO base-level directives, like @mixin or @charset, aren't allowed
[  570s]         # to be @imported into a nested block
[  570s]         # TODO i'm not sure we disallow them nested in the first place
[  570s]         # TODO @import is disallowed within mixins, control directives
[  570s]         # TODO @import doesn't take a block -- that's probably an issue with a
[  570s]         # lot of our directives
[  570s]     
[  570s]         # TODO if there's any #{}-interpolation in the AST, this should become
[  570s]         # a CSS import (though in practice Ruby only even evaluates it in url()
[  570s]         # -- in a string it's literal!)
[  570s]     
[  570s]         sass_paths = calculator.evaluate_expression(block.argument)
[  570s]         css_imports = []
[  570s]     
[  570s]         for sass_path in sass_paths:
[  570s]             # These are the rules for when an @import is interpreted as a CSS
[  570s]             # import:
[  570s]             if (
[  570s]                     # If it's a url()
[  570s]                     isinstance(sass_path, Url) or
[  570s]                     # If it's not a string (including `"foo" screen`, a List)
[  570s]                     not isinstance(sass_path, String) or
[  570s]                     # If the filename begins with an http protocol
[  570s]                     sass_path.value.startswith(('http://', 'https://')) or
[  570s]                     # If the filename ends with .css
[  570s]                     sass_path.value.endswith(self.compiler.static_extensions)):
[  570s]                 css_imports.append(sass_path.render(compress=False))
[  570s]                 continue
[  570s]     
[  570s]             # Should be left with a plain String
[  570s]             name = sass_path.value
[  570s]     
[  570s]             source = None
[  570s]             for extension in self.compiler.extensions:
[  570s]                 source = extension.handle_import(name, self, rule)
[  570s]                 if source:
[  570s]                     break
[  570s]             else:
[  570s]                 # Didn't find anything!
[  570s]                 raise SassImportError(name, self.compiler, rule=rule)
[  570s]     
[  570s]             source = self.add_source(source)
[  570s]     
[  570s]             if rule.namespace.has_import(source):
[  570s]                 # If already imported in this scope, skip
[  570s]                 # TODO this might not be right -- consider if you @import a
[  570s]                 # file at top level, then @import it inside a selector block!
[  570s]                 continue
[  570s]     
[  570s]             _rule = SassRule(
[  570s]                 source_file=source,
[  570s]                 lineno=block.lineno,
[  570s]                 unparsed_contents=source.contents,
[  570s]     
[  570s]                 # rule
[  570s]                 legacy_compiler_options=rule.legacy_compiler_options,
[  570s]                 options=rule.options,
[  570s]                 properties=rule.properties,
[  570s]                 extends_selectors=rule.extends_selectors,
[  570s]                 ancestry=rule.ancestry,
[  570s]                 namespace=rule.namespace,
[  570s]             )
[  570s]             rule.namespace.add_import(source, rule)
[  570s] >           self.manage_children(_rule, scope)
[  570s] 
[  570s] scss/compiler.py:861: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] block = <scss.rule.UnparsedBlock object at 0x40047aa390>
[  570s] 
[  570s]     def _nest_rules(self, rule, scope, block):
[  570s]         """
[  570s]         Implements Nested CSS rules
[  570s]         """
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         raw_selectors = calculator.do_glob_math(block.prop)
[  570s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  570s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  570s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  570s]         if c_parents:
[  570s]             warn_deprecated(
[  570s]                 rule,
[  570s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  570s]                 "Use 'a { @extend b; }' instead."
[  570s]             )
[  570s]     
[  570s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  570s]     
[  570s]         rule.descendants += 1
[  570s]         new_rule = SassRule(
[  570s]             source_file=rule.source_file,
[  570s]             import_key=rule.import_key,
[  570s]             lineno=block.lineno,
[  570s]             num_header_lines=block.header.num_lines,
[  570s]             unparsed_contents=block.unparsed_contents,
[  570s]     
[  570s]             legacy_compiler_options=rule.legacy_compiler_options,
[  570s]             options=rule.options.copy(),
[  570s]             #properties
[  570s]             extends_selectors=c_parents,
[  570s]             ancestry=new_ancestry,
[  570s]     
[  570s]             namespace=rule.namespace.derive(),
[  570s]             nested=rule.nested + 1,
[  570s]         )
[  570s]         self.rules.append(new_rule)
[  570s]         rule.namespace.use_import(rule.source_file)
[  570s] >       self.manage_children(new_rule, scope)
[  570s] 
[  570s] scss/compiler.py:1203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s] >               self._get_properties(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:383: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x4004a6ee90>
[  570s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  570s] scope = None, block = <scss.rule.UnparsedBlock object at 0x400484ef10>
[  570s] 
[  570s]     def _get_properties(self, rule, scope, block):
[  570s]         """
[  570s]         Implements properties and variables extraction and assignment
[  570s]         """
[  570s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  570s]         if raw_value is not None:
[  570s]             raw_value = raw_value.strip()
[  570s]     
[  570s]         try:
[  570s]             is_var = (block.prop[len(prop)] == '=')
[  570s]         except IndexError:
[  570s]             is_var = False
[  570s]         if is_var:
[  570s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]         prop = prop.strip()
[  570s]         prop = calculator.do_glob_math(prop)
[  570s]         if not prop:
[  570s]             return
[  570s]     
[  570s]         _prop = (scope or '') + prop
[  570s]         if is_var or prop.startswith('$') and raw_value is not None:
[  570s]             # Pop off any flags: !default, !global
[  570s]             is_default = False
[  570s]             is_global = True  # eventually sass will default this to false
[  570s]             while True:
[  570s]                 splits = raw_value.rsplit(None, 1)
[  570s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  570s]                     break
[  570s]     
[  570s]                 raw_value, flag = splits
[  570s]                 if flag == '!default':
[  570s]                     is_default = True
[  570s]                 elif flag == '!global':
[  570s]                     is_global = True
[  570s]                 else:
[  570s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  570s]     
[  570s]             # Variable assignment
[  570s]             _prop = normalize_var(_prop)
[  570s]             try:
[  570s]                 existing_value = rule.namespace.variable(_prop)
[  570s]             except KeyError:
[  570s]                 existing_value = None
[  570s]     
[  570s]             is_defined = existing_value is not None and not existing_value.is_null
[  570s]             if is_default and is_defined:
[  570s]                 pass
[  570s]             else:
[  570s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  570s]                     log.warn("Constant %r redefined", prop)
[  570s]     
[  570s]                 # Variable assignment is an expression, so it always performs
[  570s]                 # real division
[  570s]                 value = calculator.calculate(raw_value, divide=True)
[  570s]                 rule.namespace.set_variable(
[  570s]                     _prop, value, local_only=not is_global)
[  570s]         else:
[  570s]             # Regular property destined for output
[  570s]             _prop = calculator.apply_vars(_prop)
[  570s]             if raw_value is None:
[  570s]                 value = None
[  570s]             else:
[  570s] >               value = calculator.calculate(raw_value)
[  570s] 
[  570s] scss/compiler.py:1090: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ea6810>, expression = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def calculate(self, expression, divide=False):
[  570s] >       result = self.evaluate_expression(expression, divide=divide)
[  570s] 
[  570s] scss/calculator.py:116: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ea6810>, expr = 'white'
[  570s] divide = False
[  570s] 
[  570s]     def evaluate_expression(self, expr, divide=False):
[  570s]         try:
[  570s] >           ast = self.parse_expression(expr)
[  570s] 
[  570s] scss/calculator.py:134: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.calculator.Calculator object at 0x4004ea6810>, expr = 'white'
[  570s] target = 'goal'
[  570s] 
[  570s]     def parse_expression(self, expr, target='goal'):
[  570s]         if isinstance(expr, six.text_type):
[  570s]             # OK
[  570s]             pass
[  570s]         elif isinstance(expr, six.binary_type):
[  570s]             # Dubious
[  570s]             warn(FutureWarning(
[  570s]                 "parse_expression was passed binary data {0!r} "
[  570s]                 "-- this will no longer be supported in pyScss 2.0"
[  570s]                 .format(expr)
[  570s]             ))
[  570s]             # Don't guess an encoding; you reap what you sow
[  570s]             expr = six.text_type(expr)
[  570s]         else:
[  570s]             raise TypeError("Expected string, got %r" % (expr,))
[  570s]     
[  570s]         key = (target, expr)
[  570s]         if key in self.ast_cache:
[  570s]             return self.ast_cache[key]
[  570s]     
[  570s]         try:
[  570s]             parser = SassExpression(SassExpressionScanner(expr))
[  570s] >           ast = getattr(parser, target)()
[  570s] 
[  570s] scss/calculator.py:167: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def goal(self):
[  570s] >       expr_lst = self.expr_lst()
[  570s] 
[  570s] scss/grammar/expression.py:110: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def expr_lst(self):
[  570s] >       expr_slst = self.expr_slst()
[  570s] 
[  570s] scss/grammar/expression.py:199: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def expr_slst(self):
[  570s] >       or_expr = self.or_expr()
[  570s] 
[  570s] scss/grammar/expression.py:208: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def or_expr(self):
[  570s] >       and_expr = self.and_expr()
[  570s] 
[  570s] scss/grammar/expression.py:216: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def and_expr(self):
[  570s] >       not_expr = self.not_expr()
[  570s] 
[  570s] scss/grammar/expression.py:225: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] 
[  570s]     def not_expr(self):
[  570s] >       _token_ = self._peek(self.argspec_item_chks)
[  570s] 
[  570s] scss/grammar/expression.py:234: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.grammar.expression.SassExpression object at 0x4004ea6c50>
[  570s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _peek(self, types):
[  570s]         """
[  570s]         Returns the token type for lookahead; if there are any args
[  570s]         then the list of args is the set of token types to allow
[  570s]         """
[  570s] >       tok = self._scanner.token(self._pos, types)
[  570s] 
[  570s] scss/grammar/scanner.py:141: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = , i = 0
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def token(self, i, restrict=None):
[  570s]         """
[  570s]         Get the i'th token, and if i is one past the end, then scan
[  570s]         for another token; restrict is a list of tokens that
[  570s]         are allowed, or 0 for any token.
[  570s]         """
[  570s]         tokens_len = len(self.tokens)
[  570s]         if i == tokens_len:  # We are at the end, get the next...
[  570s] >           tokens_len += self._scan(restrict)
[  570s] 
[  570s] scss/grammar/scanner.py:270: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = 
[  570s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  570s] 
[  570s]     def _scan(self, restrict):
[  570s]         """
[  570s]         Should scan another token and add it to the list, self.tokens,
[  570s]         and add the restriction to self.restrictions
[  570s]         """
[  570s]         # Keep looking for a token, ignoring any in self.ignore
[  570s]         if DEBUG:
[  570s]             print()
[  570s]             print("Being asked to match with restriction:", repr(restrict))
[  570s]         token = None
[  570s]         while True:
[  570s]             best_pat = None
[  570s]             # Search the patterns for a match, with earlier
[  570s]             # tokens in the list having preference
[  570s]             best_pat_len = 0
[  570s]             for tok, regex in self.patterns:
[  570s]                 if DEBUG:
[  570s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  570s]                 # First check to see if we're restricting to this token
[  570s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  570s]                     if DEBUG:
[  570s]                         print("\tSkipping %r!" % (tok,))
[  570s]                     continue
[  570s]                 m = regex.match(self.input, self.pos)
[  570s]                 if m:
[  570s]                     # We got a match
[  570s]                     best_pat = tok
[  570s]                     best_pat_len = len(m.group(0))
[  570s]                     if DEBUG:
[  570s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  570s]                     break
[  570s]     
[  570s]             # If we didn't find anything, raise an error
[  570s]             if best_pat is None:
[  570s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  570s] E               scss.errors.SassSyntaxError: Syntax error: Found 'white' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  570s] 
[  570s] scss/grammar/scanner.py:236: SassSyntaxError
[  570s] __________________ scss/tests/files/regressions/issue-40.scss __________________
[  570s] 
[  570s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss>
[  570s] 
[  570s]     def runtest(self):
[  570s]         scss_file = Path(str(self.fspath))
[  570s]         css_file = scss_file.with_suffix('.css')
[  570s]     
[  570s]         with css_file.open('rb') as fh:
[  570s]             # Output is Unicode, so decode this here
[  570s]             expected = fh.read().decode('utf8')
[  570s]     
[  570s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  570s]     
[  570s]         search_path = []
[  570s]         include = scss_file.parent / 'include'
[  570s]         if include.exists():
[  570s]             search_path.append(include)
[  570s]         search_path.append(scss_file.parent)
[  570s]     
[  570s]         try:
[  570s] >           actual = compile_file(
[  570s]                 scss_file,
[  570s]                 output_style='expanded',
[  570s]                 search_path=search_path,
[  570s]                 extensions=[
[  570s]                     CoreExtension,
[  570s]                     ExtraExtension,
[  570s]                     FontsExtension,
[  570s]                     CompassExtension,
[  570s]                 ],
[  570s]             )
[  570s] 
[  570s] conftest.py:127: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss')
[  570s] compiler_class = <class 'scss.compiler.Compiler'>
[  570s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  570s] compiler = <scss.compiler.Compiler object at 0x400519d250>
[  570s] 
[  570s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  570s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  570s]         a string of CSS.
[  570s]     
[  570s]         Keyword arguments are passed along to the underlying `Compiler`.
[  570s]     
[  570s]         Note that the search path is set to the file's containing directory by
[  570s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  570s]     
[  570s]         :param filename: Path to the file to compile.
[  570s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  570s]         """
[  570s]         filename = Path(filename)
[  570s]         if 'search_path' not in kwargs:
[  570s]             kwargs['search_path'] = [filename.parent.resolve()]
[  570s]     
[  570s]         compiler = compiler_class(**kwargs)
[  570s] >       return compiler.compile(filename)
[  570s] 
[  570s] scss/compiler.py:237: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400519d250>
[  570s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss'),)
[  570s] compilation = <scss.compiler.Compilation object at 0x400519d190>
[  570s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss')
[  570s] source = <SourceFile PosixPath('issue-40.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  570s] 
[  570s]     def compile(self, *filenames):
[  570s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  570s]         # get something out besides just the output, you have to copy this
[  570s]         # method.  that sucks.
[  570s]         # TODO i think the right thing is to get all the constructors out of
[  570s]         # SourceFile, since it's really the compiler that knows the import
[  570s]         # paths and should be consulted about this.  reconsider all this (but
[  570s]         # preserve it for now, SIGH) once importers are a thing
[  570s]         compilation = self.make_compilation()
[  570s]         for filename in filenames:
[  570s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  570s]             # instead Compilation should have methods for add_string etc. that
[  570s]             # can call normalize_path.
[  570s]             # TODO it's not possible to inject custom files into the
[  570s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  570s]             # imports.  do we want the former?  is the latter better suited to
[  570s]             # an extension?
[  570s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  570s]             compilation.add_source(source)
[  570s] >       return self.call_and_catch_errors(compilation.run)
[  570s] 
[  570s] scss/compiler.py:203: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compiler object at 0x400519d250>
[  570s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400519d190>>
[  570s] args = (), kwargs = {}
[  570s] 
[  570s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  570s]         """Call the given function with the given arguments.  If it succeeds,
[  570s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  570s]         and `live_errors` is turned on, return CSS containing a traceback and
[  570s]         error message.
[  570s]         """
[  570s]         try:
[  570s] >           return f(*args, **kwargs)
[  570s] 
[  570s] scss/compiler.py:176: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519d190>
[  570s] 
[  570s]     def run(self):
[  570s]         # Any @import will add the source file to self.sources and infect this
[  570s]         # list, so make a quick copy to insulate against that
[  570s]         # TODO maybe @import should just not do that?
[  570s]         for source_file in list(self.sources):
[  570s]             rule = SassRule(
[  570s]                 source_file=source_file,
[  570s]                 lineno=1,
[  570s]     
[  570s]                 unparsed_contents=source_file.contents,
[  570s]                 namespace=self.root_namespace,
[  570s]             )
[  570s]             self.rules.append(rule)
[  570s] >           self.manage_children(rule, scope=None)
[  570s] 
[  570s] scss/compiler.py:296: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519d190>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def manage_children(self, rule, scope):
[  570s]         try:
[  570s] >           self._manage_children_impl(rule, scope)
[  570s] 
[  570s] scss/compiler.py:349: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  570s] self = <scss.compiler.Compilation object at 0x400519d190>
[  570s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  570s] 
[  570s]     def _manage_children_impl(self, rule, scope):
[  570s]         calculator = self._make_calculator(rule.namespace)
[  570s]     
[  570s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  570s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  570s]     
[  570s]             ####################################################################
[  570s]             # At (@) blocks
[  570s]             if block.is_atrule:
[  570s]                 # TODO particularly wild idea: allow extensions to handle
[  570s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  570s]                 # core?  even move the core stuff into the core extension?
[  570s]                 code = block.directive
[  570s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  570s]                 try:
[  570s]                     method = getattr(self, code)
[  570s]                 except AttributeError:
[  570s]                     if block.unparsed_contents is None:
[  570s]                         rule.properties.append((block.prop, None))
[  570s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s]                         self._nest_at_rules(rule, scope, block)
[  570s]                 else:
[  570s]                     method(calculator, rule, scope, block)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Properties
[  570s]             elif block.unparsed_contents is None:
[  570s]                 self._get_properties(rule, scope, block)
[  570s]     
[  570s]             # Nested properties
[  570s]             elif block.is_scope:
[  570s]                 if block.header.unscoped_value:
[  570s]                     # Possibly deal with default unscoped value
[  570s]                     self._get_properties(rule, scope, block)
[  570s]     
[  570s]                 rule.unparsed_contents = block.unparsed_contents
[  570s]                 subscope = (scope or '') + block.header.scope + '-'
[  570s]                 self.manage_children(rule, subscope)
[  570s]     
[  570s]             ####################################################################
[  570s]             # Nested rules
[  570s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  570s] >               self._nest_rules(rule, scope, block)
[  570s] 
[  570s] scss/compiler.py:398: 
[  570s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  570s] 
[  571s] self = <scss.compiler.Compilation object at 0x400519d190>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] block = <scss.rule.UnparsedBlock object at 0x4004fb82d0>
[  571s] 
[  571s]     def _nest_rules(self, rule, scope, block):
[  571s]         """
[  571s]         Implements Nested CSS rules
[  571s]         """
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         raw_selectors = calculator.do_glob_math(block.prop)
[  571s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  571s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  571s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  571s]         if c_parents:
[  571s]             warn_deprecated(
[  571s]                 rule,
[  571s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  571s]                 "Use 'a { @extend b; }' instead."
[  571s]             )
[  571s]     
[  571s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  571s]     
[  571s]         rule.descendants += 1
[  571s]         new_rule = SassRule(
[  571s]             source_file=rule.source_file,
[  571s]             import_key=rule.import_key,
[  571s]             lineno=block.lineno,
[  571s]             num_header_lines=block.header.num_lines,
[  571s]             unparsed_contents=block.unparsed_contents,
[  571s]     
[  571s]             legacy_compiler_options=rule.legacy_compiler_options,
[  571s]             options=rule.options.copy(),
[  571s]             #properties
[  571s]             extends_selectors=c_parents,
[  571s]             ancestry=new_ancestry,
[  571s]     
[  571s]             namespace=rule.namespace.derive(),
[  571s]             nested=rule.nested + 1,
[  571s]         )
[  571s]         self.rules.append(new_rule)
[  571s]         rule.namespace.use_import(rule.source_file)
[  571s] >       self.manage_children(new_rule, scope)
[  571s] 
[  571s] scss/compiler.py:1203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400519d190>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400519d190>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s] >               self._get_properties(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:383: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400519d190>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'a'>,)>,)>, 0 props>
[  571s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004d72b10>
[  571s] 
[  571s]     def _get_properties(self, rule, scope, block):
[  571s]         """
[  571s]         Implements properties and variables extraction and assignment
[  571s]         """
[  571s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  571s]         if raw_value is not None:
[  571s]             raw_value = raw_value.strip()
[  571s]     
[  571s]         try:
[  571s]             is_var = (block.prop[len(prop)] == '=')
[  571s]         except IndexError:
[  571s]             is_var = False
[  571s]         if is_var:
[  571s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         prop = prop.strip()
[  571s]         prop = calculator.do_glob_math(prop)
[  571s]         if not prop:
[  571s]             return
[  571s]     
[  571s]         _prop = (scope or '') + prop
[  571s]         if is_var or prop.startswith('$') and raw_value is not None:
[  571s]             # Pop off any flags: !default, !global
[  571s]             is_default = False
[  571s]             is_global = True  # eventually sass will default this to false
[  571s]             while True:
[  571s]                 splits = raw_value.rsplit(None, 1)
[  571s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  571s]                     break
[  571s]     
[  571s]                 raw_value, flag = splits
[  571s]                 if flag == '!default':
[  571s]                     is_default = True
[  571s]                 elif flag == '!global':
[  571s]                     is_global = True
[  571s]                 else:
[  571s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  571s]     
[  571s]             # Variable assignment
[  571s]             _prop = normalize_var(_prop)
[  571s]             try:
[  571s]                 existing_value = rule.namespace.variable(_prop)
[  571s]             except KeyError:
[  571s]                 existing_value = None
[  571s]     
[  571s]             is_defined = existing_value is not None and not existing_value.is_null
[  571s]             if is_default and is_defined:
[  571s]                 pass
[  571s]             else:
[  571s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  571s]                     log.warn("Constant %r redefined", prop)
[  571s]     
[  571s]                 # Variable assignment is an expression, so it always performs
[  571s]                 # real division
[  571s]                 value = calculator.calculate(raw_value, divide=True)
[  571s]                 rule.namespace.set_variable(
[  571s]                     _prop, value, local_only=not is_global)
[  571s]         else:
[  571s]             # Regular property destined for output
[  571s]             _prop = calculator.apply_vars(_prop)
[  571s]             if raw_value is None:
[  571s]                 value = None
[  571s]             else:
[  571s] >               value = calculator.calculate(raw_value)
[  571s] 
[  571s] scss/compiler.py:1090: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004d71c90>
[  571s] expression = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwA...")'
[  571s] divide = False
[  571s] 
[  571s]     def calculate(self, expression, divide=False):
[  571s] >       result = self.evaluate_expression(expression, divide=divide)
[  571s] 
[  571s] scss/calculator.py:116: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004d71c90>
[  571s] expr = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwA...")'
[  571s] divide = False
[  571s] 
[  571s]     def evaluate_expression(self, expr, divide=False):
[  571s]         try:
[  571s] >           ast = self.parse_expression(expr)
[  571s] 
[  571s] scss/calculator.py:134: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004d71c90>
[  571s] expr = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwA...")'
[  571s] target = 'goal'
[  571s] 
[  571s]     def parse_expression(self, expr, target='goal'):
[  571s]         if isinstance(expr, six.text_type):
[  571s]             # OK
[  571s]             pass
[  571s]         elif isinstance(expr, six.binary_type):
[  571s]             # Dubious
[  571s]             warn(FutureWarning(
[  571s]                 "parse_expression was passed binary data {0!r} "
[  571s]                 "-- this will no longer be supported in pyScss 2.0"
[  571s]                 .format(expr)
[  571s]             ))
[  571s]             # Don't guess an encoding; you reap what you sow
[  571s]             expr = six.text_type(expr)
[  571s]         else:
[  571s]             raise TypeError("Expected string, got %r" % (expr,))
[  571s]     
[  571s]         key = (target, expr)
[  571s]         if key in self.ast_cache:
[  571s]             return self.ast_cache[key]
[  571s]     
[  571s]         try:
[  571s]             parser = SassExpression(SassExpressionScanner(expr))
[  571s] >           ast = getattr(parser, target)()
[  571s] 
[  571s] scss/calculator.py:167: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def goal(self):
[  571s] >       expr_lst = self.expr_lst()
[  571s] 
[  571s] scss/grammar/expression.py:110: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def expr_lst(self):
[  571s] >       expr_slst = self.expr_slst()
[  571s] 
[  571s] scss/grammar/expression.py:199: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def expr_slst(self):
[  571s] >       or_expr = self.or_expr()
[  571s] 
[  571s] scss/grammar/expression.py:208: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def or_expr(self):
[  571s] >       and_expr = self.and_expr()
[  571s] 
[  571s] scss/grammar/expression.py:216: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def and_expr(self):
[  571s] >       not_expr = self.not_expr()
[  571s] 
[  571s] scss/grammar/expression.py:225: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] 
[  571s]     def not_expr(self):
[  571s] >       _token_ = self._peek(self.argspec_item_chks)
[  571s] 
[  571s] scss/grammar/expression.py:234: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004d713d0>
[  571s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _peek(self, types):
[  571s]         """
[  571s]         Returns the token type for lookahead; if there are any args
[  571s]         then the list of args is the set of token types to allow
[  571s]         """
[  571s] >       tok = self._scanner.token(self._pos, types)
[  571s] 
[  571s] scss/grammar/scanner.py:141: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = , i = 0
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def token(self, i, restrict=None):
[  571s]         """
[  571s]         Get the i'th token, and if i is one past the end, then scan
[  571s]         for another token; restrict is a list of tokens that
[  571s]         are allowed, or 0 for any token.
[  571s]         """
[  571s]         tokens_len = len(self.tokens)
[  571s]         if i == tokens_len:  # We are at the end, get the next...
[  571s] >           tokens_len += self._scan(restrict)
[  571s] 
[  571s] scss/grammar/scanner.py:270: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _scan(self, restrict):
[  571s]         """
[  571s]         Should scan another token and add it to the list, self.tokens,
[  571s]         and add the restriction to self.restrictions
[  571s]         """
[  571s]         # Keep looking for a token, ignoring any in self.ignore
[  571s]         if DEBUG:
[  571s]             print()
[  571s]             print("Being asked to match with restriction:", repr(restrict))
[  571s]         token = None
[  571s]         while True:
[  571s]             best_pat = None
[  571s]             # Search the patterns for a match, with earlier
[  571s]             # tokens in the list having preference
[  571s]             best_pat_len = 0
[  571s]             for tok, regex in self.patterns:
[  571s]                 if DEBUG:
[  571s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  571s]                 # First check to see if we're restricting to this token
[  571s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  571s]                     if DEBUG:
[  571s]                         print("\tSkipping %r!" % (tok,))
[  571s]                     continue
[  571s]                 m = regex.match(self.input, self.pos)
[  571s]                 if m:
[  571s]                     # We got a match
[  571s]                     best_pat = tok
[  571s]                     best_pat_len = len(m.group(0))
[  571s]                     if DEBUG:
[  571s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  571s]                     break
[  571s]     
[  571s]             # If we didn't find anything, raise an error
[  571s]             if best_pat is None:
[  571s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  571s] E               scss.errors.SassSyntaxError: Syntax error: Found 'url("data:' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  571s] 
[  571s] scss/grammar/scanner.py:236: SassSyntaxError
[  571s] __________________ scss/tests/files/regressions/issue-5.scss ___________________
[  571s] 
[  571s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss>
[  571s] 
[  571s]     def runtest(self):
[  571s]         scss_file = Path(str(self.fspath))
[  571s]         css_file = scss_file.with_suffix('.css')
[  571s]     
[  571s]         with css_file.open('rb') as fh:
[  571s]             # Output is Unicode, so decode this here
[  571s]             expected = fh.read().decode('utf8')
[  571s]     
[  571s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  571s]     
[  571s]         search_path = []
[  571s]         include = scss_file.parent / 'include'
[  571s]         if include.exists():
[  571s]             search_path.append(include)
[  571s]         search_path.append(scss_file.parent)
[  571s]     
[  571s]         try:
[  571s] >           actual = compile_file(
[  571s]                 scss_file,
[  571s]                 output_style='expanded',
[  571s]                 search_path=search_path,
[  571s]                 extensions=[
[  571s]                     CoreExtension,
[  571s]                     ExtraExtension,
[  571s]                     FontsExtension,
[  571s]                     CompassExtension,
[  571s]                 ],
[  571s]             )
[  571s] 
[  571s] conftest.py:127: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss')
[  571s] compiler_class = <class 'scss.compiler.Compiler'>
[  571s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  571s] compiler = <scss.compiler.Compiler object at 0x4004970090>
[  571s] 
[  571s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  571s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  571s]         a string of CSS.
[  571s]     
[  571s]         Keyword arguments are passed along to the underlying `Compiler`.
[  571s]     
[  571s]         Note that the search path is set to the file's containing directory by
[  571s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  571s]     
[  571s]         :param filename: Path to the file to compile.
[  571s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  571s]         """
[  571s]         filename = Path(filename)
[  571s]         if 'search_path' not in kwargs:
[  571s]             kwargs['search_path'] = [filename.parent.resolve()]
[  571s]     
[  571s]         compiler = compiler_class(**kwargs)
[  571s] >       return compiler.compile(filename)
[  571s] 
[  571s] scss/compiler.py:237: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x4004970090>
[  571s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss'),)
[  571s] compilation = <scss.compiler.Compilation object at 0x4004973390>
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss')
[  571s] source = <SourceFile PosixPath('issue-5.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  571s] 
[  571s]     def compile(self, *filenames):
[  571s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  571s]         # get something out besides just the output, you have to copy this
[  571s]         # method.  that sucks.
[  571s]         # TODO i think the right thing is to get all the constructors out of
[  571s]         # SourceFile, since it's really the compiler that knows the import
[  571s]         # paths and should be consulted about this.  reconsider all this (but
[  571s]         # preserve it for now, SIGH) once importers are a thing
[  571s]         compilation = self.make_compilation()
[  571s]         for filename in filenames:
[  571s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  571s]             # instead Compilation should have methods for add_string etc. that
[  571s]             # can call normalize_path.
[  571s]             # TODO it's not possible to inject custom files into the
[  571s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  571s]             # imports.  do we want the former?  is the latter better suited to
[  571s]             # an extension?
[  571s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  571s]             compilation.add_source(source)
[  571s] >       return self.call_and_catch_errors(compilation.run)
[  571s] 
[  571s] scss/compiler.py:203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x4004970090>
[  571s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004973390>>
[  571s] args = (), kwargs = {}
[  571s] 
[  571s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  571s]         """Call the given function with the given arguments.  If it succeeds,
[  571s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  571s]         and `live_errors` is turned on, return CSS containing a traceback and
[  571s]         error message.
[  571s]         """
[  571s]         try:
[  571s] >           return f(*args, **kwargs)
[  571s] 
[  571s] scss/compiler.py:176: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] 
[  571s]     def run(self):
[  571s]         # Any @import will add the source file to self.sources and infect this
[  571s]         # list, so make a quick copy to insulate against that
[  571s]         # TODO maybe @import should just not do that?
[  571s]         for source_file in list(self.sources):
[  571s]             rule = SassRule(
[  571s]                 source_file=source_file,
[  571s]                 lineno=1,
[  571s]     
[  571s]                 unparsed_contents=source_file.contents,
[  571s]                 namespace=self.root_namespace,
[  571s]             )
[  571s]             self.rules.append(rule)
[  571s] >           self.manage_children(rule, scope=None)
[  571s] 
[  571s] scss/compiler.py:296: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s]                 self._get_properties(rule, scope, block)
[  571s]     
[  571s]             # Nested properties
[  571s]             elif block.is_scope:
[  571s]                 if block.header.unscoped_value:
[  571s]                     # Possibly deal with default unscoped value
[  571s]                     self._get_properties(rule, scope, block)
[  571s]     
[  571s]                 rule.unparsed_contents = block.unparsed_contents
[  571s]                 subscope = (scope or '') + block.header.scope + '-'
[  571s]                 self.manage_children(rule, subscope)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Nested rules
[  571s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s] >               self._nest_rules(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:398: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] block = <scss.rule.UnparsedBlock object at 0x4004972610>
[  571s] 
[  571s]     def _nest_rules(self, rule, scope, block):
[  571s]         """
[  571s]         Implements Nested CSS rules
[  571s]         """
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         raw_selectors = calculator.do_glob_math(block.prop)
[  571s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  571s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  571s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  571s]         if c_parents:
[  571s]             warn_deprecated(
[  571s]                 rule,
[  571s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  571s]                 "Use 'a { @extend b; }' instead."
[  571s]             )
[  571s]     
[  571s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  571s]     
[  571s]         rule.descendants += 1
[  571s]         new_rule = SassRule(
[  571s]             source_file=rule.source_file,
[  571s]             import_key=rule.import_key,
[  571s]             lineno=block.lineno,
[  571s]             num_header_lines=block.header.num_lines,
[  571s]             unparsed_contents=block.unparsed_contents,
[  571s]     
[  571s]             legacy_compiler_options=rule.legacy_compiler_options,
[  571s]             options=rule.options.copy(),
[  571s]             #properties
[  571s]             extends_selectors=c_parents,
[  571s]             ancestry=new_ancestry,
[  571s]     
[  571s]             namespace=rule.namespace.derive(),
[  571s]             nested=rule.nested + 1,
[  571s]         )
[  571s]         self.rules.append(new_rule)
[  571s]         rule.namespace.use_import(rule.source_file)
[  571s] >       self.manage_children(new_rule, scope)
[  571s] 
[  571s] scss/compiler.py:1203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'foo'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'foo'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s] >               self._get_properties(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:383: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004973390>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'foo'>,)>,)>, 0 props>
[  571s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004708910>
[  571s] 
[  571s]     def _get_properties(self, rule, scope, block):
[  571s]         """
[  571s]         Implements properties and variables extraction and assignment
[  571s]         """
[  571s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  571s]         if raw_value is not None:
[  571s]             raw_value = raw_value.strip()
[  571s]     
[  571s]         try:
[  571s]             is_var = (block.prop[len(prop)] == '=')
[  571s]         except IndexError:
[  571s]             is_var = False
[  571s]         if is_var:
[  571s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         prop = prop.strip()
[  571s]         prop = calculator.do_glob_math(prop)
[  571s]         if not prop:
[  571s]             return
[  571s]     
[  571s]         _prop = (scope or '') + prop
[  571s]         if is_var or prop.startswith('$') and raw_value is not None:
[  571s]             # Pop off any flags: !default, !global
[  571s]             is_default = False
[  571s]             is_global = True  # eventually sass will default this to false
[  571s]             while True:
[  571s]                 splits = raw_value.rsplit(None, 1)
[  571s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  571s]                     break
[  571s]     
[  571s]                 raw_value, flag = splits
[  571s]                 if flag == '!default':
[  571s]                     is_default = True
[  571s]                 elif flag == '!global':
[  571s]                     is_global = True
[  571s]                 else:
[  571s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  571s]     
[  571s]             # Variable assignment
[  571s]             _prop = normalize_var(_prop)
[  571s]             try:
[  571s]                 existing_value = rule.namespace.variable(_prop)
[  571s]             except KeyError:
[  571s]                 existing_value = None
[  571s]     
[  571s]             is_defined = existing_value is not None and not existing_value.is_null
[  571s]             if is_default and is_defined:
[  571s]                 pass
[  571s]             else:
[  571s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  571s]                     log.warn("Constant %r redefined", prop)
[  571s]     
[  571s]                 # Variable assignment is an expression, so it always performs
[  571s]                 # real division
[  571s]                 value = calculator.calculate(raw_value, divide=True)
[  571s]                 rule.namespace.set_variable(
[  571s]                     _prop, value, local_only=not is_global)
[  571s]         else:
[  571s]             # Regular property destined for output
[  571s]             _prop = calculator.apply_vars(_prop)
[  571s]             if raw_value is None:
[  571s]                 value = None
[  571s]             else:
[  571s] >               value = calculator.calculate(raw_value)
[  571s] 
[  571s] scss/compiler.py:1090: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x40045dcd10>
[  571s] expression = '$width solid red', divide = False
[  571s] 
[  571s]     def calculate(self, expression, divide=False):
[  571s] >       result = self.evaluate_expression(expression, divide=divide)
[  571s] 
[  571s] scss/calculator.py:116: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x40045dcd10>
[  571s] expr = '$width solid red', divide = False
[  571s] 
[  571s]     def evaluate_expression(self, expr, divide=False):
[  571s]         try:
[  571s] >           ast = self.parse_expression(expr)
[  571s] 
[  571s] scss/calculator.py:134: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x40045dcd10>
[  571s] expr = '$width solid red', target = 'goal'
[  571s] 
[  571s]     def parse_expression(self, expr, target='goal'):
[  571s]         if isinstance(expr, six.text_type):
[  571s]             # OK
[  571s]             pass
[  571s]         elif isinstance(expr, six.binary_type):
[  571s]             # Dubious
[  571s]             warn(FutureWarning(
[  571s]                 "parse_expression was passed binary data {0!r} "
[  571s]                 "-- this will no longer be supported in pyScss 2.0"
[  571s]                 .format(expr)
[  571s]             ))
[  571s]             # Don't guess an encoding; you reap what you sow
[  571s]             expr = six.text_type(expr)
[  571s]         else:
[  571s]             raise TypeError("Expected string, got %r" % (expr,))
[  571s]     
[  571s]         key = (target, expr)
[  571s]         if key in self.ast_cache:
[  571s]             return self.ast_cache[key]
[  571s]     
[  571s]         try:
[  571s]             parser = SassExpression(SassExpressionScanner(expr))
[  571s] >           ast = getattr(parser, target)()
[  571s] 
[  571s] scss/calculator.py:167: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def goal(self):
[  571s] >       expr_lst = self.expr_lst()
[  571s] 
[  571s] scss/grammar/expression.py:110: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def expr_lst(self):
[  571s] >       expr_slst = self.expr_slst()
[  571s] 
[  571s] scss/grammar/expression.py:199: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def expr_slst(self):
[  571s] >       or_expr = self.or_expr()
[  571s] 
[  571s] scss/grammar/expression.py:208: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def or_expr(self):
[  571s] >       and_expr = self.and_expr()
[  571s] 
[  571s] scss/grammar/expression.py:216: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def and_expr(self):
[  571s] >       not_expr = self.not_expr()
[  571s] 
[  571s] scss/grammar/expression.py:225: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def not_expr(self):
[  571s]         _token_ = self._peek(self.argspec_item_chks)
[  571s]         if _token_ != 'NOT':
[  571s] >           comparison = self.comparison()
[  571s] 
[  571s] scss/grammar/expression.py:236: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def comparison(self):
[  571s] >       a_expr = self.a_expr()
[  571s] 
[  571s] scss/grammar/expression.py:244: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def a_expr(self):
[  571s] >       m_expr = self.m_expr()
[  571s] 
[  571s] scss/grammar/expression.py:275: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] 
[  571s]     def m_expr(self):
[  571s]         u_expr = self.u_expr()
[  571s]         v = u_expr
[  571s] >       while self._peek(self.m_expr_rsts) in self.m_expr_chks:
[  571s] 
[  571s] scss/grammar/expression.py:292: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x40045ddc10>
[  571s] types = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  571s] 
[  571s]     def _peek(self, types):
[  571s]         """
[  571s]         Returns the token type for lookahead; if there are any args
[  571s]         then the list of args is the set of token types to allow
[  571s]         """
[  571s] >       tok = self._scanner.token(self._pos, types)
[  571s] 
[  571s] scss/grammar/scanner.py:141: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s]   (@0)  VAR  =  '$width', i = 1
[  571s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  571s] 
[  571s]     def token(self, i, restrict=None):
[  571s]         """
[  571s]         Get the i'th token, and if i is one past the end, then scan
[  571s]         for another token; restrict is a list of tokens that
[  571s]         are allowed, or 0 for any token.
[  571s]         """
[  571s]         tokens_len = len(self.tokens)
[  571s]         if i == tokens_len:  # We are at the end, get the next...
[  571s] >           tokens_len += self._scan(restrict)
[  571s] 
[  571s] scss/grammar/scanner.py:270: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s]   (@0)  VAR  =  '$width'
[  571s] restrict = frozenset({'","', '":"', 'ADD', 'ALPHA_FUNCTION', 'AND', 'BANG_IMPORTANT', ...})
[  571s] 
[  571s]     def _scan(self, restrict):
[  571s]         """
[  571s]         Should scan another token and add it to the list, self.tokens,
[  571s]         and add the restriction to self.restrictions
[  571s]         """
[  571s]         # Keep looking for a token, ignoring any in self.ignore
[  571s]         if DEBUG:
[  571s]             print()
[  571s]             print("Being asked to match with restriction:", repr(restrict))
[  571s]         token = None
[  571s]         while True:
[  571s]             best_pat = None
[  571s]             # Search the patterns for a match, with earlier
[  571s]             # tokens in the list having preference
[  571s]             best_pat_len = 0
[  571s]             for tok, regex in self.patterns:
[  571s]                 if DEBUG:
[  571s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  571s]                 # First check to see if we're restricting to this token
[  571s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  571s]                     if DEBUG:
[  571s]                         print("\tSkipping %r!" % (tok,))
[  571s]                     continue
[  571s]                 m = regex.match(self.input, self.pos)
[  571s]                 if m:
[  571s]                     # We got a match
[  571s]                     best_pat = tok
[  571s]                     best_pat_len = len(m.group(0))
[  571s]                     if DEBUG:
[  571s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  571s]                     break
[  571s]     
[  571s]             # If we didn't find anything, raise an error
[  571s]             if best_pat is None:
[  571s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  571s] E               scss.errors.SassSyntaxError: Syntax error after '$width ': Found 'solid red' but expected one of ",", ":", ADD, ALPHA_FUNCTION, AND, BANG_IMPORTANT, BAREWORD, COLOR, DIV, DOUBLE_QUOTE, END, EQ, FNCT, GE, GT, IF_FUNCTION, INTERP_END, INTERP_START, LE, LITERAL_FUNCTION, LPAR, LT, MOD, MUL, NE, NOT, NUM, OR, RPAR, SIGN, SINGLE_QUOTE, SUB, URL_FUNCTION, VAR
[  571s] 
[  571s] scss/grammar/scanner.py:236: SassSyntaxError
[  571s] __________________ scss/tests/files/regressions/issue-52.scss __________________
[  571s] 
[  571s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52.scss>
[  571s] 
[  571s]     def runtest(self):
[  571s]         scss_file = Path(str(self.fspath))
[  571s]         css_file = scss_file.with_suffix('.css')
[  571s]     
[  571s]         with css_file.open('rb') as fh:
[  571s]             # Output is Unicode, so decode this here
[  571s]             expected = fh.read().decode('utf8')
[  571s]     
[  571s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  571s]     
[  571s]         search_path = []
[  571s]         include = scss_file.parent / 'include'
[  571s]         if include.exists():
[  571s]             search_path.append(include)
[  571s]         search_path.append(scss_file.parent)
[  571s]     
[  571s]         try:
[  571s] >           actual = compile_file(
[  571s]                 scss_file,
[  571s]                 output_style='expanded',
[  571s]                 search_path=search_path,
[  571s]                 extensions=[
[  571s]                     CoreExtension,
[  571s]                     ExtraExtension,
[  571s]                     FontsExtension,
[  571s]                     CompassExtension,
[  571s]                 ],
[  571s]             )
[  571s] 
[  571s] conftest.py:127: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52.scss')
[  571s] compiler_class = <class 'scss.compiler.Compiler'>
[  571s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  571s] compiler = <scss.compiler.Compiler object at 0x400480d450>
[  571s] 
[  571s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  571s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  571s]         a string of CSS.
[  571s]     
[  571s]         Keyword arguments are passed along to the underlying `Compiler`.
[  571s]     
[  571s]         Note that the search path is set to the file's containing directory by
[  571s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  571s]     
[  571s]         :param filename: Path to the file to compile.
[  571s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  571s]         """
[  571s]         filename = Path(filename)
[  571s]         if 'search_path' not in kwargs:
[  571s]             kwargs['search_path'] = [filename.parent.resolve()]
[  571s]     
[  571s]         compiler = compiler_class(**kwargs)
[  571s] >       return compiler.compile(filename)
[  571s] 
[  571s] scss/compiler.py:237: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x400480d450>
[  571s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52.scss'),)
[  571s] compilation = <scss.compiler.Compilation object at 0x400480e510>
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52.scss')
[  571s] source = <SourceFile PosixPath('issue-52.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  571s] 
[  571s]     def compile(self, *filenames):
[  571s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  571s]         # get something out besides just the output, you have to copy this
[  571s]         # method.  that sucks.
[  571s]         # TODO i think the right thing is to get all the constructors out of
[  571s]         # SourceFile, since it's really the compiler that knows the import
[  571s]         # paths and should be consulted about this.  reconsider all this (but
[  571s]         # preserve it for now, SIGH) once importers are a thing
[  571s]         compilation = self.make_compilation()
[  571s]         for filename in filenames:
[  571s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  571s]             # instead Compilation should have methods for add_string etc. that
[  571s]             # can call normalize_path.
[  571s]             # TODO it's not possible to inject custom files into the
[  571s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  571s]             # imports.  do we want the former?  is the latter better suited to
[  571s]             # an extension?
[  571s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  571s]             compilation.add_source(source)
[  571s] >       return self.call_and_catch_errors(compilation.run)
[  571s] 
[  571s] scss/compiler.py:203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x400480d450>
[  571s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400480e510>>
[  571s] args = (), kwargs = {}
[  571s] 
[  571s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  571s]         """Call the given function with the given arguments.  If it succeeds,
[  571s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  571s]         and `live_errors` is turned on, return CSS containing a traceback and
[  571s]         error message.
[  571s]         """
[  571s]         try:
[  571s] >           return f(*args, **kwargs)
[  571s] 
[  571s] scss/compiler.py:176: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] 
[  571s]     def run(self):
[  571s]         # Any @import will add the source file to self.sources and infect this
[  571s]         # list, so make a quick copy to insulate against that
[  571s]         # TODO maybe @import should just not do that?
[  571s]         for source_file in list(self.sources):
[  571s]             rule = SassRule(
[  571s]                 source_file=source_file,
[  571s]                 lineno=1,
[  571s]     
[  571s]                 unparsed_contents=source_file.contents,
[  571s]                 namespace=self.root_namespace,
[  571s]             )
[  571s]             self.rules.append(rule)
[  571s] >           self.manage_children(rule, scope=None)
[  571s] 
[  571s] scss/compiler.py:296: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s]                 self._get_properties(rule, scope, block)
[  571s]     
[  571s]             # Nested properties
[  571s]             elif block.is_scope:
[  571s]                 if block.header.unscoped_value:
[  571s]                     # Possibly deal with default unscoped value
[  571s]                     self._get_properties(rule, scope, block)
[  571s]     
[  571s]                 rule.unparsed_contents = block.unparsed_contents
[  571s]                 subscope = (scope or '') + block.header.scope + '-'
[  571s]                 self.manage_children(rule, subscope)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Nested rules
[  571s]             elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s] >               self._nest_rules(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:398: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] block = <scss.rule.UnparsedBlock object at 0x400480ff50>
[  571s] 
[  571s]     def _nest_rules(self, rule, scope, block):
[  571s]         """
[  571s]         Implements Nested CSS rules
[  571s]         """
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         raw_selectors = calculator.do_glob_math(block.prop)
[  571s]         # DEVIATION: ruby sass doesn't support bare variables in selectors
[  571s]         raw_selectors = calculator.apply_vars(raw_selectors)
[  571s]         c_selectors, c_parents = self.parse_selectors(raw_selectors)
[  571s]         if c_parents:
[  571s]             warn_deprecated(
[  571s]                 rule,
[  571s]                 "The XCSS 'a extends b' syntax is deprecated.  "
[  571s]                 "Use 'a { @extend b; }' instead."
[  571s]             )
[  571s]     
[  571s]         new_ancestry = rule.ancestry.with_nested_selectors(c_selectors)
[  571s]     
[  571s]         rule.descendants += 1
[  571s]         new_rule = SassRule(
[  571s]             source_file=rule.source_file,
[  571s]             import_key=rule.import_key,
[  571s]             lineno=block.lineno,
[  571s]             num_header_lines=block.header.num_lines,
[  571s]             unparsed_contents=block.unparsed_contents,
[  571s]     
[  571s]             legacy_compiler_options=rule.legacy_compiler_options,
[  571s]             options=rule.options.copy(),
[  571s]             #properties
[  571s]             extends_selectors=c_parents,
[  571s]             ancestry=new_ancestry,
[  571s]     
[  571s]             namespace=rule.namespace.derive(),
[  571s]             nested=rule.nested + 1,
[  571s]         )
[  571s]         self.rules.append(new_rule)
[  571s]         rule.namespace.use_import(rule.source_file)
[  571s] >       self.manage_children(new_rule, scope)
[  571s] 
[  571s] scss/compiler.py:1203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  571s] scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s] >               self._get_properties(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:383: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400480e510>
[  571s] rule = <SassRule <RuleAncestry (<BlockSelectorHeader (<Selector: 'h1'>,)>,)>, 0 props>
[  571s] scope = None, block = <scss.rule.UnparsedBlock object at 0x4004f89ad0>
[  571s] 
[  571s]     def _get_properties(self, rule, scope, block):
[  571s]         """
[  571s]         Implements properties and variables extraction and assignment
[  571s]         """
[  571s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  571s]         if raw_value is not None:
[  571s]             raw_value = raw_value.strip()
[  571s]     
[  571s]         try:
[  571s]             is_var = (block.prop[len(prop)] == '=')
[  571s]         except IndexError:
[  571s]             is_var = False
[  571s]         if is_var:
[  571s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         prop = prop.strip()
[  571s]         prop = calculator.do_glob_math(prop)
[  571s]         if not prop:
[  571s]             return
[  571s]     
[  571s]         _prop = (scope or '') + prop
[  571s]         if is_var or prop.startswith('$') and raw_value is not None:
[  571s]             # Pop off any flags: !default, !global
[  571s]             is_default = False
[  571s]             is_global = True  # eventually sass will default this to false
[  571s]             while True:
[  571s]                 splits = raw_value.rsplit(None, 1)
[  571s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  571s]                     break
[  571s]     
[  571s]                 raw_value, flag = splits
[  571s]                 if flag == '!default':
[  571s]                     is_default = True
[  571s]                 elif flag == '!global':
[  571s]                     is_global = True
[  571s]                 else:
[  571s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  571s]     
[  571s]             # Variable assignment
[  571s]             _prop = normalize_var(_prop)
[  571s]             try:
[  571s]                 existing_value = rule.namespace.variable(_prop)
[  571s]             except KeyError:
[  571s]                 existing_value = None
[  571s]     
[  571s]             is_defined = existing_value is not None and not existing_value.is_null
[  571s]             if is_default and is_defined:
[  571s]                 pass
[  571s]             else:
[  571s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  571s]                     log.warn("Constant %r redefined", prop)
[  571s]     
[  571s]                 # Variable assignment is an expression, so it always performs
[  571s]                 # real division
[  571s]                 value = calculator.calculate(raw_value, divide=True)
[  571s]                 rule.namespace.set_variable(
[  571s]                     _prop, value, local_only=not is_global)
[  571s]         else:
[  571s]             # Regular property destined for output
[  571s]             _prop = calculator.apply_vars(_prop)
[  571s]             if raw_value is None:
[  571s]                 value = None
[  571s]             else:
[  571s] >               value = calculator.calculate(raw_value)
[  571s] 
[  571s] scss/compiler.py:1090: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004f8bbd0>
[  571s] expression = 'url(//example.com/image.png)', divide = False
[  571s] 
[  571s]     def calculate(self, expression, divide=False):
[  571s] >       result = self.evaluate_expression(expression, divide=divide)
[  571s] 
[  571s] scss/calculator.py:116: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004f8bbd0>
[  571s] expr = 'url(//example.com/image.png)', divide = False
[  571s] 
[  571s]     def evaluate_expression(self, expr, divide=False):
[  571s]         try:
[  571s] >           ast = self.parse_expression(expr)
[  571s] 
[  571s] scss/calculator.py:134: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4004f8bbd0>
[  571s] expr = 'url(//example.com/image.png)', target = 'goal'
[  571s] 
[  571s]     def parse_expression(self, expr, target='goal'):
[  571s]         if isinstance(expr, six.text_type):
[  571s]             # OK
[  571s]             pass
[  571s]         elif isinstance(expr, six.binary_type):
[  571s]             # Dubious
[  571s]             warn(FutureWarning(
[  571s]                 "parse_expression was passed binary data {0!r} "
[  571s]                 "-- this will no longer be supported in pyScss 2.0"
[  571s]                 .format(expr)
[  571s]             ))
[  571s]             # Don't guess an encoding; you reap what you sow
[  571s]             expr = six.text_type(expr)
[  571s]         else:
[  571s]             raise TypeError("Expected string, got %r" % (expr,))
[  571s]     
[  571s]         key = (target, expr)
[  571s]         if key in self.ast_cache:
[  571s]             return self.ast_cache[key]
[  571s]     
[  571s]         try:
[  571s]             parser = SassExpression(SassExpressionScanner(expr))
[  571s] >           ast = getattr(parser, target)()
[  571s] 
[  571s] scss/calculator.py:167: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def goal(self):
[  571s] >       expr_lst = self.expr_lst()
[  571s] 
[  571s] scss/grammar/expression.py:110: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def expr_lst(self):
[  571s] >       expr_slst = self.expr_slst()
[  571s] 
[  571s] scss/grammar/expression.py:199: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def expr_slst(self):
[  571s] >       or_expr = self.or_expr()
[  571s] 
[  571s] scss/grammar/expression.py:208: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def or_expr(self):
[  571s] >       and_expr = self.and_expr()
[  571s] 
[  571s] scss/grammar/expression.py:216: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def and_expr(self):
[  571s] >       not_expr = self.not_expr()
[  571s] 
[  571s] scss/grammar/expression.py:225: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] 
[  571s]     def not_expr(self):
[  571s] >       _token_ = self._peek(self.argspec_item_chks)
[  571s] 
[  571s] scss/grammar/expression.py:234: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004f8b510>
[  571s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _peek(self, types):
[  571s]         """
[  571s]         Returns the token type for lookahead; if there are any args
[  571s]         then the list of args is the set of token types to allow
[  571s]         """
[  571s] >       tok = self._scanner.token(self._pos, types)
[  571s] 
[  571s] scss/grammar/scanner.py:141: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = , i = 0
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def token(self, i, restrict=None):
[  571s]         """
[  571s]         Get the i'th token, and if i is one past the end, then scan
[  571s]         for another token; restrict is a list of tokens that
[  571s]         are allowed, or 0 for any token.
[  571s]         """
[  571s]         tokens_len = len(self.tokens)
[  571s]         if i == tokens_len:  # We are at the end, get the next...
[  571s] >           tokens_len += self._scan(restrict)
[  571s] 
[  571s] scss/grammar/scanner.py:270: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _scan(self, restrict):
[  571s]         """
[  571s]         Should scan another token and add it to the list, self.tokens,
[  571s]         and add the restriction to self.restrictions
[  571s]         """
[  571s]         # Keep looking for a token, ignoring any in self.ignore
[  571s]         if DEBUG:
[  571s]             print()
[  571s]             print("Being asked to match with restriction:", repr(restrict))
[  571s]         token = None
[  571s]         while True:
[  571s]             best_pat = None
[  571s]             # Search the patterns for a match, with earlier
[  571s]             # tokens in the list having preference
[  571s]             best_pat_len = 0
[  571s]             for tok, regex in self.patterns:
[  571s]                 if DEBUG:
[  571s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  571s]                 # First check to see if we're restricting to this token
[  571s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  571s]                     if DEBUG:
[  571s]                         print("\tSkipping %r!" % (tok,))
[  571s]                     continue
[  571s]                 m = regex.match(self.input, self.pos)
[  571s]                 if m:
[  571s]                     # We got a match
[  571s]                     best_pat = tok
[  571s]                     best_pat_len = len(m.group(0))
[  571s]                     if DEBUG:
[  571s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  571s]                     break
[  571s]     
[  571s]             # If we didn't find anything, raise an error
[  571s]             if best_pat is None:
[  571s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  571s] E               scss.errors.SassSyntaxError: Syntax error: Found 'url(//exam' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  571s] 
[  571s] scss/grammar/scanner.py:236: SassSyntaxError
[  571s] __________________ scss/tests/files/regressions/issue-6.scss ___________________
[  571s] 
[  571s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss>
[  571s] 
[  571s]     def runtest(self):
[  571s]         scss_file = Path(str(self.fspath))
[  571s]         css_file = scss_file.with_suffix('.css')
[  571s]     
[  571s]         with css_file.open('rb') as fh:
[  571s]             # Output is Unicode, so decode this here
[  571s]             expected = fh.read().decode('utf8')
[  571s]     
[  571s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  571s]     
[  571s]         search_path = []
[  571s]         include = scss_file.parent / 'include'
[  571s]         if include.exists():
[  571s]             search_path.append(include)
[  571s]         search_path.append(scss_file.parent)
[  571s]     
[  571s]         try:
[  571s] >           actual = compile_file(
[  571s]                 scss_file,
[  571s]                 output_style='expanded',
[  571s]                 search_path=search_path,
[  571s]                 extensions=[
[  571s]                     CoreExtension,
[  571s]                     ExtraExtension,
[  571s]                     FontsExtension,
[  571s]                     CompassExtension,
[  571s]                 ],
[  571s]             )
[  571s] 
[  571s] conftest.py:127: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss')
[  571s] compiler_class = <class 'scss.compiler.Compiler'>
[  571s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  571s] compiler = <scss.compiler.Compiler object at 0x400488b390>
[  571s] 
[  571s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  571s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  571s]         a string of CSS.
[  571s]     
[  571s]         Keyword arguments are passed along to the underlying `Compiler`.
[  571s]     
[  571s]         Note that the search path is set to the file's containing directory by
[  571s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  571s]     
[  571s]         :param filename: Path to the file to compile.
[  571s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  571s]         """
[  571s]         filename = Path(filename)
[  571s]         if 'search_path' not in kwargs:
[  571s]             kwargs['search_path'] = [filename.parent.resolve()]
[  571s]     
[  571s]         compiler = compiler_class(**kwargs)
[  571s] >       return compiler.compile(filename)
[  571s] 
[  571s] scss/compiler.py:237: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x400488b390>
[  571s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss'),)
[  571s] compilation = <scss.compiler.Compilation object at 0x400488ba90>
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss')
[  571s] source = <SourceFile PosixPath('issue-6.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  571s] 
[  571s]     def compile(self, *filenames):
[  571s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  571s]         # get something out besides just the output, you have to copy this
[  571s]         # method.  that sucks.
[  571s]         # TODO i think the right thing is to get all the constructors out of
[  571s]         # SourceFile, since it's really the compiler that knows the import
[  571s]         # paths and should be consulted about this.  reconsider all this (but
[  571s]         # preserve it for now, SIGH) once importers are a thing
[  571s]         compilation = self.make_compilation()
[  571s]         for filename in filenames:
[  571s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  571s]             # instead Compilation should have methods for add_string etc. that
[  571s]             # can call normalize_path.
[  571s]             # TODO it's not possible to inject custom files into the
[  571s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  571s]             # imports.  do we want the former?  is the latter better suited to
[  571s]             # an extension?
[  571s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  571s]             compilation.add_source(source)
[  571s] >       return self.call_and_catch_errors(compilation.run)
[  571s] 
[  571s] scss/compiler.py:203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x400488b390>
[  571s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x400488ba90>>
[  571s] args = (), kwargs = {}
[  571s] 
[  571s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  571s]         """Call the given function with the given arguments.  If it succeeds,
[  571s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  571s]         and `live_errors` is turned on, return CSS containing a traceback and
[  571s]         error message.
[  571s]         """
[  571s]         try:
[  571s] >           return f(*args, **kwargs)
[  571s] 
[  571s] scss/compiler.py:176: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400488ba90>
[  571s] 
[  571s]     def run(self):
[  571s]         # Any @import will add the source file to self.sources and infect this
[  571s]         # list, so make a quick copy to insulate against that
[  571s]         # TODO maybe @import should just not do that?
[  571s]         for source_file in list(self.sources):
[  571s]             rule = SassRule(
[  571s]                 source_file=source_file,
[  571s]                 lineno=1,
[  571s]     
[  571s]                 unparsed_contents=source_file.contents,
[  571s]                 namespace=self.root_namespace,
[  571s]             )
[  571s]             self.rules.append(rule)
[  571s] >           self.manage_children(rule, scope=None)
[  571s] 
[  571s] scss/compiler.py:296: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400488ba90>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400488ba90>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s] >               self._get_properties(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:383: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x400488ba90>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] block = <scss.rule.UnparsedBlock object at 0x400488a610>
[  571s] 
[  571s]     def _get_properties(self, rule, scope, block):
[  571s]         """
[  571s]         Implements properties and variables extraction and assignment
[  571s]         """
[  571s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  571s]         if raw_value is not None:
[  571s]             raw_value = raw_value.strip()
[  571s]     
[  571s]         try:
[  571s]             is_var = (block.prop[len(prop)] == '=')
[  571s]         except IndexError:
[  571s]             is_var = False
[  571s]         if is_var:
[  571s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         prop = prop.strip()
[  571s]         prop = calculator.do_glob_math(prop)
[  571s]         if not prop:
[  571s]             return
[  571s]     
[  571s]         _prop = (scope or '') + prop
[  571s]         if is_var or prop.startswith('$') and raw_value is not None:
[  571s]             # Pop off any flags: !default, !global
[  571s]             is_default = False
[  571s]             is_global = True  # eventually sass will default this to false
[  571s]             while True:
[  571s]                 splits = raw_value.rsplit(None, 1)
[  571s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  571s]                     break
[  571s]     
[  571s]                 raw_value, flag = splits
[  571s]                 if flag == '!default':
[  571s]                     is_default = True
[  571s]                 elif flag == '!global':
[  571s]                     is_global = True
[  571s]                 else:
[  571s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  571s]     
[  571s]             # Variable assignment
[  571s]             _prop = normalize_var(_prop)
[  571s]             try:
[  571s]                 existing_value = rule.namespace.variable(_prop)
[  571s]             except KeyError:
[  571s]                 existing_value = None
[  571s]     
[  571s]             is_defined = existing_value is not None and not existing_value.is_null
[  571s]             if is_default and is_defined:
[  571s]                 pass
[  571s]             else:
[  571s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  571s]                     log.warn("Constant %r redefined", prop)
[  571s]     
[  571s]                 # Variable assignment is an expression, so it always performs
[  571s]                 # real division
[  571s] >               value = calculator.calculate(raw_value, divide=True)
[  571s] 
[  571s] scss/compiler.py:1081: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x400488add0>
[  571s] expression = 'monster', divide = True
[  571s] 
[  571s]     def calculate(self, expression, divide=False):
[  571s] >       result = self.evaluate_expression(expression, divide=divide)
[  571s] 
[  571s] scss/calculator.py:116: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x400488add0>, expr = 'monster'
[  571s] divide = True
[  571s] 
[  571s]     def evaluate_expression(self, expr, divide=False):
[  571s]         try:
[  571s] >           ast = self.parse_expression(expr)
[  571s] 
[  571s] scss/calculator.py:134: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x400488add0>, expr = 'monster'
[  571s] target = 'goal'
[  571s] 
[  571s]     def parse_expression(self, expr, target='goal'):
[  571s]         if isinstance(expr, six.text_type):
[  571s]             # OK
[  571s]             pass
[  571s]         elif isinstance(expr, six.binary_type):
[  571s]             # Dubious
[  571s]             warn(FutureWarning(
[  571s]                 "parse_expression was passed binary data {0!r} "
[  571s]                 "-- this will no longer be supported in pyScss 2.0"
[  571s]                 .format(expr)
[  571s]             ))
[  571s]             # Don't guess an encoding; you reap what you sow
[  571s]             expr = six.text_type(expr)
[  571s]         else:
[  571s]             raise TypeError("Expected string, got %r" % (expr,))
[  571s]     
[  571s]         key = (target, expr)
[  571s]         if key in self.ast_cache:
[  571s]             return self.ast_cache[key]
[  571s]     
[  571s]         try:
[  571s]             parser = SassExpression(SassExpressionScanner(expr))
[  571s] >           ast = getattr(parser, target)()
[  571s] 
[  571s] scss/calculator.py:167: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def goal(self):
[  571s] >       expr_lst = self.expr_lst()
[  571s] 
[  571s] scss/grammar/expression.py:110: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def expr_lst(self):
[  571s] >       expr_slst = self.expr_slst()
[  571s] 
[  571s] scss/grammar/expression.py:199: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def expr_slst(self):
[  571s] >       or_expr = self.or_expr()
[  571s] 
[  571s] scss/grammar/expression.py:208: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def or_expr(self):
[  571s] >       and_expr = self.and_expr()
[  571s] 
[  571s] scss/grammar/expression.py:216: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def and_expr(self):
[  571s] >       not_expr = self.not_expr()
[  571s] 
[  571s] scss/grammar/expression.py:225: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] 
[  571s]     def not_expr(self):
[  571s] >       _token_ = self._peek(self.argspec_item_chks)
[  571s] 
[  571s] scss/grammar/expression.py:234: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4004888b90>
[  571s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _peek(self, types):
[  571s]         """
[  571s]         Returns the token type for lookahead; if there are any args
[  571s]         then the list of args is the set of token types to allow
[  571s]         """
[  571s] >       tok = self._scanner.token(self._pos, types)
[  571s] 
[  571s] scss/grammar/scanner.py:141: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = , i = 0
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def token(self, i, restrict=None):
[  571s]         """
[  571s]         Get the i'th token, and if i is one past the end, then scan
[  571s]         for another token; restrict is a list of tokens that
[  571s]         are allowed, or 0 for any token.
[  571s]         """
[  571s]         tokens_len = len(self.tokens)
[  571s]         if i == tokens_len:  # We are at the end, get the next...
[  571s] >           tokens_len += self._scan(restrict)
[  571s] 
[  571s] scss/grammar/scanner.py:270: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _scan(self, restrict):
[  571s]         """
[  571s]         Should scan another token and add it to the list, self.tokens,
[  571s]         and add the restriction to self.restrictions
[  571s]         """
[  571s]         # Keep looking for a token, ignoring any in self.ignore
[  571s]         if DEBUG:
[  571s]             print()
[  571s]             print("Being asked to match with restriction:", repr(restrict))
[  571s]         token = None
[  571s]         while True:
[  571s]             best_pat = None
[  571s]             # Search the patterns for a match, with earlier
[  571s]             # tokens in the list having preference
[  571s]             best_pat_len = 0
[  571s]             for tok, regex in self.patterns:
[  571s]                 if DEBUG:
[  571s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  571s]                 # First check to see if we're restricting to this token
[  571s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  571s]                     if DEBUG:
[  571s]                         print("\tSkipping %r!" % (tok,))
[  571s]                     continue
[  571s]                 m = regex.match(self.input, self.pos)
[  571s]                 if m:
[  571s]                     # We got a match
[  571s]                     best_pat = tok
[  571s]                     best_pat_len = len(m.group(0))
[  571s]                     if DEBUG:
[  571s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  571s]                     break
[  571s]     
[  571s]             # If we didn't find anything, raise an error
[  571s]             if best_pat is None:
[  571s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  571s] E               scss.errors.SassSyntaxError: Syntax error: Found 'monster' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  571s] 
[  571s] scss/grammar/scanner.py:236: SassSyntaxError
[  571s] ______________ scss/tests/files/regressions/nth-inside-each.scss _______________
[  571s] 
[  571s] self = <SassItem /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each.scss>
[  571s] 
[  571s]     def runtest(self):
[  571s]         scss_file = Path(str(self.fspath))
[  571s]         css_file = scss_file.with_suffix('.css')
[  571s]     
[  571s]         with css_file.open('rb') as fh:
[  571s]             # Output is Unicode, so decode this here
[  571s]             expected = fh.read().decode('utf8')
[  571s]     
[  571s]         scss.config.STATIC_ROOT = str(scss_file.parent / 'static')
[  571s]     
[  571s]         search_path = []
[  571s]         include = scss_file.parent / 'include'
[  571s]         if include.exists():
[  571s]             search_path.append(include)
[  571s]         search_path.append(scss_file.parent)
[  571s]     
[  571s]         try:
[  571s] >           actual = compile_file(
[  571s]                 scss_file,
[  571s]                 output_style='expanded',
[  571s]                 search_path=search_path,
[  571s]                 extensions=[
[  571s]                     CoreExtension,
[  571s]                     ExtraExtension,
[  571s]                     FontsExtension,
[  571s]                     CompassExtension,
[  571s]                 ],
[  571s]             )
[  571s] 
[  571s] conftest.py:127: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each.scss')
[  571s] compiler_class = <class 'scss.compiler.Compiler'>
[  571s] kwargs = {'extensions': [<class 'scss.extension.core.CoreExtension'>, <class 'scss.extension.extra.ExtraExtension'>, <class 'sc...tests/files/regressions/include'), PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')]}
[  571s] compiler = <scss.compiler.Compiler object at 0x4004c53550>
[  571s] 
[  571s]     def compile_file(filename, compiler_class=Compiler, **kwargs):
[  571s]         """Compile a single file (provided as a :class:`pathlib.Path`), and return
[  571s]         a string of CSS.
[  571s]     
[  571s]         Keyword arguments are passed along to the underlying `Compiler`.
[  571s]     
[  571s]         Note that the search path is set to the file's containing directory by
[  571s]         default, unless you explicitly pass a ``search_path`` kwarg.
[  571s]     
[  571s]         :param filename: Path to the file to compile.
[  571s]         :type filename: str, bytes, or :class:`pathlib.Path`
[  571s]         """
[  571s]         filename = Path(filename)
[  571s]         if 'search_path' not in kwargs:
[  571s]             kwargs['search_path'] = [filename.parent.resolve()]
[  571s]     
[  571s]         compiler = compiler_class(**kwargs)
[  571s] >       return compiler.compile(filename)
[  571s] 
[  571s] scss/compiler.py:237: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x4004c53550>
[  571s] filenames = (PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each.scss'),)
[  571s] compilation = <scss.compiler.Compilation object at 0x4004c515d0>
[  571s] filename = PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each.scss')
[  571s] source = <SourceFile PosixPath('nth-inside-each.scss') from PosixPath('/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions')>
[  571s] 
[  571s]     def compile(self, *filenames):
[  571s]         # TODO this doesn't spit out the compilation itself, so if you want to
[  571s]         # get something out besides just the output, you have to copy this
[  571s]         # method.  that sucks.
[  571s]         # TODO i think the right thing is to get all the constructors out of
[  571s]         # SourceFile, since it's really the compiler that knows the import
[  571s]         # paths and should be consulted about this.  reconsider all this (but
[  571s]         # preserve it for now, SIGH) once importers are a thing
[  571s]         compilation = self.make_compilation()
[  571s]         for filename in filenames:
[  571s]             # TODO maybe SourceFile should not be exposed to the end user, and
[  571s]             # instead Compilation should have methods for add_string etc. that
[  571s]             # can call normalize_path.
[  571s]             # TODO it's not possible to inject custom files into the
[  571s]             # /compiler/ as persistent across compiles, nor to provide "fake"
[  571s]             # imports.  do we want the former?  is the latter better suited to
[  571s]             # an extension?
[  571s]             source = SourceFile.from_filename(self.normalize_path(filename))
[  571s]             compilation.add_source(source)
[  571s] >       return self.call_and_catch_errors(compilation.run)
[  571s] 
[  571s] scss/compiler.py:203: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compiler object at 0x4004c53550>
[  571s] f = <bound method Compilation.run of <scss.compiler.Compilation object at 0x4004c515d0>>
[  571s] args = (), kwargs = {}
[  571s] 
[  571s]     def call_and_catch_errors(self, f, *args, **kwargs):
[  571s]         """Call the given function with the given arguments.  If it succeeds,
[  571s]         return its return value.  If it raises a :class:`scss.errors.SassError`
[  571s]         and `live_errors` is turned on, return CSS containing a traceback and
[  571s]         error message.
[  571s]         """
[  571s]         try:
[  571s] >           return f(*args, **kwargs)
[  571s] 
[  571s] scss/compiler.py:176: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004c515d0>
[  571s] 
[  571s]     def run(self):
[  571s]         # Any @import will add the source file to self.sources and infect this
[  571s]         # list, so make a quick copy to insulate against that
[  571s]         # TODO maybe @import should just not do that?
[  571s]         for source_file in list(self.sources):
[  571s]             rule = SassRule(
[  571s]                 source_file=source_file,
[  571s]                 lineno=1,
[  571s]     
[  571s]                 unparsed_contents=source_file.contents,
[  571s]                 namespace=self.root_namespace,
[  571s]             )
[  571s]             self.rules.append(rule)
[  571s] >           self.manage_children(rule, scope=None)
[  571s] 
[  571s] scss/compiler.py:296: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004c515d0>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def manage_children(self, rule, scope):
[  571s]         try:
[  571s] >           self._manage_children_impl(rule, scope)
[  571s] 
[  571s] scss/compiler.py:349: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004c515d0>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] 
[  571s]     def _manage_children_impl(self, rule, scope):
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]     
[  571s]         for c_lineno, c_property, c_codestr in locate_blocks(rule.unparsed_contents):
[  571s]             block = UnparsedBlock(rule, c_lineno, c_property, c_codestr)
[  571s]     
[  571s]             ####################################################################
[  571s]             # At (@) blocks
[  571s]             if block.is_atrule:
[  571s]                 # TODO particularly wild idea: allow extensions to handle
[  571s]                 # unrecognized blocks, and get the pyscss stuff out of the
[  571s]                 # core?  even move the core stuff into the core extension?
[  571s]                 code = block.directive
[  571s]                 code = '_at_' + code.lower().replace(' ', '_')[1:]
[  571s]                 try:
[  571s]                     method = getattr(self, code)
[  571s]                 except AttributeError:
[  571s]                     if block.unparsed_contents is None:
[  571s]                         rule.properties.append((block.prop, None))
[  571s]                     elif scope is None:  # needs to have no scope to crawl down the nested rules
[  571s]                         self._nest_at_rules(rule, scope, block)
[  571s]                 else:
[  571s]                     method(calculator, rule, scope, block)
[  571s]     
[  571s]             ####################################################################
[  571s]             # Properties
[  571s]             elif block.unparsed_contents is None:
[  571s] >               self._get_properties(rule, scope, block)
[  571s] 
[  571s] scss/compiler.py:383: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.compiler.Compilation object at 0x4004c515d0>
[  571s] rule = <SassRule <RuleAncestry ()>, 0 props>, scope = None
[  571s] block = <scss.rule.UnparsedBlock object at 0x40052003d0>
[  571s] 
[  571s]     def _get_properties(self, rule, scope, block):
[  571s]         """
[  571s]         Implements properties and variables extraction and assignment
[  571s]         """
[  571s]         prop, raw_value = (_prop_split_re.split(block.prop, 1) + [None])[:2]
[  571s]         if raw_value is not None:
[  571s]             raw_value = raw_value.strip()
[  571s]     
[  571s]         try:
[  571s]             is_var = (block.prop[len(prop)] == '=')
[  571s]         except IndexError:
[  571s]             is_var = False
[  571s]         if is_var:
[  571s]             warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s]         calculator = self._make_calculator(rule.namespace)
[  571s]         prop = prop.strip()
[  571s]         prop = calculator.do_glob_math(prop)
[  571s]         if not prop:
[  571s]             return
[  571s]     
[  571s]         _prop = (scope or '') + prop
[  571s]         if is_var or prop.startswith('$') and raw_value is not None:
[  571s]             # Pop off any flags: !default, !global
[  571s]             is_default = False
[  571s]             is_global = True  # eventually sass will default this to false
[  571s]             while True:
[  571s]                 splits = raw_value.rsplit(None, 1)
[  571s]                 if len(splits) < 2 or not splits[1].startswith('!'):
[  571s]                     break
[  571s]     
[  571s]                 raw_value, flag = splits
[  571s]                 if flag == '!default':
[  571s]                     is_default = True
[  571s]                 elif flag == '!global':
[  571s]                     is_global = True
[  571s]                 else:
[  571s]                     raise ValueError("Unrecognized flag: {0}".format(flag))
[  571s]     
[  571s]             # Variable assignment
[  571s]             _prop = normalize_var(_prop)
[  571s]             try:
[  571s]                 existing_value = rule.namespace.variable(_prop)
[  571s]             except KeyError:
[  571s]                 existing_value = None
[  571s]     
[  571s]             is_defined = existing_value is not None and not existing_value.is_null
[  571s]             if is_default and is_defined:
[  571s]                 pass
[  571s]             else:
[  571s]                 if is_defined and prop.startswith('$') and prop[1].isupper():
[  571s]                     log.warn("Constant %r redefined", prop)
[  571s]     
[  571s]                 # Variable assignment is an expression, so it always performs
[  571s]                 # real division
[  571s] >               value = calculator.calculate(raw_value, divide=True)
[  571s] 
[  571s] scss/compiler.py:1081: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4005200f50>
[  571s] expression = 'yellow #FFA500, blue #4682B4, green #2ca02c', divide = True
[  571s] 
[  571s]     def calculate(self, expression, divide=False):
[  571s] >       result = self.evaluate_expression(expression, divide=divide)
[  571s] 
[  571s] scss/calculator.py:116: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4005200f50>
[  571s] expr = 'yellow #FFA500, blue #4682B4, green #2ca02c', divide = True
[  571s] 
[  571s]     def evaluate_expression(self, expr, divide=False):
[  571s]         try:
[  571s] >           ast = self.parse_expression(expr)
[  571s] 
[  571s] scss/calculator.py:134: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.calculator.Calculator object at 0x4005200f50>
[  571s] expr = 'yellow #FFA500, blue #4682B4, green #2ca02c', target = 'goal'
[  571s] 
[  571s]     def parse_expression(self, expr, target='goal'):
[  571s]         if isinstance(expr, six.text_type):
[  571s]             # OK
[  571s]             pass
[  571s]         elif isinstance(expr, six.binary_type):
[  571s]             # Dubious
[  571s]             warn(FutureWarning(
[  571s]                 "parse_expression was passed binary data {0!r} "
[  571s]                 "-- this will no longer be supported in pyScss 2.0"
[  571s]                 .format(expr)
[  571s]             ))
[  571s]             # Don't guess an encoding; you reap what you sow
[  571s]             expr = six.text_type(expr)
[  571s]         else:
[  571s]             raise TypeError("Expected string, got %r" % (expr,))
[  571s]     
[  571s]         key = (target, expr)
[  571s]         if key in self.ast_cache:
[  571s]             return self.ast_cache[key]
[  571s]     
[  571s]         try:
[  571s]             parser = SassExpression(SassExpressionScanner(expr))
[  571s] >           ast = getattr(parser, target)()
[  571s] 
[  571s] scss/calculator.py:167: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def goal(self):
[  571s] >       expr_lst = self.expr_lst()
[  571s] 
[  571s] scss/grammar/expression.py:110: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def expr_lst(self):
[  571s] >       expr_slst = self.expr_slst()
[  571s] 
[  571s] scss/grammar/expression.py:199: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def expr_slst(self):
[  571s] >       or_expr = self.or_expr()
[  571s] 
[  571s] scss/grammar/expression.py:208: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def or_expr(self):
[  571s] >       and_expr = self.and_expr()
[  571s] 
[  571s] scss/grammar/expression.py:216: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def and_expr(self):
[  571s] >       not_expr = self.not_expr()
[  571s] 
[  571s] scss/grammar/expression.py:225: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] 
[  571s]     def not_expr(self):
[  571s] >       _token_ = self._peek(self.argspec_item_chks)
[  571s] 
[  571s] scss/grammar/expression.py:234: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = <scss.grammar.expression.SassExpression object at 0x4005200990>
[  571s] types = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _peek(self, types):
[  571s]         """
[  571s]         Returns the token type for lookahead; if there are any args
[  571s]         then the list of args is the set of token types to allow
[  571s]         """
[  571s] >       tok = self._scanner.token(self._pos, types)
[  571s] 
[  571s] scss/grammar/scanner.py:141: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = , i = 0
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def token(self, i, restrict=None):
[  571s]         """
[  571s]         Get the i'th token, and if i is one past the end, then scan
[  571s]         for another token; restrict is a list of tokens that
[  571s]         are allowed, or 0 for any token.
[  571s]         """
[  571s]         tokens_len = len(self.tokens)
[  571s]         if i == tokens_len:  # We are at the end, get the next...
[  571s] >           tokens_len += self._scan(restrict)
[  571s] 
[  571s] scss/grammar/scanner.py:270: 
[  571s] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[  571s] 
[  571s] self = 
[  571s] restrict = frozenset({'ADD', 'ALPHA_FUNCTION', 'BANG_IMPORTANT', 'BAREWORD', 'COLOR', 'DOUBLE_QUOTE', ...})
[  571s] 
[  571s]     def _scan(self, restrict):
[  571s]         """
[  571s]         Should scan another token and add it to the list, self.tokens,
[  571s]         and add the restriction to self.restrictions
[  571s]         """
[  571s]         # Keep looking for a token, ignoring any in self.ignore
[  571s]         if DEBUG:
[  571s]             print()
[  571s]             print("Being asked to match with restriction:", repr(restrict))
[  571s]         token = None
[  571s]         while True:
[  571s]             best_pat = None
[  571s]             # Search the patterns for a match, with earlier
[  571s]             # tokens in the list having preference
[  571s]             best_pat_len = 0
[  571s]             for tok, regex in self.patterns:
[  571s]                 if DEBUG:
[  571s]                     print("\tTrying %s: %s at pos %d -> %s" % (repr(tok), repr(regex.pattern), self.pos, repr(self.input)))
[  571s]                 # First check to see if we're restricting to this token
[  571s]                 if restrict and tok not in restrict and tok not in self.ignore:
[  571s]                     if DEBUG:
[  571s]                         print("\tSkipping %r!" % (tok,))
[  571s]                     continue
[  571s]                 m = regex.match(self.input, self.pos)
[  571s]                 if m:
[  571s]                     # We got a match
[  571s]                     best_pat = tok
[  571s]                     best_pat_len = len(m.group(0))
[  571s]                     if DEBUG:
[  571s]                         print("Match OK! %s: %s at pos %d" % (repr(tok), repr(regex.pattern), self.pos))
[  571s]                     break
[  571s]     
[  571s]             # If we didn't find anything, raise an error
[  571s]             if best_pat is None:
[  571s] >               raise SassSyntaxError(self.input, self.pos, restrict)
[  571s] E               scss.errors.SassSyntaxError: Syntax error: Found 'yellow #FF' but expected one of ADD, ALPHA_FUNCTION, BANG_IMPORTANT, BAREWORD, COLOR, DOUBLE_QUOTE, FNCT, IF_FUNCTION, INTERP_START, LITERAL_FUNCTION, LPAR, NOT, NUM, SIGN, SINGLE_QUOTE, URL_FUNCTION, VAR
[  571s] 
[  571s] scss/grammar/scanner.py:236: SassSyntaxError
[  571s] =============================== warnings summary ===============================
[  571s] scss/compiler.py:1430
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1430: DeprecationWarning: invalid escape sequence '\:'
[  571s]     result = tb * (i + nesting) + "@media -sass-debug-info{filename{font-family:file\:\/\/%s}line{font-family:\\00003%s}}" % (filename, lineno) + nl
[  571s] 
[  571s] scss/cssdefs.py:497
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/cssdefs.py:497: DeprecationWarning: invalid escape sequence '\s'
[  571s]     _has_code_re = re.compile('''
[  571s] 
[  571s] conftest.py:62: 142 warnings
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/conftest.py:62: PytestRemovedIn8Warning: The (fspath: py.path.local) argument to SassFile is deprecated. Please use the (path: pathlib.Path) argument instead.
[  571s]   See https://docs.pytest.org/en/latest/deprecations.html#fspath-argument-for-node-constructors-replaced-with-pathlib-path
[  571s]     return SassFile.from_parent(parent, fspath=path)
[  571s] 
[  571s] scss/tests/test_misc.py:55
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/test_misc.py:55: DeprecationWarning: invalid escape sequence '\:'
[  571s]     expected = """\
[  571s] 
[  571s] scss/tests/test_misc.py::test_extend_across_files
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at first.css:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/test_misc.py::test_extend_across_files
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at first.css:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/test_misc.py::test_extend_across_files
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at second.css:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'reverse_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss:1)
[  571s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s] 
[  571s] scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  571s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  571s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  571s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  571s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/selector.py:180: FutureWarning: The xCSS 'self' selector is deprecated and will be removed in 2.0.  Use & instead.  (<SimpleSelector: 'self'>)
[  571s]     warn(FutureWarning(
[  571s] 
[  571s] scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/005-extends.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/005-extends.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/006-extends-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/006-extends-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/010-math.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/010-math.scss:1)
[  571s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s] 
[  571s] scss/tests/files/original-doctests/011-math-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/011-math-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/012-math-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/012-math-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/015-nesting-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/015-nesting-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/022-extend-multiple.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/022-extend-multiple.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/025-forum.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/025-forum.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1015: SassDeprecationWarning: @variables and @vars are deprecated.  Just assign variables at top-level. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1040: SassDeprecationWarning: Assignment with = is deprecated; use : instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss:1)
[  571s]     warn_deprecated(rule, "Assignment with = is deprecated; use : instead.")
[  571s] 
[  571s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/027-forum-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/027-forum-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/030-errors-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/030-errors-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/039-math-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-math-4.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/original-doctests/041-another-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:1176: SassDeprecationWarning: The XCSS 'a extends b' syntax is deprecated.  Use 'a { @extend b; }' instead. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/041-another-extend.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-32.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-32.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-4.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] scss/tests/files/regressions/issue-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss
[  571s]   /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/compiler.py:524: SassDeprecationWarning: The 'short_colors' @option no longer has any effect. (at /home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-7.scss:1)
[  571s]     warn_deprecated(
[  571s] 
[  571s] -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
[  571s] =========================== short test summary info ============================
[  571s] FAILED scss/tests/test_expression.py::test_reference_operations - re.error: g...
[  571s] FAILED scss/tests/test_expression.py::test_functions - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/test_expression.py::test_parse_strings - scss.errors.SassSy...
[  571s] FAILED scss/tests/test_expression.py::test_parse_bang_important - scss.errors...
[  571s] FAILED scss/tests/test_expression.py::test_parse_special_functions - scss.err...
[  571s] FAILED scss/tests/test_misc.py::test_super_selector - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/test_misc.py::test_debug_info - scss.errors.SassSyntaxError...
[  571s] FAILED scss/tests/test_misc.py::test_live_errors - scss.errors.SassSyntaxErro...
[  571s] FAILED scss/tests/extension/test_core.py::test_rgb - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_rgba - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_red - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_green - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/extension/test_core.py::test_blue - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_mix - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_hsl - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_hsla - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_hue - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_saturation - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_lightness - scss.errors.SassSy...
[  571s] FAILED scss/tests/extension/test_core.py::test_adjust_hue - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_lighten - scss.errors.SassSynt...
[  571s] FAILED scss/tests/extension/test_core.py::test_darken - scss.errors.SassSynta...
[  571s] FAILED scss/tests/extension/test_core.py::test_saturate - scss.errors.SassSyn...
[  571s] FAILED scss/tests/extension/test_core.py::test_desaturate - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_grayscale - scss.errors.SassSy...
[  571s] FAILED scss/tests/extension/test_core.py::test_grayscale_css_filter - scss.er...
[  571s] FAILED scss/tests/extension/test_core.py::test_complement - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_invert - scss.errors.SassSynta...
[  571s] FAILED scss/tests/extension/test_core.py::test_invert_css_filter - scss.error...
[  571s] FAILED scss/tests/extension/test_core.py::test_alpha_opacity - scss.errors.Sa...
[  571s] FAILED scss/tests/extension/test_core.py::test_alpha_ie_filter - scss.errors....
[  571s] FAILED scss/tests/extension/test_core.py::test_opacify_fadein - scss.errors.S...
[  571s] FAILED scss/tests/extension/test_core.py::test_transparentize_fadeout - scss....
[  571s] FAILED scss/tests/extension/test_core.py::test_adjust_color - scss.errors.Sas...
[  571s] FAILED scss/tests/extension/test_core.py::test_scale_color - scss.errors.Sass...
[  571s] FAILED scss/tests/extension/test_core.py::test_change_color - scss.errors.Sas...
[  571s] FAILED scss/tests/extension/test_core.py::test_ie_hex_str - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_unquote - scss.errors.SassSynt...
[  571s] FAILED scss/tests/extension/test_core.py::test_quote - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/extension/test_core.py::test_str_length - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_str_insert - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_str_index - scss.errors.SassSy...
[  571s] FAILED scss/tests/extension/test_core.py::test_str_slice - scss.errors.SassSy...
[  571s] FAILED scss/tests/extension/test_core.py::test_to_upper_case - scss.errors.Sa...
[  571s] FAILED scss/tests/extension/test_core.py::test_to_lower_case - scss.errors.Sa...
[  571s] FAILED scss/tests/extension/test_core.py::test_percentage - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_round - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/extension/test_core.py::test_ceil - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_floor - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/extension/test_core.py::test_abs - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_min - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_max - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_length - scss.errors.SassSynta...
[  571s] FAILED scss/tests/extension/test_core.py::test_nth - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_join - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_append - scss.errors.SassSynta...
[  571s] FAILED scss/tests/extension/test_core.py::test_zip - scss.errors.SassSyntaxEr...
[  571s] FAILED scss/tests/extension/test_core.py::test_index - scss.errors.SassSyntax...
[  571s] FAILED scss/tests/extension/test_core.py::test_list_separator - scss.errors.S...
[  571s] FAILED scss/tests/extension/test_core.py::test_set_nth - scss.errors.SassSynt...
[  571s] FAILED scss/tests/extension/test_core.py::test_map_get - scss.errors.SassSynt...
[  571s] FAILED scss/tests/extension/test_core.py::test_map_merge - scss.errors.SassSy...
[  571s] FAILED scss/tests/extension/test_core.py::test_map_keys - scss.errors.SassSyn...
[  571s] FAILED scss/tests/extension/test_core.py::test_map_values - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_map_has_key - scss.errors.Sass...
[  571s] FAILED scss/tests/extension/test_core.py::test_type_of - scss.errors.SassSynt...
[  571s] FAILED scss/tests/extension/test_core.py::test_unit - scss.errors.SassSyntaxE...
[  571s] FAILED scss/tests/extension/test_core.py::test_unitless - scss.errors.SassSyn...
[  571s] FAILED scss/tests/extension/test_core.py::test_comparable - scss.errors.SassS...
[  571s] FAILED scss/tests/extension/test_core.py::test_if - scss.errors.SassSyntaxErr...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_blank - scss.errors...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_compact - scss.erro...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_reject - scss.error...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_first_value_of - sc...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_enumerate - scss.er...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_headings - scss.err...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_nest - scss.errors....
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_opposite_position
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_pi - scss.errors.Sa...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_e - scss.errors.Sas...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_sqrt - scss.errors....
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_log - scss.errors.S...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_pow - scss.errors.S...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_font_url - scss.err...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_font_files - scss.e...
[  571s] FAILED scss/tests/extension/compass/test_helpers.py::test_inline_font_files
[  571s] FAILED scss/tests/extension/compass/test_images.py::test_image_url - scss.err...
[  571s] FAILED scss/tests/files/bugs/append.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/append.scss
[  571s] FAILED scss/tests/files/bugs/argspec-named-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-named-arguments.scss
[  571s] FAILED scss/tests/files/bugs/argspec-slurpy-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/argspec-slurpy-arguments.scss
[  571s] FAILED scss/tests/files/bugs/at-rules-1.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-1.scss
[  571s] FAILED scss/tests/files/bugs/at-rules-compressed-semicolon.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-compressed-semicolon.scss
[  571s] FAILED scss/tests/files/bugs/at-rules-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/at-rules-interpolation.scss
[  571s] FAILED scss/tests/files/bugs/base64url.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/base64url.scss
[  571s] FAILED scss/tests/files/bugs/colors-preserve-names.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/colors-preserve-names.scss
[  571s] FAILED scss/tests/files/bugs/extend-child-selector.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-child-selector.scss
[  571s] FAILED scss/tests/files/bugs/extend-common-prefix-complex.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-common-prefix-complex.scss
[  571s] FAILED scss/tests/files/bugs/extend-selector-order.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/extend-selector-order.scss
[  571s] FAILED scss/tests/files/bugs/if-with-parentheses.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/if-with-parentheses.scss
[  571s] FAILED scss/tests/files/bugs/interpolation-timing.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/interpolation-timing.scss
[  571s] FAILED scss/tests/files/bugs/names-equivalence.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/names-equivalence.scss
[  571s] FAILED scss/tests/files/bugs/trailing-combinators.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/trailing-combinators.scss
[  571s] FAILED scss/tests/files/bugs/unit-float-precision.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/unit-float-precision.scss
[  571s] FAILED scss/tests/files/bugs/variables-font-face-default.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/bugs/variables-font-face-default.scss
[  571s] FAILED scss/tests/files/compass/current-color.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/current-color.scss
[  571s] FAILED scss/tests/files/compass/gradients.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/compass/gradients.scss
[  571s] FAILED scss/tests/files/general/000-smoketest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/000-smoketest.scss
[  571s] FAILED scss/tests/files/general/each-destructuring-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-2.scss
[  571s] FAILED scss/tests/files/general/each-destructuring-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring-3.scss
[  571s] FAILED scss/tests/files/general/each-destructuring.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/each-destructuring.scss
[  571s] FAILED scss/tests/files/general/empty-list-included.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/empty-list-included.scss
[  571s] FAILED scss/tests/files/general/global-variable-exists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/global-variable-exists.scss
[  571s] FAILED scss/tests/files/general/if-lazy.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/if-lazy.scss
[  571s] FAILED scss/tests/files/general/interpolation-acid.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-acid.scss
[  571s] FAILED scss/tests/files/general/interpolation-mixin-name.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/interpolation-mixin-name.scss
[  571s] FAILED scss/tests/files/general/maps-complex-keys.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-complex-keys.scss
[  571s] FAILED scss/tests/files/general/maps-example-lists.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example-lists.scss
[  571s] FAILED scss/tests/files/general/maps-example.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/maps-example.scss
[  571s] FAILED scss/tests/files/general/names-loop-variable.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/names-loop-variable.scss
[  571s] FAILED scss/tests/files/general/null-values.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/null-values.scss
[  571s] FAILED scss/tests/files/general/scoping-mixin-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin-2.scss
[  571s] FAILED scss/tests/files/general/scoping-mixin.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-mixin.scss
[  571s] FAILED scss/tests/files/general/scoping-nested-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested-2.scss
[  571s] FAILED scss/tests/files/general/scoping-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/scoping-nested.scss
[  571s] FAILED scss/tests/files/general/slurpy-keyword-args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/general/slurpy-keyword-args.scss
[  571s] FAILED scss/tests/files/kronuz/args.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/args.scss
[  571s] FAILED scss/tests/files/kronuz/functions-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/functions-context.scss
[  571s] FAILED scss/tests/files/kronuz/image-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/image-colors.scss
[  571s] FAILED scss/tests/files/kronuz/imports-unused.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/imports-unused.scss
[  571s] FAILED scss/tests/files/kronuz/linear-gradient.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/linear-gradient.scss
[  571s] FAILED scss/tests/files/kronuz/lists-circular-nth.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/lists-circular-nth.scss
[  571s] FAILED scss/tests/files/kronuz/mixin-varargs.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixin-varargs.scss
[  571s] FAILED scss/tests/files/kronuz/mixins-context.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/mixins-context.scss
[  571s] FAILED scss/tests/files/kronuz/order-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/order-test.scss
[  571s] FAILED scss/tests/files/kronuz/reversed-range.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/reversed-range.scss
[  571s] FAILED scss/tests/files/kronuz/rgba-colors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/rgba-colors.scss
[  571s] FAILED scss/tests/files/kronuz/scope-loop-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scope-loop-variables.scss
[  571s] FAILED scss/tests/files/kronuz/scoping-control.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/scoping-control.scss
[  571s] FAILED scss/tests/files/kronuz/selectors-append-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-append-nest.scss
[  571s] FAILED scss/tests/files/kronuz/selectors-nest.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-nest.scss
[  571s] FAILED scss/tests/files/kronuz/selectors-special.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/selectors-special.scss
[  571s] FAILED scss/tests/files/kronuz/sprite-map.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/sprite-map.scss
[  571s] FAILED scss/tests/files/kronuz/style-nested.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/kronuz/style-nested.scss
[  571s] FAILED scss/tests/files/original-doctests/000-general.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/000-general.scss
[  571s] FAILED scss/tests/files/original-doctests/001-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/001-variables.scss
[  571s] FAILED scss/tests/files/original-doctests/002-nesting-children.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/002-nesting-children.scss
[  571s] FAILED scss/tests/files/original-doctests/003-nesting-children-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/003-nesting-children-2.scss
[  571s] FAILED scss/tests/files/original-doctests/004-nesting-children-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/004-nesting-children-3.scss
[  571s] FAILED scss/tests/files/original-doctests/007-extends-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/007-extends-3.scss
[  571s] FAILED scss/tests/files/original-doctests/008-extends-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/008-extends-4.scss
[  571s] FAILED scss/tests/files/original-doctests/009-extends-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/009-extends-5.scss
[  571s] FAILED scss/tests/files/original-doctests/013-nesting.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/013-nesting.scss
[  571s] FAILED scss/tests/files/original-doctests/014-nesting-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/014-nesting-2.scss
[  571s] FAILED scss/tests/files/original-doctests/016-variables.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/016-variables.scss
[  571s] FAILED scss/tests/files/original-doctests/017-interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/017-interpolation.scss
[  571s] FAILED scss/tests/files/original-doctests/018-mixins.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/018-mixins.scss
[  571s] FAILED scss/tests/files/original-doctests/019-mixins-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/019-mixins-2.scss
[  571s] FAILED scss/tests/files/original-doctests/020-mixins-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/020-mixins-3.scss
[  571s] FAILED scss/tests/files/original-doctests/021-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/021-extend.scss
[  571s] FAILED scss/tests/files/original-doctests/023-extend-multiple-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/023-extend-multiple-2.scss
[  571s] FAILED scss/tests/files/original-doctests/024-extend-placeholder.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/024-extend-placeholder.scss
[  571s] FAILED scss/tests/files/original-doctests/026-forum-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/026-forum-2.scss
[  571s] FAILED scss/tests/files/original-doctests/028-errors.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/028-errors.scss
[  571s] FAILED scss/tests/files/original-doctests/029-errors-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/029-errors-2.scss
[  571s] FAILED scss/tests/files/original-doctests/031-test.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/031-test.scss
[  571s] FAILED scss/tests/files/original-doctests/032-test-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/032-test-2.scss
[  571s] FAILED scss/tests/files/original-doctests/033-test-3.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/033-test-3.scss
[  571s] FAILED scss/tests/files/original-doctests/034-test-4.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/034-test-4.scss
[  571s] FAILED scss/tests/files/original-doctests/035-test-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/035-test-5.scss
[  571s] FAILED scss/tests/files/original-doctests/036-test-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/036-test-6.scss
[  571s] FAILED scss/tests/files/original-doctests/037-test-7.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/037-test-7.scss
[  571s] FAILED scss/tests/files/original-doctests/038-test-8.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/038-test-8.scss
[  571s] FAILED scss/tests/files/original-doctests/039-hover-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/039-hover-extend.scss
[  571s] FAILED scss/tests/files/original-doctests/040-complex-sequence-extend.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/original-doctests/040-complex-sequence-extend.scss
[  571s] FAILED scss/tests/files/regressions/args-vars.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/args-vars.scss
[  571s] FAILED scss/tests/files/regressions/argspec-default-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-default-arguments.scss
[  571s] FAILED scss/tests/files/regressions/argspec-no-arguments.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-no-arguments.scss
[  571s] FAILED scss/tests/files/regressions/argspec-trailing-comma.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/argspec-trailing-comma.scss
[  571s] FAILED scss/tests/files/regressions/interpolation-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation-2.scss
[  571s] FAILED scss/tests/files/regressions/interpolation.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/interpolation.scss
[  571s] FAILED scss/tests/files/regressions/issue-10.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-10.scss
[  571s] FAILED scss/tests/files/regressions/issue-110.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-110.scss
[  571s] FAILED scss/tests/files/regressions/issue-2.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-2.scss
[  571s] FAILED scss/tests/files/regressions/issue-21.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-21.scss
[  571s] FAILED scss/tests/files/regressions/issue-258.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-258.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-a.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-a.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-b.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-b.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-c.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-c.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-d.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-d.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-e.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-e.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-f.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-f.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-g.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-g.scss
[  571s] FAILED scss/tests/files/regressions/issue-334-h.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-334-h.scss
[  571s] FAILED scss/tests/files/regressions/issue-40.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-40.scss
[  571s] FAILED scss/tests/files/regressions/issue-5.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-5.scss
[  571s] FAILED scss/tests/files/regressions/issue-52.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-52.scss
[  571s] FAILED scss/tests/files/regressions/issue-6.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/issue-6.scss
[  571s] FAILED scss/tests/files/regressions/nth-inside-each.scss::/home/abuild/rpmbuild/BUILD/pyScss-1.4.0/scss/tests/files/regressions/nth-inside-each.scss
[  571s] = 198 failed, 43 passed, 7 skipped, 1 deselected, 1 xfailed, 217 warnings in 288.53s (0:04:48) =
[  571s] error: Bad exit status from /var/tmp/rpm-tmp.B6AkES (%check)
[  571s] 
[  571s] RPM build errors:
[  571s]     Bad exit status from /var/tmp/rpm-tmp.B6AkES (%check)
[  571s] ### VM INTERACTION START ###
[  572s] [  565.674415][    T1] sysrq: Power Off
[  572s] [  565.676031][   T18] reboot: Power down
[  572s] ### VM INTERACTION END ###
[  572s] 
[  572s] sheep88 failed "build python-pyScss.spec" at Sat Feb 18 21:34:56 UTC 2023.
[  572s] 
